{
 "userName": "AxleMike",
 "date": "2026-02-28T18:09:47.776Z",
 "numShaders": 15,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "Xls3DM",
    "date": "1422494432",
    "viewed": 668,
    "name": "A Simple Ray Tracer",
    "description": "My first ray tracer.  Basically a testbed to mess around in.",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raytracing",
     "raytracer",
     "sphere",
     "softshadows",
     "plane"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// A rough draft of a ray tracer, I need to go back through and fix some artifacts and optimize\n\n// References:\n// Used iq's noise example and anji's ray tracer as initial examples\n\n// https://www.shadertoy.com/view/lsf3WH\n// https://www.shadertoy.com/view/4dsGRn\n\n//////////////////////////////////////////////////\n// Settings\n//////////////////////////////////////////////////\n#define     NUMBER_OF_BOUNCES   \t4\n#define     MATERIALS_ENABLED   \t1\n#define     SHADOWS_ENABLED     \t1\n#define     SOFT_SHADOWS_ENABLED\t1\n#define \tSOFT_SHADOW_SAMPLES\t\t26 // 100 looks nice but is slow, need to optimize\n#define     SHOW_NORMALS        \t0\n\n//////////////////////////////////////////////////\n// Constants\n//////////////////////////////////////////////////\nconst float     PI \t\t\t\t = 3.14159265359;\nconst float     MAX_DISTANCE \t = 1000.0;\nconst float     EPSILON \t\t = 0.001;\n\n//////////////////////////////////////////////////\n// Helpers\n//////////////////////////////////////////////////  \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Noise(in vec2 uv)\n{ \n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453); \n} \n\nfloat ComputeFresnel(in float NdotV)\n{\n\tconst float fresnelReflectionIndex = 0.01;\n\tfloat fresnel = fresnelReflectionIndex + (1.0 - fresnelReflectionIndex) * pow((1.0 - NdotV), 5.0);\n    return fresnel;\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float rc = 1.0 - c;\n    \n    return mat3(rc * axis.x * axis.x + c,          rc * axis.x * axis.y - axis.z * s, rc * axis.z * axis.x + axis.y * s,\n                rc * axis.x * axis.y + axis.z * s, rc * axis.y * axis.y + c,          rc * axis.y * axis.z - axis.x * s,\n                rc * axis.z * axis.x - axis.y * s, rc * axis.y * axis.z + axis.x * s, rc * axis.z * axis.z + c);\n}\n\n//////////////////////////////////////////////////\n// Materials\n//////////////////////////////////////////////////  \nstruct Material\n{\n    vec3    mAlbedo;\n    vec3    mSpecular;\n    float   mMicrosurface;\n};\n    \nconst int NUMBER_OF_MATERIALS = 5;\nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nvoid InitializeMaterials()\n{\n    gMaterials[0] = Material(vec3(0.8, 0.8, 0.8), vec3(0.80), 1.0);\n    gMaterials[1] = Material(vec3(0.1, 1.0, 0.1), vec3(0.32), 0.3);\n    gMaterials[2] = Material(vec3(1.0, 0.7, 0.0), vec3(0.42), 0.1);\n    gMaterials[3] = Material(vec3(0.4, 0.4, 0.8), vec3(0.05), 0.2); \n    gMaterials[4] = Material(vec3(0.9, 0.1, 0.1), vec3(0.02), 0.2); \n}\n\n//////////////////////////////////////////////////\n// Geometry\n//////////////////////////////////////////////////\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n};    \n\nstruct Sphere\n{\n    vec3    mCenter;\n    float   mRadius;\n\n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n\nstruct Plane\n{\n    vec3    mNormal;\n    float   mD;\n    \n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n        \n//////////////////////////////////////////////////\n// Intersection Helpers\n//////////////////////////////////////////////////   \nstruct IntersectionPoint\n{\n    vec3        mPoint;\n    vec3        mNormal;\n    float       mT;\n    \n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n    \nIntersectionPoint GetClosestIntersection(in IntersectionPoint a, in IntersectionPoint b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;  \n}\n  \nbool IsIntersectionValid(in IntersectionPoint a)\n{\n    return (a.mT < (MAX_DISTANCE - EPSILON));  \n}\n\n//////////////////////////////////////////////////\n// Creation Helpers\n////////////////////////////////////////////////// \n#if MATERIALS_ENABLED\n#define CREATE_SPHERE(position, radius, material) Sphere(position, radius, material)\n#define CREATE_PLANE(normal, d, material) Plane(normalize(normal), d, material)\n#define CREATE_TRIANGLE(a, b, c, material) Triangle(a, b, c, material)\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE, gMaterials[0])\n#else\n#define CREATE_SPHERE(position, radius, material) Sphere(position, radius)    \n#define CREATE_PLANE(normal, d, material) Plane(normalize(normal), d)   \n#define CREATE_TRIANGLE(a, b, c) Triangle(a, b, c)\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE) \n#endif // MATERIALS_ENABLED  \n\n//////////////////////////////////////////////////\n// Intersection Tests\n////////////////////////////////////////////////// \nIntersectionPoint RayPlaneIntersectionTest(in Ray ray, in Plane plane)\n{\n    IntersectionPoint intersection = INVALID_INTERSECTION;\n    \n    float numerator = plane.mD - dot(plane.mNormal, ray.mPosition);\n    float denominator = dot(plane.mNormal, ray.mDirection);\n    if(abs(denominator) > EPSILON)\n    {\n        float t = numerator / denominator;\n        if(t > EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = plane.mNormal;\n            intersection.mT = t;\n\n#if MATERIALS_ENABLED\n            intersection.mMaterial = plane.mMaterial;\n#endif // MATERIALS_ENABLED   \n        }\n    }\n    return intersection;\n}\n\nIntersectionPoint RaySphereIntersectionTest(in Ray ray, in Sphere sphere)\n{   \n    IntersectionPoint intersection = INVALID_INTERSECTION;\n\n    float sRadiusSquared = sphere.mRadius * sphere.mRadius;\n    vec3 eDistance = ray.mPosition - sphere.mCenter;\n    \n    float b = dot(eDistance, ray.mDirection);\n    float c = dot(eDistance, eDistance) - sRadiusSquared;\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        float t = max(-b - sqrt(discriminant), 0.0); // clamp t to zero incase it started inside the sphere\n           \n        if(discriminant >= EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = normalize(intersection.mPoint - sphere.mCenter);\n            intersection.mT = t;\n      \n#if MATERIALS_ENABLED\n            intersection.mMaterial = sphere.mMaterial;\n#endif // MATERIALS_ENABLED          \n       }      \n    }\n    return intersection;\n}\n\nIntersectionPoint CheckSceneForIntersection(in Ray currentRay)\n{\n    // Spheres\n    Sphere sphere0 = CREATE_SPHERE(vec3(-1.3, -0.2, -0.2), 0.2 + pow(abs(sin(iTime * PI * 0.4 + 0.2) * 0.4), 2.0), gMaterials[1]);  \n    Sphere sphere1 = CREATE_SPHERE(vec3(-0.1, (sin(iTime * PI * 0.4) * 0.75) + 0.35, -0.5), 0.7, gMaterials[2]);  \n    Sphere sphere2 = CREATE_SPHERE(vec3(0.9, -0.05, 0.2), 0.4, gMaterials[3]);\n    Sphere sphere3 = CREATE_SPHERE(vec3(0.1 + (cos(iTime * PI * 0.4)), 0.8, 0.7), 0.5, gMaterials[4]);\n\n    // Check scene for intersection   \n    IntersectionPoint sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere0);\n    IntersectionPoint sphereIntersection1 = RaySphereIntersectionTest(currentRay, sphere1);\n    IntersectionPoint closestIntersection = GetClosestIntersection(sphereIntersection0, sphereIntersection1);\n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere2);\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere3);\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n   \n    // Ground Plane\n    Plane plane0 = CREATE_PLANE(vec3(0.0, 1.0, 0.0), -1.1, gMaterials[0]);  \n    IntersectionPoint planeIntersection = RayPlaneIntersectionTest(currentRay, plane0);\n    closestIntersection = GetClosestIntersection(closestIntersection, planeIntersection);\n     \n    return closestIntersection;\n}\n\n//////////////////////////////////////////////////\n// Lighting Helpers\n//////////////////////////////////////////////////\nstruct DirectionalLight\n{\n    vec3 mDirection;\n    vec3 mColor;\n}; \n    \nvec3 ApplyDirectionalLight(in DirectionalLight light, in IntersectionPoint geometryIntersection, in vec3 startingPoint)\n{\n    // Determine some values\n    vec3 normal = normalize(geometryIntersection.mNormal);\n    vec3 lightDirection = normalize(-light.mDirection);\n    vec3 viewVector = normalize(startingPoint - geometryIntersection.mPoint);\n    vec3 halfVector = normalize(lightDirection + viewVector);\n    \n    // Wolfgang's cook torrence approach from Programming Vertex and Pixel shaders \n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = Saturate(dot(normal, viewVector));\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float NHSquared = NdotH * NdotH;\n    float roughnessSquared = geometryIntersection.mMaterial.mMicrosurface * geometryIntersection.mMaterial.mMicrosurface;\n    \n    float microfacets = 0.0;\n    float geometricAttenuation = 0.0;\n    vec3 specular = vec3(0.0);\n    \n    float denom0 = roughnessSquared * NHSquared;\n    float denom1 = denom0 * NHSquared;\n    \n    if((abs(denom0) > EPSILON) && (abs(denom1) > EPSILON))\n    {\n    \tmicrofacets = (1.0 / denom1) * (exp(-((1.0 - NHSquared) / denom0))); // D\n    }\n   \tif(abs(VdotH) > EPSILON)\n    {\n    \tgeometricAttenuation = min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)); // G\n    }\n    float fresnel = ComputeFresnel(NdotV); // F\n    \n    float denom2 = PI * NdotL * NdotV;\n    if(abs(denom2) > EPSILON)\n    {\n    \tspecular = (fresnel * microfacets * geometricAttenuation) / denom2 * geometryIntersection.mMaterial.mSpecular;\n    }\n    vec3 lighting = ((NdotL * Saturate(1.5 * ((0.7 * NdotL * geometryIntersection.mMaterial.mAlbedo + specular)))))  * light.mColor;\n        \n    // Cast a ray to check for shadows\n    float shadow = 1.0;\n#if SHADOWS_ENABLED\n   \n#if SOFT_SHADOWS_ENABLED  \n    // Create slight varations around the incomming light direction for sampling\n    vec3 axis0 = normalize(cross(lightDirection, vec3(0.0, 1.0, 0.0)));\n    vec3 axis1 = normalize(cross(lightDirection, axis0));\n                       \n    for(int i = 0; i < SOFT_SHADOW_SAMPLES; ++i)\n    {   \n        float index = float(i);\n        float sampleIndex = index / float(SOFT_SHADOW_SAMPLES / 4) * 2.0 * PI + Noise(startingPoint.xz);\n     \tfloat pushAmount = (mod(index, 4.0) + 1.0) * 0.25;\n        vec3 offset = (cos(sampleIndex) * axis0 + sin(sampleIndex) * axis1) * pushAmount * 0.01;\n        \n    \tRay shadowRay = Ray(geometryIntersection.mPoint + (EPSILON * normal), (lightDirection + offset));\n    \tIntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n        shadow += IsIntersectionValid(lightIntersection) ? 0.0 : 1.0; // Determine if we hit an object and are in a shadow region\n    }\n    shadow /= float(SOFT_SHADOW_SAMPLES);\n#else\n    Ray shadowRay = Ray(geometryIntersection.mPoint + (EPSILON * normal), lightDirection);\n    IntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n    shadow = IsIntersectionValid(lightIntersection) ? 0.0 : shadow; // Determine if we hit an object and are in a shadow region\n#endif // SOFT_SHADOWS_ENABLED\n    \n#endif // SHADOWS_ENABLED\n    \n    return (lighting * shadow);\n}\n\nvec3 CalculateLighting(in IntersectionPoint intersection, in vec3 startingPoint)\n{\n    DirectionalLight directionalLight = DirectionalLight(vec3(0.4, -1.0, -0.8), vec3(1.0));    \n    return ApplyDirectionalLight(directionalLight, intersection, startingPoint);\n}\n\n//////////////////////////////////////////////////\n// Implementation\n//////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    InitializeMaterials();\n\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    float aspectRatio = (iResolution.x / iResolution.y);\n    vec2 uv =  2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec2 aspectRatioAdjustedUVs = vec2(uv.x * aspectRatio, uv.y);\n       \n    // Rotate the scene\n    float rotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * PI * 2.0 : (iTime * PI) * 0.1; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 rotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), rotationValue);\n    vec3 cameraPosition = vec3(2.0 * sin(rotationValue), 0.0, 2.0 * cos(rotationValue));\n    \n    // Determine the inital ray, the camera ray \n    vec3 cameraRayDirection = normalize(vec3(aspectRatioAdjustedUVs.xy, -1.0));\n    cameraRayDirection = (rotationMatrix * cameraRayDirection);\n    Ray ray = Ray(cameraPosition, cameraRayDirection);\n          \n    vec3 color = vec3(0.0);\n    \n    // Find the first collision\n    IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\n#if SHOW_NORMALS    \n    vec3 normal = currentIntersection.mNormal;\n#endif // SHOW_NORMALS\n    \n    vec3 specular = vec3(1.0); // Specular starts at one and will decrease with every bounce\n\tvec3 lighting = vec3(1.0); // Lighting starts at one so background cubemap will be lit\n \n    for(int i = 0; i < NUMBER_OF_BOUNCES; ++i)\n    {\n        // Only apply the bounces if we actually hit something\n        if(IsIntersectionValid(currentIntersection))\n        {\n            lighting = CalculateLighting(currentIntersection, ray.mPosition);\n            color += (lighting * specular);\n            \n            specular *= (currentIntersection.mMaterial.mSpecular); \n\n            // Determine the bounce direction of the ray and update the structure\n            ray.mDirection = reflect(ray.mDirection, currentIntersection.mNormal);\n            ray.mPosition = currentIntersection.mPoint + ray.mDirection * EPSILON;\n\n            // Trace the ray forward\n            currentIntersection = CheckSceneForIntersection(ray);\n        }\n        else\n        {\n            // We didn't hit anything, so return the texture cube color and break out!\n            color.rgb += texture(iChannel0, ray.mDirection).rgb * specular; \n            break; \n        }\n    }\n    \n#if SHOW_NORMALS    \n    fragColor = vec4(normal * 0.5 + 0.5, 1.0); // Modify the normal to go from [0,0] to [1,1]\n#else\n    fragColor = vec4(color.rgb, 1.0);\n#endif \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlfSzj",
    "date": "1437788127",
    "viewed": 635,
    "name": "Simple Text Example",
    "description": "Simple Text Example\n\nInitial implementation was based on https://www.shadertoy.com/view/XsBGRt\n\nI may take another pass at this and try to make it a bit more flexible.\n",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "text"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/**\n * References:\n *\n * - https://www.shadertoy.com/view/XsBGRt\n*/\n\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n\n#define SPACE(position) position.x -= 8.0 \n#define NEGATIVE(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n\n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\nfloat WriteString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    textCursor *= iResolution.xy;\n        \n    fragCoord = (fragCoord.xy * iResolution.xy) / scale;\n    vec2 textPos = floor(fragCoord.xy - (textCursor.xy  / scale) + 1.0);\n    \n    if (textPos.y < 1.0 || textPos.y > 8.0)\n    {\n        return 0.0;\n    }\n    \n    float bitVal = 0.0;\n\n    bitVal += LETTER_A(textPos);\n    bitVal += LETTER_B(textPos);\n    bitVal += LETTER_C(textPos);\n    bitVal += LETTER_D(textPos);\n    bitVal += LETTER_E(textPos);\n    bitVal += LETTER_F(textPos);\n    bitVal += LETTER_G(textPos);\n    bitVal += LETTER_H(textPos);\n    bitVal += LETTER_I(textPos);\n    bitVal += LETTER_J(textPos);\n    bitVal += LETTER_K(textPos);\n    bitVal += LETTER_L(textPos);\n    bitVal += LETTER_M(textPos);\n    bitVal += LETTER_N(textPos);\n    bitVal += LETTER_O(textPos);\n    bitVal += LETTER_P(textPos);   \n    bitVal += LETTER_Q(textPos);\n    bitVal += LETTER_R(textPos);\n    bitVal += LETTER_S(textPos);    \n    bitVal += LETTER_T(textPos);  \n    bitVal += LETTER_U(textPos);  \n    bitVal += LETTER_V(textPos);    \n    bitVal += LETTER_W(textPos);\n    bitVal += LETTER_X(textPos);\n    bitVal += LETTER_Y(textPos);\n    bitVal += LETTER_Z(textPos);\n    \n    SPACE(textPos);\n    \n    bitVal += NEGATIVE(textPos);\n    bitVal += NUMBER_1(textPos);\n    bitVal += NUMBER_2(textPos);\n    bitVal += NUMBER_3(textPos);\n    bitVal += NUMBER_4(textPos);\n    bitVal += NUMBER_5(textPos);\n    bitVal += NUMBER_6(textPos);\n    bitVal += NUMBER_7(textPos);\n    bitVal += NUMBER_8(textPos);\n    bitVal += NUMBER_9(textPos);\n    bitVal += NUMBER_0(textPos);\n\n    return bitVal;\n}\n\nfloat DisplayDigit(in int digit, out vec2 textPos)\n{\n    float bitVal = 0.0;\n    \n    if(digit == 0)      { bitVal += NUMBER_0(textPos); }\n    else if(digit == 1) { bitVal += NUMBER_1(textPos); }\n    else if(digit == 2) { bitVal += NUMBER_2(textPos); }\n    else if(digit == 3) { bitVal += NUMBER_3(textPos); }\n    else if(digit == 4) { bitVal += NUMBER_4(textPos); }\n    else if(digit == 5) { bitVal += NUMBER_5(textPos); }\n    else if(digit == 6) { bitVal += NUMBER_6(textPos); }\n    else if(digit == 7) { bitVal += NUMBER_7(textPos); }\n    else if(digit == 8) { bitVal += NUMBER_8(textPos); }\n    else if(digit == 9) { bitVal += NUMBER_9(textPos); }\n    \n    return bitVal;\n}\n\nfloat WriteInteger(in vec2 textCursor, in vec2 fragCoord, in float scale, in int number)\n{\n    const int MAX_NUMBER_OF_DIGITS = 8;\n    \n    textCursor *= iResolution.xy;\n\n    fragCoord = (fragCoord.xy * iResolution.xy) / scale;\n    vec2 textPos = floor(fragCoord.xy - (textCursor.xy / scale) + 1.0);   \n    \n    if (textPos.y < 1.0 || textPos.y > 8.0)\n    {\n        return 0.0;\n\t}\n      \n    float bitVal = 0.0;\n    \n    if(number < 0)\n    {\n     \tnumber = -number;\n        bitVal += NEGATIVE(textPos);\n    }\n    \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0));\n        foundNonZero = (digit != 0) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero)\n            {\n                bitVal += DisplayDigit(digit, textPos);\n            }\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 textPosition = vec2(0.1, 0.1);\n\n    float textBit = WriteString(textPosition, uv, 2.0);\n    \n    textPosition = vec2(0.1, 0.3);\n    textBit += WriteInteger(textPosition, uv, 2.0, int(iTime));\n    \n    vec3 fontColor = vec3(1.0);\n    fragColor = vec4(fontColor * textBit, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtjSDh",
    "date": "1444021607",
    "viewed": 3151,
    "name": "Parallax Scrolling Star Field",
    "description": "A rough parallax scrolling star field.",
    "likes": 17,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "parallax",
     "starfield"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Voronoi and fractal noise functions based on iq's https://www.shadertoy.com/view/MslGD8\n\nfloat Hash(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    return -1.0 + 2.0 * fract(sin(h) * 43758.5453);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    float h2 = dot(p, vec2(37.271, 377.632));\n    return -1.0 + 2.0 * vec2(fract(sin(h) * 43758.5453), fract(sin(h2) * 43758.5453));\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\nfloat FractalNoise(in vec2 p)\n{\n    p *= 5.0;\n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n\tfloat f = 0.5000 * Noise(p); p = m * p;\n\tf += 0.2500 * Noise(p); p = m * p;\n\tf += 0.1250 * Noise(p); p = m * p;\n\tf += 0.0625 * Noise(p); p = m * p;\n    \n    return f;\n}\n\nvec3 Voronoi(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j)\n    {\n        for(int i = -1; i <= 1; ++i)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = Hash2D(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\treturn vec3(md, mr);\n}\n\nvec3 ApplyFog(in vec2 texCoord)\n{\n    vec3 finalColor = vec3(0.0);\n    \n    vec2 samplePosition = (4.0 * texCoord.xy / iResolution.xy) + vec2(0.0, iTime * 0.0025);\n    float fogAmount = FractalNoise(samplePosition) * 0.175;\n        \n    vec3 fogColor = vec3(texCoord.xy / iResolution.xy + vec2(0.5, 0.0), sin(iTime) * 0.25 + 0.5);\n    finalColor = fogColor * fogAmount * vec3(sin(iTime) * 0.00125 + 0.75);  \n    \n    return finalColor;\n}\n\nvec3 AddStarField(vec2 samplePosition, float threshold)\n{\n    vec3 starValue = Voronoi(samplePosition);\n    if(starValue.x < threshold)\n    {\n        float power = 1.0 - (starValue.x / threshold);\n        return vec3(power * power * power);\n    }\n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxResolution = max(iResolution.x, iResolution.y);\n    \n\tvec3 finalColor = ApplyFog(fragCoord.xy);\n    \n    // Add Star Fields\n    vec2 samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.01);\n    finalColor += AddStarField(samplePosition * 16.0, 0.00125);\n    \n    samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.004);\n    finalColor += AddStarField(samplePosition * 20.0, 0.00125);\n    \n    samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.0005 + 0.5);\n    finalColor += AddStarField(samplePosition * 8.0, 0.0007);\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtSXzK",
    "date": "1451457385",
    "viewed": 291,
    "name": "Noise Functions: 1",
    "description": "A collection of noise functions. \nNeed to fix the text so that it is properly supported for any resolution, right now it just kinda works.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Text\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n#define SPACE(position) position.x -= 8.0 \n#define DASH(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\n#define START_TEXT     fragCoord = (fragCoord.xy*iResolution.xy)/scale; vec2 textPos=floor(fragCoord.xy-(textCursor.xy /scale)+1.0); if(textPos.y<0.0 || textPos.y>8.0) return -1.0; if (fragCoord.x + (scale * 2.0) < textCursor.x) return -1.0;\n#define END_TEXT\t   if (fragCoord.x < (textPos.x * iResolution.x)) return -1.0;\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\n// Shared Strings\n#define NOISE_STRING(bitVal, textPos) bitVal += LETTER_N(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_S(textPos); bitVal += LETTER_E(textPos);\n#define GENERIC_STRING(bitVal, textPos) bitVal += LETTER_G(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_N(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_C(textPos)\n#define TEXTURE_STRING(bitVal, textPos) bitVal = LETTER_T(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_X(textPos); bitVal += LETTER_T(textPos); bitVal += LETTER_U(textPos); bitVal += LETTER_R(textPos);  bitVal += LETTER_E(textPos)\n\n#define FRACTAL_STRING(bitVal, textPos) bitVal = LETTER_F(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_C(textPos); bitVal += LETTER_T(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_L(textPos)\n#define BROWNIAN_STRING(bitVal, textPos) bitVal += LETTER_B(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_W(textPos); bitVal += LETTER_N(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_N(textPos) \n#define MOTION_STRING(bitVal, textPos) bitVal += LETTER_M(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_T(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_N(textPos)\n#define PERLIN_STRING(bitVal, textPos) bitVal += LETTER_P(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_L(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_N(textPos)\n#define LAYERS_STRING(bitVal, textPos) bitVal += LETTER_L(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_Y(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_S(textPos)\n\nfloat WriteRandomNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT     \n    float bitVal = LETTER_R(textPos);\n    bitVal += LETTER_A(textPos);\n    bitVal += LETTER_N(textPos);\n    bitVal += LETTER_D(textPos);\n    bitVal += LETTER_O(textPos);\n    bitVal += LETTER_M(textPos);\n    SPACE(textPos);\n\tNOISE_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WriteTextureNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT      \n    float bitVal = 0.0;\n    TEXTURE_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos)\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WriteGenericNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT\n    float bitVal = 0.0;\n    GENERIC_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WriteFractalBrownianMotionString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT \n    float bitVal = 0.0;\n    FRACTAL_STRING(bitVal, textPos);\n    SPACE(textPos);\n    BROWNIAN_STRING(bitVal, textPos);\n    SPACE(textPos);\n    MOTION_STRING(bitVal, textPos);\n    SPACE(textPos);\n    bitVal += DASH(textPos);\n    SPACE(textPos);\n    GENERIC_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos);\n    SPACE(textPos);\n    bitVal += DASH(textPos);\n    SPACE(textPos);\n    bitVal += NUMBER_7(textPos);\n    SPACE(textPos);\n\tLAYERS_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WritePerlinNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT   \n    float bitVal = 0.0;\n    PERLIN_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos)\n    SPACE(textPos);\n    bitVal += DASH(textPos);\n    SPACE(textPos);\n    bitVal += NUMBER_7(textPos);\n    SPACE(textPos);\n    LAYERS_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\n//////////////////////////////////////////////////\n// Helpers\n//////////////////////////////////////////////////  \nfloat TextureNoise(in vec2 p)\n{\n \treturn texture(iChannel0, p).r; \n}\n\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat RandomNoise(in vec2 p)\n{\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// I believe the following noise function is based on an implementation done by iq in one of his examples, not sure though.  My bad\nfloat Hash(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    return fract(sin(h) * 43758.5453);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(i), Hash(i + vec2(1.0, 0.0)), u.x), mix(Hash(i + vec2(0.0, 1.0)), Hash(i + vec2(1.0)), u.x), u.y);   \n}\n\nfloat FractalBrownianMotion(in vec2 p)\n{\n   float f \n     = Noise(p) * 64.0\n     + Noise(p * 2.0) * 32.0\n   \t + Noise(p * 4.0) * 16.0\n     + Noise(p * 8.0) * 8.0\n     + Noise(p * 16.0) * 4.0\n     + Noise(p * 32.0) * 2.0\n     + Noise(p * 64.0);\n    \n    return f / (1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0 + 64.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 clampValues = vec2(0.5);\n    if(iMouse.z > 0.001)\n    {\n    \tclampValues = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    }\n    vec2 textPoint = vec2(clampValues.x * iResolution.x, clampValues.y * iResolution.y);\n\n    vec3 finalColor;\n    if(uv.y > clampValues.y)\n    {\n        if(uv.x < clampValues.x)\n        {\n            finalColor = vec3(RandomNoise(uv));\n            float textBit = WriteRandomNoiseString(vec2(textPoint.x - 100.0, textPoint.y + 8.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(0.2, 0.8, 0.2);   \n            }\n        }\n        else\n        {\n            finalColor = vec3(Noise(uv * 400.0));\n            float textBit = WriteGenericNoiseString(vec2(textPoint.x + 10.0, textPoint.y + 8.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(1.0, 0.2, 0.2);   \n            }\n        }\n    }\n    else\n    {\n        if(uv.x < clampValues.x)\n        {\n            finalColor = vec3(FractalBrownianMotion(uv * 400.0));\n            float textBit = WriteFractalBrownianMotionString(vec2(textPoint.x - 378.0, textPoint.y - 15.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(0.8, 0.8, 0.2);   \n            }\n        }\n        else\n        {\n            finalColor = vec3(TextureNoise(uv * 2.0));\n            float textBit = WriteTextureNoiseString(vec2(textPoint.x + 10.0, textPoint.y - 15.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(0.5, 0.5, 1.0);   \n            }\n        }\n    }\n\n    // Dividers\n    vec3 dividerColor = vec3(0.7, 1.0, 0.7);\n    float divider = min(smoothstep(0.003, 0.005, abs(uv.x - clampValues.x)), smoothstep(0.003, 0.008, abs(uv.y - clampValues.y)));\n    finalColor = finalColor * divider + dividerColor * (1.0 - divider);\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lstGzf",
    "date": "1454186674",
    "viewed": 442,
    "name": "Mass Effect - Mass Relay",
    "description": "Messing around with distance fields and creating a volumetric effect.",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "distancefield",
     "volume"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGRn",
       "filepath": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3Wl",
       "filepath": "https://soundcloud.com/user3303533/mass-effect-3-earth",
       "type": "musicstream",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         32\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 35.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Hash(in vec2 p)\n{\n    return -1.0 + 2.0 * fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n    return -1.0 + 2.0 * vec2(fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453), fract(sin(dot(p, vec2(37.271, 377.632))) * 43758.5453));\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\n//////////////////////////////////////////////////////\n// 3D noise and Voronio from https://www.shadertoy.com/view/4sfGzS and https://www.shadertoy.com/view/ldl3W8\nfloat Noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv+.5) / 256.).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nvec3 Voronoi(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j)\n    {\n        for(int i = -1; i <= 1; ++i)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = Hash2D(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\n//////////////////////////////////////////////////////\n// smin from https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat smin(in float a, in float b, in float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat LengthN(in vec3 v, in float n)\n{\n    float inverseN = 1.0 / n; \n    v = abs(v);\n    return pow(pow(v.x, n) + pow(v.y, n) + pow(v.z, n), inverseN);\n}\n\nfloat LengthN(in vec2 v, in float n)\n{\n    float inverseN = 1.0 / n; \n    v = abs(v);\n    return pow(pow(v.x, n) + pow(v.y, n), inverseN);\n}\n    \n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(in vec3 p, in vec3 boxSize)\n{\n  vec3 d = abs(p) - boxSize;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec3 cylinderDimensions)\n{\n  return length(p.xz - cylinderDimensions.xy) - cylinderDimensions.z;\n}\n\nfloat sdSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdPipe(in vec3 p, in vec3 cylinderPosition, in vec2 cylinderDimensions)\n{\n    vec2 d = abs(vec2(length(p.yz + cylinderPosition.yz), p.x + cylinderPosition.x)) - cylinderDimensions;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdVerticalPipe(in vec3 p, in vec3 cylinderPosition, in vec2 cylinderDimensions)\n{\n    vec2 d = abs(vec2(length(p.xz + cylinderPosition.xz), p.y + cylinderPosition.y)) - cylinderDimensions;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xy + torusPosition.xy) - torusDimensions.x, p.z + torusPosition.z);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdTorus82(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(LengthN(p.xy + torusPosition.xy, 2.0) - torusDimensions.x, p.z + torusPosition.z);\n    return LengthN(q, 8.0) - torusDimensions.y;\n}\n\nfloat sdTorus42(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(LengthN(p.xy + torusPosition.xy, 2.0) - torusDimensions.x, p.z + torusPosition.z);\n    return LengthN(q, 4.0) - torusDimensions.y;\n}\n\nfloat Capsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nconst vec3 gMassRelayPosition = vec3(1.0, 3.0, 0.0);\n\nIntersectionData CheckMassRelay(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 1.0);\n    \n    float intersectionT = sdTorus(p, gMassRelayPosition, vec2(4.5, 0.85));\n    intersectionData.mT = intersectionT;\n\n    // Back\n    intersectionT = sdBox(p - vec3(7.5, 0.0, 0.0) + gMassRelayPosition, vec3(2.0, 1.8, 0.65));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 3.5);\n  \n    // rear modifications\n    intersectionT = sdBox(p - vec3(10.0, -0.5, 0.0) + gMassRelayPosition, vec3(1.0, 0.5, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    intersectionT = sdBox(p - vec3(10.0, 1.05, 0.0) + gMassRelayPosition, vec3(1.85, 0.25, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    \n    // top beam\n    intersectionT = sdPipe(p, vec3(11.0, -1.5, 0.0) + gMassRelayPosition, vec2(0.8, 7.0));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);    \n    intersectionT = sdPipe(p, vec3(8.0, -1.8, 0.0) + gMassRelayPosition, vec2(0.8, 3.5));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);    \n    \n    // bottom beam\n    intersectionT = sdPipe(p, vec3(11.0, 1.5, 0.0) + gMassRelayPosition, vec2(0.8, 7.0));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);\n        \n    // center hole\n    intersectionT = sdBox(p - vec3(-12.0, 0.0, 0.0) + gMassRelayPosition, vec3(10.0, 1.0, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n       \n    // rail modifications\n    intersectionT = sdBox(p - vec3(-18.0, -2.25, 0.0) + gMassRelayPosition, vec3(1.0, 1.0, 1.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    intersectionT = sdBox(p - vec3(-18.0, 2.25, 0.0) + gMassRelayPosition, vec3(1.0, 1.0, 1.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    \n    return intersectionData;\n}\n\nIntersectionData CheckMassRelayRing(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 2.0);\n    \n    // Ring 1\n    mat3 rotationMatrix0 = Create3x3RotationMatrix(vec3(0.0, 1.0, 0.0), PI * 0.60 * iTime);\n    vec3 q0 = rotationMatrix0 * (p + gMassRelayPosition);\n    float intersectionT = sdTorus42(q0, vec3(0.0), vec2(3.0, 0.2));\n    intersectionData.mT = intersectionT;\n    \n    mat3 rotationMatrix1 = Create3x3RotationMatrix(vec3(0.0, 1.0, 0.0), PI * 0.60 * iTime);\n    mat3 rotationMatrix2 = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), PI * 0.80 * iTime);\n    vec3 q = rotationMatrix2 * (rotationMatrix1 * (p + gMassRelayPosition));\n    intersectionT = sdTorus42(q, vec3(0.0), vec2(2.5, 0.15));\n    intersectionData.mT = min(intersectionData.mT, intersectionT);\n    \n    return intersectionData;\n}\n\nIntersectionData CheckAntennas(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 3.0);\n    \n    // Left Attennas\n    float intersectionT = sdPipe(p, vec3(11.0, -2.4, -0.35) + gMassRelayPosition, vec2(0.07, 2.5));\n    intersectionData.mT = intersectionT;  \n    intersectionT = sdVerticalPipe(p, vec3(1.4, -6.8, 0.0) + gMassRelayPosition, vec2(0.2, 3.1));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n    intersectionT = sdVerticalPipe(p, vec3(1.9, -6.8, 0.0) + gMassRelayPosition, vec2(0.08, 3.6));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(0.9, -6.8, 0.0) + gMassRelayPosition, vec2(0.1, 3.1));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1); \n    intersectionT = sdVerticalPipe(p, vec3(0.6, -6.8, 0.0) + gMassRelayPosition, vec2(0.08, 1.4));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n    \n    // Right Attennas\n    intersectionT = sdVerticalPipe(p, vec3(-1.6, -6.5, 0.0) + gMassRelayPosition, vec2(0.08, 1.4));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1); \n    intersectionT = sdVerticalPipe(p, vec3(-1.6, -5.8, 0.0) + gMassRelayPosition, vec2(0.16, 0.7));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(-2.2, -6.4, 0.0) + gMassRelayPosition, vec2(0.08, 1.5));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(-2.2, -5.6, 0.0) + gMassRelayPosition, vec2(0.16, 0.85));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n\n    return intersectionData;\n}\n\nIntersectionData CheckBolt(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 4.0);\n      \n    const int NUMBER_OF_BENDS = 5;\n    vec2 maxBoltYValues = vec2(-1.25, 1.25); \n    float maxBoltYRange = abs(maxBoltYValues.x - maxBoltYValues.y); \n    float yIncr = maxBoltYRange / float(NUMBER_OF_BENDS);\n    \n    vec3 q = p + gMassRelayPosition;\n    int index = int(clamp((((q.y - maxBoltYValues.x) / maxBoltYRange) * float(NUMBER_OF_BENDS)), 0.0, float(NUMBER_OF_BENDS)));\n\n    float boltArea = mod(iTime, 15.0);\n    if(boltArea < 13.0)\n    {\n        vec2 currentBoltYValues = vec2((maxBoltYValues.x + float(index) * yIncr), (maxBoltYValues.x + float(index + 1) * yIncr));\n\n        vec3 randomOffsetHigh = (texture(iChannel0, vec2(floor(mod(iTime, 25.0) * 10.0) / 25.0, float(index) / float(NUMBER_OF_BENDS)), -100.0).xyz * 2.0 - 1.0) * vec3(0.25, 0.0, 0.25);\n        if(index >= (NUMBER_OF_BENDS - 1))\n        \trandomOffsetHigh = vec3(0.0);\n      \n        vec3 randomOffsetLow = (texture(iChannel0, vec2(floor(mod(iTime, 25.0) * 10.0) / 25.0, max(0.0, float(index - 1)) / float(NUMBER_OF_BENDS)), -100.0).xyz * 2.0 - 1.0) * vec3(0.25, 0.0, 0.25);\n\n        intersectionData.mT = Capsule(q, vec3(-4.0 - boltArea, currentBoltYValues.x, 0.0) + randomOffsetLow,\n                                      vec3(-4.0 - boltArea, currentBoltYValues.y, 0.0) + randomOffsetHigh, 0.05);\n    }\n    return intersectionData;\n}\n\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData massRelayIntersection = CheckMassRelay(p);\n    IntersectionData antennasIntersection = CheckAntennas(p);    \n    IntersectionData intersectionData = GetClosestIntersection(massRelayIntersection, antennasIntersection);   \n    \n    IntersectionData ringIntersectionData = CheckMassRelayRing(p);\n    intersectionData = GetClosestIntersection(intersectionData, ringIntersectionData); \n    \n    IntersectionData boltIntersectionData = CheckBolt(p);\n    intersectionData = GetClosestIntersection(intersectionData, boltIntersectionData);\n    \n    return intersectionData;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }\n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\nvoid RaySphereIntersectionTest(in vec3 rayPosition, in vec3 rayDirection, in vec3 spherePosition, in float sphereRadius,\n                               out vec3 intersectionNear, out vec3 intersectionFar)\n{   \n    float sRadiusSquared = sphereRadius * sphereRadius;\n    vec3 eDistance = rayPosition - spherePosition;\n    \n    float b = dot(eDistance, rayDirection);\n    float c = dot(eDistance, eDistance) - sRadiusSquared;\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        float t0 = max(-b - sqrt(discriminant), 0.0); // clamp t0 to zero incase it started inside the sphere\n        float t1 = max(-b + sqrt(discriminant), 0.0); // clamp t1 to zero incase it started inside the sphere\n           \n        if(discriminant >= EPSILON)\n        {\n            intersectionNear = rayPosition + rayDirection * t0;\n            intersectionFar = rayPosition + rayDirection * t1;\n       }      \n    }\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nfloat GGXDistribution(in float NdotH, in float m)\n{\n    // Divide by PI is applied later\n    float m2 = m * m;\n    float f = ( NdotH * m2 - NdotH ) * NdotH + 1.0;\n    return m2 / (f * f);\n}\n\nfloat CookTorranceGeometricAttenuation(in float NdotH, in float NdotL, in float VdotH, in float NdotV)\n{\n    return (min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)));\n}\n\nfloat GGXSmithCorrelated(in float NdotL, in float NdotV, in float alphaG)\n{\n    float alphaG2 = alphaG * alphaG;\n    float Lambda_GGXV = NdotL * sqrt((- NdotV * alphaG2 + NdotV) * NdotV + alphaG2);\n    float Lambda_GGXL = NdotV * sqrt((- NdotL * alphaG2 + NdotL) * NdotL + alphaG2);\n    return 0.5 / ( Lambda_GGXV + Lambda_GGXL );\n}\n\nfloat ComputeSchlickFresnel(in float NdotV, in float fresnelReflectionIndex)\n{\n    return fresnelReflectionIndex + (1.0 - fresnelReflectionIndex) * pow((1.0 - NdotV), 5.0);\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 ApplyPointLight(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, \n                       in float roughness, in float metallic, in float reflectance, in float ambient,\n                       in vec3 lightPosition, in float lightRadius, in vec3 lightColor)\n{       \n    vec3 lightDirection = -(lightPosition - point);\n\n    // Apply lighting\n    float lightDistance = length(lightDirection);\n    lightDirection = normalize(lightDirection);\n    float attenutation = Saturate(1.0 - lightDistance / lightRadius); \n    attenutation *= attenutation;\n    \n    // Determine some values\n    vec3 viewVector = normalize(eye - point);\n    vec3 halfVector = normalize(lightDirection + viewVector);\n\n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = Saturate(dot(normal, viewVector));\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float HdotL = Saturate(dot(halfVector, lightDirection));\n\n    vec3 diffuse = (1.0 - metallic) * albedo;\n\n    // Cook Torence\n    float f0 = 0.16 * (reflectance * reflectance);\n    float fresnel = ComputeSchlickFresnel(NdotV, f0);    \n\n    float Vis = GGXSmithCorrelated(NdotV, NdotL, roughness);\n    float geometricAttenuation = CookTorranceGeometricAttenuation(NdotH, NdotL, VdotH, NdotV);\n    float microfacets = GGXDistribution(NdotH, roughness);\n\n    float specular = (fresnel * microfacets * Vis) / PI;\n\n    return ((NdotL * Saturate(1.5 * ((0.7 * NdotL * diffuse + specular))))) * lightColor * attenutation;         \n}\n\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, \n                       in float roughness, in float metallic, in float reflectance, in float ambient)\n{       \n    vec3 lighting = ApplyPointLight(point, normal, eye, albedo, roughness, metallic, reflectance,\n                               0.5, -gMassRelayPosition, 60.0, vec3(0.5, 0.5, 1.0));\n    \n    // Apply lighting from moving bolt\n    float boltArea = mod(iTime, 15.0);\n    if(boltArea < 13.0)\n    {\n        lighting += ApplyPointLight(point, normal, eye, albedo, roughness, metallic, reflectance,\n                               0.5, -gMassRelayPosition + vec3(-4.0 - boltArea, 0.0, 0.0), 8.0, vec3(0.5, 0.5, 1.0));\n    }\n    return lighting + (albedo * ambient);\n}\n\n//////////////////////////////////////////////////////\n// Background\nvec3 ApplyFog(in vec3 texCoord)\n{\n    vec3 samplePosition = 8.0 * texCoord.xyz;\n    \n    float fogAmount = Noise(samplePosition);\n    fogAmount += Noise(samplePosition * 3.01) * 0.5;\n    fogAmount += Noise(samplePosition * 3.02) * 0.25;\n    fogAmount += Noise(samplePosition * 3.03) * 0.125;\n    fogAmount += Noise(samplePosition * 3.01) * 0.0625;\n    \n    vec3 fogColor = vec3(texCoord.xyz + vec3(0.5, 0.0, 0.5))  * 0.1;\n    return (fogColor * fogAmount * vec3(0.75));  \n}\n\nvec3 AddStarField(in vec2 p, in float threshold)\n{\n    vec3 starValue = Voronoi(p);\n    if(starValue.x < threshold)\n    {\n        float power = 1.0 - (starValue.x / threshold);\n        return vec3(power * power * 0.5);\n    }\n    return vec3(0.0);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    // Gets the intersection point from the camera ray to camera facing plane that the core is on\n    vec3 directionToCore = -normalize(gMassRelayPosition - cameraPosition);\n    vec3 coreIntersectionNear = vec3(MAX_DISTANCE);\n    vec3 coreIntersectionFar = vec3(MAX_DISTANCE);\n    \n    const float coreVolumeRadius = 8.0;\n    const float solidCoreRadius = 1.25;\n    RaySphereIntersectionTest(cameraPosition, cameraDirection, -gMassRelayPosition, coreVolumeRadius, coreIntersectionNear, coreIntersectionFar);\n      \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        float roughness = 0.9;\n        float metallic = 1.0;\n        float reflectance = 0.2;\n        float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == 1.0)\n        {\n            // I'm sure theres a better way to do this\n            vec2 texCoords = intersectionPoint.xy;\n            if(abs(dot(normal, vec3(1.0, 0.0, 0.0))) > 0.8)\n                texCoords =  intersectionPoint.zy;  \n            else if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) > 0.8)\n                texCoords =  intersectionPoint.xz;\n\n            vec3 textureColor = texture(iChannel1, texCoords * 0.125).rgb;\n            diffuse = vec3(0.3, 0.3, 0.4);  \n            \n            if(textureColor.r < glowThreshold)\n            {\n                ambient = 1.0;\n                diffuse = vec3(1.0);\n            }  \n        }\n        else if(intersection.mMaterialIndex == 2.0 || intersection.mMaterialIndex == 3.0)  \n            diffuse = vec3(0.5);               \n        else if(intersection.mMaterialIndex == 4.0)\n        {\n            ambient = 10.0;  \n            diffuse = vec3(1.0);\n        }\n\n        finalColor += CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, roughness, metallic, reflectance, ambient);         \n    }\n    else\n    {   \n        // calculate the uv coords for the skybox\n        vec2 starFieldCoord = vec2(atan(cameraDirection.x, cameraDirection.z) / (2.0 * PI), asin(cameraDirection.y) / PI);       \n        finalColor += AddStarField(starFieldCoord * 80.0, 0.0025);\n        finalColor += AddStarField(starFieldCoord * 65.0, 0.0025);\n        finalColor += AddStarField(starFieldCoord * 50.0, 0.001);       \n        finalColor += ApplyFog(cameraDirection);\n    }\n\n    float lengthToNearVol = min(length(cameraPosition - coreIntersectionNear), intersection.mT);\n    float lengthToFarVol = min(length(cameraPosition - coreIntersectionFar), intersection.mT);\n    float volumeTravelDistance = abs(lengthToNearVol - lengthToFarVol);\n    \n    if(volumeTravelDistance < coreVolumeRadius * 2.0)\n    {\n        vec3 volStartPoint = (cameraRay.mPosition + cameraRay.mDirection * lengthToNearVol);\n        float volumeAmount = 0.0;\n        \n        const int numberOfSteps = 20;\n        float stepSize = max(volumeTravelDistance / float(numberOfSteps), EPSILON);\n\n        for(int i = 0; i < numberOfSteps; ++i)\n        {\n            vec3 currentPoint = volStartPoint + (float(i) * stepSize * cameraDirection);\t   \n            float distanceFromCenterCore = length(currentPoint + gMassRelayPosition);\n\n            float blueTint = Saturate((coreVolumeRadius - distanceFromCenterCore) / coreVolumeRadius) * 2.0;\n            float whiteTint = Saturate((solidCoreRadius - distanceFromCenterCore) / solidCoreRadius) * 200.0;\n\n            if(length(currentPoint) > MAX_DISTANCE)\n            {\n                break;\n            }\n            volumeAmount += blueTint + whiteTint;        \n        }\n        volumeAmount /= float(numberOfSteps);\n        vec3 volumeColor = mix(vec3(0.1, 0.1, 1.0), vec3(1.0), vec3(volumeAmount * 0.5));\n        finalColor = mix(finalColor, volumeColor, vec3(Saturate(volumeAmount)));\n    } \n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 13.0;\n    vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n    vec4 finalColor = DisplayScene(cameraPosition, cameraDirection, 0.4);\n    finalColor *= pow(16.0 * screenCoord.x * screenCoord.y * (1.0 - screenCoord.x) * (1.0 - screenCoord.y), 0.1); // Vigneting\n\n\tfragColor = finalColor;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lst3W2",
    "date": "1452574056",
    "viewed": 1415,
    "name": "Shadertris",
    "description": "A proof of concept. Still needs some work (pretty rough visually, no score, additional code clean up).\n\nControls\narrow keys: move\nrotate: a/d/space/up",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "game",
     "interactive",
     "multipass"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Based on iq's brick game: https://www.shadertoy.com/view/MddGzf\n\n// Modified has unique colors per block and some 5-pieces\n#define MODIFIED 1\n#define CLASSIC 2\n#define MODE MODIFIED\n\n#if (MODE == MODIFIED)\nconst int CELLS_WIDE = 13;\nconst float NUM_BLOCK_TYPES = 8.0;\n#else\nconst int CELLS_WIDE = 10;\nconst float NUM_BLOCK_TYPES = 7.0;\n#endif\nconst int CELLS_TALL = 20; // hide the top four cells so we don't see shapes spawning\n\nconst float fCELLS_WIDE = float(CELLS_WIDE);\nconst float fCELLS_TALL = float(CELLS_TALL);\nconst int HALF_CELLS_WIDE = CELLS_WIDE / 2;\nconst int HALF_CELLS_TALL = CELLS_TALL / 2;\nconst float fHALF_CELLS_WIDE = float(HALF_CELLS_WIDE);\nconst float fHALF_CELLS_TALL = float(HALF_CELLS_TALL);\n\nconst float PI = 3.14159265359;\n\n// Block Types\nconst float I_BLOCK = 1.0;\nconst float J_BLOCK = 2.0;\nconst float L_BLOCK = 3.0;\nconst float O_BLOCK = 4.0;\nconst float S_BLOCK = 5.0;\nconst float T_BLOCK = 6.0;\nconst float Z_BLOCK = 7.0;\nconst float PLUS_BLOCK = 8.0;\nconst float MAX_BLOCK = 9.0;\n\n// storage register/texel addresses\nconst vec2 txGameInfo0      \t\t= vec2(0.0, 0.0); // x = game state, y = time in current state, z = time till next spin, time till next move\nconst vec2 txGameInfo1 \t    \t\t= vec2(1.0, 0.0); // x = score, y = total lines cleared, z = highScore, w = drop speed\nconst vec2 txGameInfo2 \t    \t\t= vec2(2.0, 0.0); // x = current test row, y = kill/copy row, z = next block type, w = current multipler\nconst vec2 txControlledBlockInfo0 \t= vec2(3.0, 0.0); // xy = position, z = rotation, w = block type\nconst vec2 txControlledBlockInfo1 \t= vec2(4.0, 0.0); // x = time till drop, y = next block type, z = space released\nconst vec4 txBlocks \t\t\t\t= vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));  // x = taken, y = color, z = destory, w = time till death\n\n// Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec3 GetColor(in float colorType, in vec2 textCoord)\n{\n    vec3 color = vec3(0.0);\n    \n    if(colorType == I_BLOCK)\n    \tcolor = vec3(0.5, 1.0, 1.0); // cyan\n    else if(colorType == J_BLOCK)    \n        color = vec3(0.0, 0.0, 1.0); // blue\n    else if(colorType == L_BLOCK)    \n        color = vec3(1.0, 0.5, 0.0); // orange\n    else if(colorType == O_BLOCK)    \n        color = vec3(1.0, 1.0, 0.0); // yellow\n    else if(colorType == S_BLOCK)    \n        color = vec3(0.0, 1.0, 0.5); // lime green\n    else if(colorType == T_BLOCK)    \n        color = vec3(0.5, 0.0, 1.0); // purple\n    else if(colorType == Z_BLOCK)    \n        color = vec3(1.0, 0.0, 0.0); // red\n    else if(colorType == PLUS_BLOCK)    \n        color = vec3(1.0, 0.7, 0.8); // pink\n\telse if(colorType == MAX_BLOCK)\n        color = vec3(1.0);\n\n    vec2 q = abs(textCoord);   \n    vec2 t = step(vec2(0.9), q);\n    return mix(color * 0.0, + color, vec3(1.0 - length(q * q)));\n}\n\nvec4 GetCollisionSetA(in float blockType)\n{\n    if(blockType == I_BLOCK)\n   \t\treturn vec4(0.0, 0.0, 0.0, 1.0);    \n    else if(blockType == J_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);     \n    else if(blockType == L_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(0.0, 0.0, 0.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);     \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);    \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0); \n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetB(in float blockType)\n{\n    if(blockType == I_BLOCK)\n    \treturn vec4(0.0, 2.0, 0.0, 3.0);     \n    else if(blockType == J_BLOCK)\n        return vec4(-1.0, 0.0, 1.0, 1.0);    \n    else if(blockType == L_BLOCK)\n        return vec4(-1.0, 0.0, -1.0, 1.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(1.0, 0.0, 1.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, -1.0, 1.0, -1.0);    \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);      \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, -1.0, -1.0, -1.0);\n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);\n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetC(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return vec4(0.0);\n    else if(blockType == J_BLOCK)\n        return vec4(0.0);\n    else if(blockType == L_BLOCK)\n         return vec4(0.0);\n    else if(blockType == O_BLOCK)\n        return vec4(0.0); \n    else if(blockType == S_BLOCK)\n\t\treturn vec4(0.0);\n    else if(blockType == T_BLOCK)\n        return vec4(-2.0, 0.0, 0.0, 0.0);\n    else if(blockType == Z_BLOCK)\n        vec4(0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);\n\treturn vec4(0.0);  \n}\n\nvec3 CheckForUserBlockColor(in vec4 controlledBlockInfo, in vec2 blockInfoCoords, in vec2 localBlockCoords, in float colorType)\n{\n    vec2 position = controlledBlockInfo.xy;\n    float rotation = controlledBlockInfo.z;\n    float blockType = controlledBlockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    \n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n    \n    vec2 c0 = floor(position + collisionSetA.xy);\n    vec2 c1 = floor(position + collisionSetA.zw);\n    vec2 c2 = floor(position + collisionSetB.xy);\n    vec2 c3 = floor(position + collisionSetB.zw);\n    vec2 c4 = floor(position + collisionSetC.xy);\n    vec2 c5 = floor(position + collisionSetC.zw);\n       \n    vec2 blockIndex = floor(vec2((blockInfoCoords.x * fCELLS_WIDE), (blockInfoCoords.y * fCELLS_TALL)));\n    \n#if (MODE == MODIFIED)\n    if((blockIndex == c0) || (blockIndex == c1) || (blockIndex == c2) || (blockIndex == c3) || (blockIndex == c4) || (blockIndex == c5))\n#else\n    if((blockIndex == c0) || (blockIndex == c1) || (blockIndex == c2) || (blockIndex == c3))   \n#endif\n    {\n        return GetColor(colorType, localBlockCoords);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float fieldAspectRatio = float(CELLS_WIDE) / float(CELLS_TALL);\n    const float inverseFieldAspectRatio = 1.0 / fieldAspectRatio;\n   \n    float aspectRatio = (iResolution.x / iResolution.y);\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 uv =  2.0 * screenCoord - 1.0; \n\n    // load game state\n    vec4 gameInfo0 = LoadValue(txGameInfo0);\n    vec4 gameInfo1 = LoadValue(txGameInfo1);\n    vec4 gameInfo2 = LoadValue(txGameInfo2);\n    vec4 controlledBlockInfo0 = LoadValue(txControlledBlockInfo0);\n    vec4 controlledBlockInfo1 = LoadValue(txControlledBlockInfo1);\n    \n    vec3 finalColor = vec3(0.0);\n    \n\t// Blocks\n    vec2 blockInfoCoords = vec2(uv.x * inverseFieldAspectRatio + 0.5, (1.0 - (screenCoord.y - 0.1979)));\n    vec2 localBlockCoords = vec2(blockInfoCoords.x * fCELLS_WIDE, blockInfoCoords.y * fCELLS_TALL);\n    localBlockCoords = (localBlockCoords - floor(localBlockCoords)) * 2.0 - 1.0;\n\n    if((blockInfoCoords.x > 0.0) && (blockInfoCoords.x < 1.0))\n    {   \n        vec2 blockIndex = floor(vec2((blockInfoCoords.x * fCELLS_WIDE), (blockInfoCoords.y * fCELLS_TALL)));\n        vec4 blockInfo = texture(iChannel0, (0.5 + txBlocks.xy + blockIndex) / iChannelResolution[0].xy, -100.0);\n        \n        if(blockInfo.x == 2.0) // hack for a clear block flash\n            finalColor.rgb = GetColor(MAX_BLOCK, localBlockCoords);\n        else if(blockInfo.x == 1.0)\n            finalColor.rgb = GetColor(blockInfo.y + ((blockInfo.x - 1.0) * MAX_BLOCK), localBlockCoords);\n        \n         if(controlledBlockInfo0.w != 0.0) // Player Block\n            finalColor.rgb += CheckForUserBlockColor(controlledBlockInfo0, blockInfoCoords, localBlockCoords, controlledBlockInfo1.w);\n    }\n    else if((blockInfoCoords.x > -0.1) && (blockInfoCoords.x < 1.1))\n    {\n        float gradient = (cos(abs(uv.x) * 110.0));\n        finalColor.rgb = vec3(gradient * gradient * 0.5 + 0.2);\n    }\n    else\n    {\n        finalColor = vec3(screenCoord, 0.5 + 0.5 * sin(iTime)) * 0.33334;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Based on iq's brick game: https://www.shadertoy.com/view/MddGzf\n\n// Modified has unique colors per block and some 5-pieces\n#define MODIFIED 1\n#define CLASSIC 2\n#define MODE MODIFIED\n\n#define RANDOM_COLOR_BLOCKS 1\n\n#if (MODE == MODIFIED)\nconst int CELLS_WIDE = 13;\nconst float NUM_BLOCK_TYPES = 8.0;\n#else\nconst int CELLS_WIDE = 10;\nconst float NUM_BLOCK_TYPES = 7.0;\n#endif\nconst int CELLS_TALL = 24;\n\nconst float fCELLS_WIDE = float(CELLS_WIDE);\nconst float fCELLS_TALL = float(CELLS_TALL);\nconst int HALF_CELLS_WIDE = CELLS_WIDE / 2;\nconst int HALF_CELLS_TALL = CELLS_TALL / 2;\nconst float fHALF_CELLS_WIDE = float(HALF_CELLS_WIDE);\nconst float fHALF_CELLS_TALL = float(HALF_CELLS_TALL);\n\nconst float PI = 3.14159265359;\n\n// Block Types (empty is 0.0)\nconst float I_BLOCK = 1.0;\nconst float J_BLOCK = 2.0;\nconst float L_BLOCK = 3.0;\nconst float O_BLOCK = 4.0;\nconst float S_BLOCK = 5.0;\nconst float T_BLOCK = 6.0;\nconst float Z_BLOCK = 7.0;\nconst float PLUS_BLOCK = 8.0;\n\n// storage register/texel addresses\nconst vec2 txGameInfo0      \t\t= vec2(0.0, 0.0); // x = game state, y = time in current state, z = time till next spin, time till next move\nconst vec2 txGameInfo1 \t    \t\t= vec2(1.0, 0.0); // x = score, y = lines cleared, z = highScore, w = drop speed\nconst vec2 txGameInfo2 \t    \t\t= vec2(2.0, 0.0); // x = current test row, y = destory/copy row, z = next block type, w = current multipler\nconst vec2 txControlledBlockInfo0 \t= vec2(3.0, 0.0); // xy = position, z = rotation, w = block type\nconst vec2 txControlledBlockInfo1 \t= vec2(4.0, 0.0); // x = time till drop, y = next block type, z = space released, w = block color\nconst vec4 txBlocks \t\t\t\t= vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));  // x = taken, y = color, z = destory, w = time till death\n\n// Keys\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_E     = 69.5/256.0;\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) { vec2 d = abs(p - 0.5 - c) - 0.5; return -max(d.x, d.y); }\nfloat IsInside(in vec2 p, in vec4 c) { vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; return -max(d.x, d.y); }\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nfloat GetRandomBlock(in float seed)\n{\n    vec3 value = texture(iChannel2, seed * iTime * vec2(12.9898, 78.233 + iTime)).rgb;\n    return floor(mod((value.x + value.y * 7.13 + value.z * 131.0), NUM_BLOCK_TYPES) + 1.0);\n}\n\nvec4 GetBlockInfo(in vec2 blockPosition)\n{  \n    return LoadValue(txBlocks.xy + blockPosition);\n}\n\nbool IsCellValid(in vec2 blockPosition)\n{\n\tbool blockOutOfBounds = (blockPosition.x < 0.0 || blockPosition.x >= (fCELLS_WIDE - 0.1) \n                            || blockPosition.y < 0.0 || blockPosition.y >= (fCELLS_TALL - 0.1)); \n                             \n    return blockOutOfBounds || (GetBlockInfo(blockPosition).x != 0.0) || (GetBlockInfo(blockPosition).y != 0.0);    \n}\n\nvec4 GetCollisionSetA(in float blockType)\n{\n    if(blockType == I_BLOCK)\n   \t\treturn vec4(0.0, 0.0, 0.0, 1.0);    \n    else if(blockType == J_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);     \n    else if(blockType == L_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(0.0, 0.0, 0.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);     \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);    \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0); \n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetB(in float blockType)\n{\n    if(blockType == I_BLOCK)\n    \treturn vec4(0.0, 2.0, 0.0, 3.0);     \n    else if(blockType == J_BLOCK)\n        return vec4(-1.0, 0.0, 1.0, 1.0);    \n    else if(blockType == L_BLOCK)\n        return vec4(-1.0, 0.0, -1.0, 1.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(1.0, 0.0, 1.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, -1.0, 1.0, -1.0);    \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);      \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, -1.0, -1.0, -1.0);\n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);\n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetC(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return vec4(0.0);\n    else if(blockType == J_BLOCK)\n        return vec4(0.0);\n    else if(blockType == L_BLOCK)\n         return vec4(0.0);\n    else if(blockType == O_BLOCK)\n        return vec4(0.0); \n    else if(blockType == S_BLOCK)\n\t\treturn vec4(0.0);\n    else if(blockType == T_BLOCK)\n        return vec4(-2.0, 0.0, 0.0, 0.0);\n    else if(blockType == Z_BLOCK)\n        vec4(0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);\n\treturn vec4(0.0);  \n}\n\nbool CheckForBlockCollisions(in vec4 blockInfo)\n{\n    // Get the collision offsets for whatever the blocktype is \n    bool hasCollided = false;\n    \n    vec2 position = blockInfo.xy;\n    float rotation = blockInfo.z;\n    float blockType = blockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    // O_BLOCK doesn't need to rotate\n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n    vec2 c0 = position + collisionSetA.xy;\n    vec2 c1 = position + collisionSetA.zw;\n    vec2 c2 = position + collisionSetB.xy;\n    vec2 c3 = position + collisionSetB.zw;\n    vec2 c4 = position + collisionSetC.xy;\n    vec2 c5 = position + collisionSetC.zw;\n    \n#if (MODE == MODIFIED)\n    hasCollided = IsCellValid(c0) || IsCellValid(c1) || IsCellValid(c2) || IsCellValid(c3) || IsCellValid(c4) || IsCellValid(c5);\n#else\n    hasCollided = IsCellValid(c0) || IsCellValid(c1) || IsCellValid(c2) || IsCellValid(c3);\n#endif\n    \n    return hasCollided;\n}\n\nvoid PlaceBlock(in vec4 playerBlockInfo, in vec2 targetCellIndex, inout vec4 targetCellInfo, in float colorType)\n{\n    // Very similar to the CheckForBlockCollisions function except we need to update some user data and update block info of the target cells\n    vec2 position = playerBlockInfo.xy;\n    float rotation = playerBlockInfo.z;\n    float blockType = playerBlockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    // O_BLOCK doesn't need to rotate\n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n     \n    vec2 c0 = position + collisionSetA.xy;\n    vec2 c1 = position + collisionSetA.zw;\n    vec2 c2 = position + collisionSetB.xy;\n    vec2 c3 = position + collisionSetB.zw;\n    vec2 c4 = position + collisionSetC.xy;\n    vec2 c5 = position + collisionSetC.zw;\n    \n#if (MODE == MODIFIED)\n    if((c0 == targetCellIndex) || (c1 == targetCellIndex) || (c2 == targetCellIndex) || (c3 == targetCellIndex) || (c4 == targetCellIndex) || (c5 == targetCellIndex))\n#else\n    if((c0 == targetCellIndex) || (c1 == targetCellIndex) || (c2 == targetCellIndex) || (c3 == targetCellIndex))   \n#endif\n    {\n        targetCellInfo = vec4(1.0, colorType, 0.0, 0.0);\n    }\n}\n\n// Each block type spawns at a different height, this is so it only takes a single drop update\n// for the block to appear in the playing field\nfloat GetStartingHeight(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return 0.0;\n    else if(blockType == J_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == L_BLOCK)\n    \treturn 2.0;\n    else if(blockType == O_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == S_BLOCK)\n    \treturn 3.0;\n    else if(blockType == T_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == Z_BLOCK)\n    \treturn 3.0;\n    else if(blockType == PLUS_BLOCK)\n    \treturn 2.0;\n    return 0.0;\n}\n\nfloat CalculateDropSpeed(in float linesCleared)\n{\n\treturn max(0.5 - min(floor((linesCleared) * 0.2) * 0.09, 1.9), 0.005);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute gameplay outside of the data area\n    if(fragCoord.x > fCELLS_WIDE || fragCoord.y > (1.0 + fCELLS_TALL)) discard;\n\n    // load game state\n    vec4 gameInfo0 = LoadValue(txGameInfo0);\n    vec4 gameInfo1 = LoadValue(txGameInfo1);\n    vec4 gameInfo2 = LoadValue(txGameInfo2);\n    vec4 controlledBlockInfo0 = LoadValue(txControlledBlockInfo0);\n    vec4 controlledBlockInfo1 = LoadValue(txControlledBlockInfo1);\n    vec4 blockInfo = LoadValue(fragCoord.xy - 0.5);\n    vec2 blockIndex = floor(vec2(fragCoord.x, fragCoord.y - 1.0));\n\n    // reset buffer A on frame 0\n\tif(iFrame == 0) gameInfo0 = vec4(-1.0, 0.0, 0.0, 0.0);\n    \n    if(gameInfo0.x == -1.0) // reset state\n    { \n        gameInfo0 = vec4(0.0, 0.0, 0.0, 0.0);\n        gameInfo1 = vec4(0.0, 0.0, 10000.0, CalculateDropSpeed(0.0));\n #if (MODE == MODIFIED)\n        gameInfo2 = vec4(0.0, 0.0, GetRandomBlock(1.0), 0.0);\n #else\n        gameInfo2 = vec4(0.0, 0.0, GetRandomBlock(1.0), 0.0);\n #endif\n        controlledBlockInfo0 = vec4(0.0);\n        controlledBlockInfo1 = vec4(0.0, 0.0, 0.0, gameInfo2.z);\n        blockInfo = vec4(0.0);\n    }\n    else if(gameInfo0.x == 0.0) // title state\n    {\n    \tgameInfo0 = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    else if(gameInfo0.x == 1.0) // normal gameplay state\n    {\n        if(controlledBlockInfo0.w == 0.0) // current block type is invalid so get a new block\n        {\n            controlledBlockInfo0 = vec4(fHALF_CELLS_WIDE, GetStartingHeight(gameInfo2.z), 0.0, gameInfo2.z);        \n            controlledBlockInfo1.x = gameInfo1.w;\n#if (MODE == MODIFIED) && RANDOM_COLOR_BLOCKS\n        \tcontrolledBlockInfo1.w = GetRandomBlock(2.0);\n#else \n            controlledBlockInfo1.w =  gameInfo2.z;\n#endif\n            gameInfo2.z = GetRandomBlock(1.0);\n        }\n        else\n        {\n            if(controlledBlockInfo1.x <= 0.0) // Drop block and check for collisions\n            {\n                vec4 futureControlledBlockInfo0 = controlledBlockInfo0;\n                futureControlledBlockInfo0.y += 1.0;\n\n                bool blockCollided = CheckForBlockCollisions(futureControlledBlockInfo0);\n                if(blockCollided)\n                {\n                    PlaceBlock(controlledBlockInfo0, blockIndex, blockInfo, controlledBlockInfo1.w);\n                    controlledBlockInfo0.w = 0.0; // set user control block type to invalid\n\n                    // Move to row completion check\n                    gameInfo0.x = 2.0;\n                    gameInfo2.xy = vec2(fCELLS_TALL, -1.0);\n                }\n                else\n                {\n                    controlledBlockInfo0.y += 1.0;\n                    controlledBlockInfo1.x = gameInfo1.w;\n                }\n            }\n            else\n            {\n                bool moveWasMade = false;\n                vec4 potentialMoveData = controlledBlockInfo0;\n\n                if(gameInfo0.z <= 0.0) // Rotation\n                {\n                    float rotateCW = texture(iChannel1, vec2(KEY_SPACE, 0.25)).x + texture(iChannel1, vec2(KEY_Q, 0.25)).x;\n                    if(rotateCW > 0.5)\n                    {\n                        potentialMoveData.z -= 1.0;\n                        if(potentialMoveData.z <= -1.0)\n                            potentialMoveData.z = 3.0;    \n                        moveWasMade = true;\n                    }\n                    float rotateCCW = texture(iChannel1, vec2(KEY_UP, 0.25)).x + texture(iChannel1, vec2(KEY_E, 0.25)).x;\n                    if(rotateCCW > 0.5)\n                    {\n                        potentialMoveData.z += 1.0;\n                        if(potentialMoveData.z >= 4.0)\n                            potentialMoveData.z = 0.0;    \n                        moveWasMade = true;\n                    }\n                    gameInfo0.z = 0.1;\n                }\n\n                if(gameInfo0.w <= 0.0) // Movement\n                {\n                    float pressLeft = texture(iChannel1, vec2(KEY_LEFT, 0.25)).x;\n                    float pressRight = texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x;\n                    float pressDown = texture(iChannel1, vec2(KEY_DOWN, 0.25)).x;\n                    \n                    if(pressLeft > 0.5)\n                    {\n                        potentialMoveData.x -= 1.0;\n                        moveWasMade = true;\n                    }\n                    if(pressRight > 0.5)\n                    {\n                        potentialMoveData.x += 1.0;\n                        moveWasMade = true;\n                    }\n                    \n                    if(pressDown > 0.5)\n                    {\n                        potentialMoveData.y += 1.0;\n                        moveWasMade = true;\n                    }\n                    gameInfo0.w = 0.05;\n                }\n                \n                if(CheckForBlockCollisions(potentialMoveData) == false) // Determine if the move was valid\n                {\n                    if(potentialMoveData.y > controlledBlockInfo0.y) // if it was a downwards move reset the drop timer\n                        controlledBlockInfo1.x = gameInfo1.w;\n                    controlledBlockInfo0 = potentialMoveData;             \n                }\n\n                controlledBlockInfo1.x -= iTimeDelta; // time till next drop\n                gameInfo0.z -= iTimeDelta; // time till next rotation available\n                gameInfo0.w -= iTimeDelta; // time till next movement available\n            }\n        }\n\t} \n    else if(gameInfo0.x == 2.0) // check for completed rows\n    {\n        bool completedRow = true;\n        \n        for(int i = 0; i < CELLS_WIDE; ++i)\n        {\n            vec2 testCoords = vec2(float(i), gameInfo2.x);\n            if(LoadValue(testCoords).x == 0.0)\n            {\n                completedRow = false;\n                break;\n            }\n        }\n        \n        if(completedRow)\n        {        \n           \tgameInfo2.w++; // increase multipler\n            gameInfo0.x = 3.0; // delete row phase\n            gameInfo2.y = gameInfo2.x; // set the delete row to the test row\n            \n            if(blockIndex.y == floor(gameInfo2.x - 1.0))\n                blockInfo.x = 2.0;\n        }\n        else\n        {  \n            // advance to next row\n            gameInfo2.x--;\n            if(gameInfo2.x < 1.0) // no rows completed\n            {\n                // calculate score\n                float stage = floor(gameInfo1.y * 0.2);\n                gameInfo1.x += min((gameInfo2.w * gameInfo2.w * 100.0) - 100.0, 100.0) * (stage);\n                gameInfo1.y += gameInfo2.w; // increase completed row count\n                \n                // Do a quick check for a game over state\n                bool isGameOver = false;\n                for(int i = 0; i < CELLS_WIDE; ++i)\n                {\n                    vec2 testCoords = vec2(float(i), 3.0);\n                    if(LoadValue(testCoords).x == 1.0)\n                    {\n                        isGameOver = true;\n                        break;\n                    }\n                }\n                \n                if(isGameOver)\n                {\n                    gameInfo0.x = 5.0;\t\n                }\n                else\n                {\n                    // reset back to normal gameplay\n                    gameInfo2.w = 0.0;\n                    gameInfo0.x = 1.0;\t\n                    gameInfo2.x = 0.0;\n                    gameInfo1.w = CalculateDropSpeed(gameInfo1.y);\n                    controlledBlockInfo1.x = gameInfo1.w;\n                }\n            }\n        }\n    }\n    else if(gameInfo0.x == 3.0) // delete rows\n    {\n\t\tif(blockIndex.y == (gameInfo2.x - 1.0))\n        {\n            blockInfo = vec4(0.0); // clear this block\n            gameInfo2.x = clamp(gameInfo2.x + 1.0, -1.0, fCELLS_TALL); // go back down a row      \n        }\n        gameInfo0.x = 4.0; // move down rows\n    }\n    else if(gameInfo0.x == 4.0) // move down rows\n    {\n        if(blockIndex.y < gameInfo2.x && blockIndex.y != 0.0)\n        {\n        \t// copy the value of the block above it\n            vec4 aboveBlockInfo = LoadValue(vec2(fragCoord.x - 0.5, fragCoord.y - 0.5 - 1.0));\n            blockInfo = aboveBlockInfo;          \n        }\n        gameInfo0.x = 2.0; // go back to checking rows\n    }\n    else if(gameInfo0.x == 5.0) // game over state\n    {\n    \t// Add a reset?\n       \tfloat anyKeyPressed = texture(iChannel1, vec2(KEY_SPACE, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_Q, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_UP, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_E, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_LEFT, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_DOWN, 0.25)).x;\n        \n       \tif(anyKeyPressed > 0.5)\n       \t{\n       \t\tgameInfo0 = vec4(-1.0, 0.0, 0.0, 0.0);\n       \t}    \n    }\n    gameInfo0.y += iTimeDelta;\n    \n\t// store game state\n    fragColor = vec4(0.0);\n \n    StoreValue(txGameInfo0, gameInfo0, fragColor, fragCoord);\n    StoreValue(txGameInfo1, gameInfo1, fragColor, fragCoord);\n    StoreValue(txGameInfo2, gameInfo2, fragColor, fragCoord); \n    StoreValue(txControlledBlockInfo0, controlledBlockInfo0, fragColor, fragCoord);\n    StoreValue(txControlledBlockInfo1, controlledBlockInfo1, fragColor, fragCoord);\n   \tStoreValue(txBlocks, blockInfo, fragColor, fragCoord);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4sKGDG",
    "date": "1475354369",
    "viewed": 772,
    "name": "PBR Editor",
    "description": "Hopefully I'm doing everything correctly, if not please correct/contact me :)\nControls: Mouse and A/D keys\n\nTODO:\n-fix reflections, proper glossy reflections, monte carlo bugs, crashes on some platforms, IBL, code cleanup, fix initial flash",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "editor",
     "pbr",
     "multipass"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Text Display\n\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\n// Materials\nstruct Material\n{\n    vec3    mBaseColor;\n    float \tmRoughness;\n    float \tmMetallic;\n    float   mReflectance;\n    float   mAmbient;\n    \n    int\t\tmDiffuseType;\n    int \tmMicrofacetDistributionType;\n    int\t\tmGeometricAttenuationType;\n    \n    int \tmIndex;\n};\n    \n// Diffuse Types\nconst int LAMBERT_DIFFUSE \t\t\t= 0;\nconst int DISNEY_DIFFUSE  \t\t\t= 1;\n    \n// Microfacet Distribution Types\nconst int GGX_MICROFACET \t \t\t= 0;    \nconst int BECKMAN_MICROFACET \t\t= 1;\n\n// Geometric Attenuation Types\nconst int VSMITH_GGX_GEOMETRIC \t\t= 0;\nconst int UE4_GEOMETRIC \t\t\t= 1;\nconst int COOK_TORRANCE_GEOMETRIC \t= 2;\n\nconst int NUMBER_OF_MATERIALS = 11;\nconst vec4 txMaterials = vec4(3.0, 0.0, 3.0 + float(NUMBER_OF_MATERIALS), 3.0);\n\n// Text\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n#define SPACE(position) position.x -= 8.0 \n#define DASH(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n#define COLON(position) BitCheck(0x63, 0x63, position); position.x -= 5.0 \n#define PERIOD(position) BitCheck(0x3, 0x3, position); position.x -= 4.0 \n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\n#define START_TEXT    textCursor.y=1.0-textCursor.y;float tS=scale;vec2 mFC=floor((uv.xy*iResolution.xy)/floor(tS));vec2 tP=floor(mFC.xy-(textCursor.xy*iResolution.xy/tS)+1.0);if(tP.y<0.0||tP.y>8.0){return 0.0;}if(fragCoord.x+(tS*2.0)<textCursor.x){return -1.0;}float bV=0.0;\n#define END_TEXT\t  return bV;\n\n////////////////////////////////////////////////////////\n// Strings\n#define EDIT_MODE_STRING bV+=LETTER_E(tP);bV+=LETTER_D(tP);bV+=LETTER_I(tP);bV+=LETTER_T(tP);SPACE(tP);bV+=LETTER_M(tP);bV+=LETTER_O(tP);bV+=LETTER_D(tP);bV+=LETTER_E(tP);\n#define ITERATION_STRING bV+=LETTER_I(tP);bV+=LETTER_T(tP);bV+=LETTER_E(tP);bV+=LETTER_R(tP);bV+=LETTER_A(tP);bV+=LETTER_T(tP);bV+=LETTER_I(tP);bV+=LETTER_O(tP);bV+=LETTER_N(tP);bV+=COLON(tP);SPACE(tP);\n\n#define MATERIAL_STRING bV+=LETTER_M(tP);bV+=LETTER_A(tP);bV+=LETTER_T(tP);bV+=LETTER_E(tP);bV+=LETTER_R(tP);bV+=LETTER_I(tP);bV+=LETTER_A(tP);bV+=LETTER_L(tP);bV+=COLON(tP);SPACE(tP);\n#define INVALID_STRING bV+=LETTER_I(tP);bV+=LETTER_N(tP);bV+=LETTER_V(tP);bV+=LETTER_A(tP);bV+=LETTER_L(tP);bV+=LETTER_I(tP);bV+=LETTER_D(tP);\n\n#define BASE_COLOR_STRING bV+=LETTER_B(tP);bV+=LETTER_A(tP);bV+=LETTER_S(tP);bV+=LETTER_E(tP);SPACE(tP);bV+=LETTER_C(tP);bV+=LETTER_O(tP);bV+=LETTER_L(tP);bV+=LETTER_O(tP);bV+=LETTER_R(tP);bV+=COLON(tP);SPACE(tP);\n#define ROUGHNESS_STRING bV+=LETTER_R(tP);bV+=LETTER_O(tP);bV+=LETTER_U(tP);bV+=LETTER_G(tP);bV+=LETTER_H(tP);bV+=LETTER_N(tP);bV+=LETTER_E(tP);bV+=LETTER_S(tP);bV+=LETTER_S(tP);bV+=COLON(tP);SPACE(tP);\n#define METALLIC_STRING bV+=LETTER_M(tP);bV+=LETTER_E(tP);bV+=LETTER_T(tP);bV+=LETTER_A(tP);bV+=LETTER_L(tP);bV+=LETTER_L(tP);bV+=LETTER_I(tP);bV+=LETTER_C(tP);bV+=COLON(tP);SPACE(tP);\n#define REFLECTANCE_STRING bV+=LETTER_R(tP);bV+=LETTER_E(tP);bV+=LETTER_F(tP);bV+=LETTER_L(tP);bV+=LETTER_E(tP);bV+=LETTER_C(tP);bV+=LETTER_T(tP);bV+=LETTER_A(tP);bV+=LETTER_N(tP);bV+=LETTER_C(tP);bV+=LETTER_E(tP);bV+=COLON(tP);SPACE(tP);\n#define AMBIENT_STRING bV+=LETTER_A(tP);bV+=LETTER_M(tP);bV+=LETTER_B(tP);bV+=LETTER_I(tP);bV+=LETTER_E(tP);bV+=LETTER_N(tP);bV+=LETTER_T(tP);bV+=COLON(tP);SPACE(tP);\n\n#define DIFFUSE_STRING bV+=LETTER_D(tP);bV+=LETTER_I(tP);bV+=LETTER_F(tP);bV+=LETTER_F(tP);bV+=LETTER_U(tP);bV+=LETTER_S(tP);bV+=LETTER_E(tP);bV+=COLON(tP);SPACE(tP);\n#define LAMBERT_STRING bV+=LETTER_L(tP);bV+=LETTER_A(tP);bV+=LETTER_M(tP);bV+=LETTER_B(tP);bV+=LETTER_E(tP);bV+=LETTER_R(tP);bV+=LETTER_T(tP);\n#define DISNEY_STRING bV+=LETTER_D(tP);bV+=LETTER_I(tP);bV+=LETTER_S(tP);bV+=LETTER_N(tP);bV+=LETTER_E(tP);bV+=LETTER_Y(tP);\n\n#define MICROFACET_DISTRIBUTION_STRING bV+=LETTER_M(tP);bV+=LETTER_I(tP);bV+=LETTER_C(tP);bV+=LETTER_R(tP);bV+=LETTER_O(tP);bV+=LETTER_F(tP);bV+=LETTER_A(tP);bV+=LETTER_C(tP);bV+=LETTER_E(tP);bV+=LETTER_T(tP);bV+=COLON(tP);SPACE(tP);\n#define GGX_STRING bV+=LETTER_G(tP);bV+=LETTER_G(tP);bV+=LETTER_X(tP);\n#define BECKMAN_STRING bV+=LETTER_B(tP);bV+=LETTER_E(tP);bV+=LETTER_C(tP);bV+=LETTER_K(tP);bV+=LETTER_M(tP);bV+=LETTER_A(tP);bV+=LETTER_N(tP);\n\n#define GEOMETRIC_ATTENUTATION_STRING bV+=LETTER_G(tP);bV+=LETTER_E(tP);bV+=LETTER_O(tP);bV+=LETTER_M(tP);bV+=LETTER_E(tP);bV+=LETTER_T(tP);bV+=LETTER_R(tP);bV+=LETTER_I(tP);bV+=LETTER_C(tP);bV+=COLON(tP);SPACE(tP);\n#define VSMITH_GGX_STRING bV+=LETTER_V(tP);bV+=LETTER_S(tP);bV+=LETTER_M(tP);bV+=LETTER_I(tP);bV+=LETTER_T(tP);bV+=LETTER_H(tP);SPACE(tP);bV+=LETTER_G(tP);bV+=LETTER_G(tP);bV+=LETTER_X(tP);\n#define UE4_STRING bV+=LETTER_U(tP);bV+=LETTER_E(tP);bV+=NUMBER_4(tP);\n#define COOK_TORRANCE_STRING bV+=LETTER_C(tP);bV+=LETTER_O(tP);bV+=LETTER_O(tP);bV+=LETTER_K(tP);SPACE(tP);bV+=LETTER_T(tP);bV+=LETTER_O(tP);bV+=LETTER_R(tP);bV+=LETTER_R(tP);bV+=LETTER_A(tP);bV+=LETTER_N(tP);bV+=LETTER_C(tP);bV+=LETTER_E(tP);\n\n////////////////////////////////////////////////////////\n// Bit Checks for text\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in vec2 textPos) \n{\n    return BitCheck(c1, c2, 0, textPos);\n}\n\nfloat DisplayDigit(in int digit, out vec2 textPos)\n{\n    float bitVal = 0.0;\n    \n    if(digit == 0)      { bitVal += NUMBER_0(textPos); }\n    else if(digit == 1) { bitVal += NUMBER_1(textPos); }\n    else if(digit == 2) { bitVal += NUMBER_2(textPos); }\n    else if(digit == 3) { bitVal += NUMBER_3(textPos); }\n    else if(digit == 4) { bitVal += NUMBER_4(textPos); }\n    else if(digit == 5) { bitVal += NUMBER_5(textPos); }\n    else if(digit == 6) { bitVal += NUMBER_6(textPos); }\n    else if(digit == 7) { bitVal += NUMBER_7(textPos); }\n    else if(digit == 8) { bitVal += NUMBER_8(textPos); }\n    else if(digit == 9) { bitVal += NUMBER_9(textPos); }\n    \n    return bitVal;\n}\n\nfloat WriteFloat(inout vec2 textPos, in vec2 uv, in float scale, in float number, in bool displayMultipleZeroes)\n{\n    const int MAX_NUMBER_OF_DIGITS = 4;\n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n      \n    float bitVal = 0.0;   \n    if(number < 0.0)\n    {\n     \tnumber = -number;\n        bitVal += DASH(textPos);\n    }\n        \n    bitVal += DisplayDigit(int(number), textPos);\n    number *= 10000.0;\n    bitVal += PERIOD(textPos);\n   \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0)); \n        foundNonZero = (digit != 0 || displayMultipleZeroes) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero || (number == 0.0 && i == 1))\n                bitVal += DisplayDigit(digit, textPos);\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal; \n}\n\nfloat WriteInterger(inout vec2 textPos, in vec2 uv, in float scale, in int number)\n{\n    const int MAX_NUMBER_OF_DIGITS = 2;\n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n      \n    float bitVal = 0.0;   \n    if(number < 0)\n    {\n     \tnumber = -number;\n        bitVal += DASH(textPos);\n    }\n   \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0)); \n        foundNonZero = (digit != 0) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero || (number == 0 && i == 1))\n                bitVal += DisplayDigit(digit, textPos);\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal; \n}\n\nfloat WriteInterger8(inout vec2 textPos, in vec2 uv, in float scale, in int number)\n{\n    const int MAX_NUMBER_OF_DIGITS = 8;\n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n      \n    float bitVal = 0.0;   \n    if(number < 0)\n    {\n     \tnumber = -number;\n        bitVal += DASH(textPos);\n    }\n   \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0)); \n        foundNonZero = (digit != 0) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero || (number == 0 && i == 1))\n                bitVal += DisplayDigit(digit, textPos);\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal; \n}\n////////////////////////////////////////////////////////\n// Formatted Strings\nfloat WriteEditString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale){START_TEXT EDIT_MODE_STRING END_TEXT}\n\nfloat WriteBaseColorString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in vec3 baseColor)\n{START_TEXT BASE_COLOR_STRING END_TEXT}\n\nfloat WriteRoughnessString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float roughness)\n{START_TEXT ROUGHNESS_STRING bV+=WriteFloat(tP, uv, 1.1, roughness, true); END_TEXT}\n\nfloat WriteMetallicString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float metallic)\n{START_TEXT METALLIC_STRING bV+=WriteFloat(tP, uv, 1.1, metallic, true); END_TEXT}\n\nfloat WriteReflectanceString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float reflectance)\n{START_TEXT REFLECTANCE_STRING bV+=WriteFloat(tP, uv, 1.1, reflectance, true); END_TEXT}\n\nfloat WriteAmbientString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float ambient)\n{START_TEXT AMBIENT_STRING bV+=WriteFloat(tP, uv, 1.1, ambient, true); END_TEXT}\n\nfloat WriteDiffuseString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int diffuseType)\n{\n    START_TEXT  \n    DIFFUSE_STRING       \n    if(diffuseType == LAMBERT_DIFFUSE){LAMBERT_STRING}\n    else if(diffuseType == DISNEY_DIFFUSE){DISNEY_STRING}   \n    END_TEXT\n}\n\nfloat WriteMicrofacetString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int microfacetType)\n{\n    START_TEXT  \n    MICROFACET_DISTRIBUTION_STRING       \n    if(microfacetType == GGX_MICROFACET){GGX_STRING}\n    else if(microfacetType == BECKMAN_MICROFACET){BECKMAN_STRING}   \n    END_TEXT\n}\n\nfloat WriteGeometricAttenuationString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int geometricAttenuationType)\n{\n    START_TEXT  \n    GEOMETRIC_ATTENUTATION_STRING       \n    if(geometricAttenuationType == VSMITH_GGX_GEOMETRIC){VSMITH_GGX_STRING}\n    else if(geometricAttenuationType == UE4_GEOMETRIC){UE4_STRING} \n    else if(geometricAttenuationType == COOK_TORRANCE_GEOMETRIC){COOK_TORRANCE_STRING} \n    END_TEXT\n}\n\nfloat WriteMaterialIndexString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int materialIndex)\n{\n    const int NUMBER_OF_MATERIALS = 11; \n    START_TEXT     \n    MATERIAL_STRING\n    if((materialIndex >= 0) && (materialIndex < NUMBER_OF_MATERIALS))\n    {\n         bV += WriteInterger(tP, uv, tS, materialIndex);\n    }\n    else\n    {\n        INVALID_STRING\n    }\n    END_TEXT\n}\n\nfloat WriteIterationString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int iteration)\n{\n    START_TEXT \n    ITERATION_STRING \n    bV += WriteInterger8(tP, uv, tS, iteration); \n    END_TEXT\n}\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\nMaterial LoadMaterial(in int materialIndex)\n{\n    vec4 materialInfo0 = LoadValueBufferA(txMaterials.xy + vec2(float(materialIndex), 0.0));\n    vec4 materialInfo1 = LoadValueBufferA(txMaterials.xy + vec2(float(materialIndex), 1.0));\n    vec4 materialInfo2 = LoadValueBufferA(txMaterials.xy + vec2(float(materialIndex), 2.0));\n\n    return Material(materialInfo0.xyz, materialInfo0.w, materialInfo1.x, materialInfo1.y, \n                    materialInfo1.z, int(materialInfo2.x), int(materialInfo2.y), int(materialInfo2.z), materialIndex);\n}\n\n////////////////////////////////////////////////////////\n// Editor\nvec4 DisplaySlider(in vec2 uv, in float height, in float value, in vec3 color)\n{\n    float inSliderBounds = step(0.015, uv.x)*step(uv.x, 0.29)*step(uv.y, 1.0-(height+0.01))*step(1.0-(height+0.04), uv.y);\n    float barU = (value * 0.275 + 0.015);\n    \n    float inBarBounds = step(barU - 0.005, uv.x)*step(uv.x, barU + 0.005)*step(uv.y, 1.0-(height+0.005))*step(1.0-(height+0.045), uv.y);\n    float gradientAmount = inSliderBounds * Saturate(uv.x / 0.259); \n    return vec4((gradientAmount * color) * (1.0 - inBarBounds) + vec3(0.0) * inBarBounds, inSliderBounds + inBarBounds);\n}\n\nvec4 DisplayClickBox(in vec2 uv, in float height, in vec3 color)\n{\n    float inBounds = step(0.01, uv.x)*step(uv.x, 0.29) *step(uv.y, 1.0-(height))*step(1.0-(height+0.035), uv.y);\n\treturn vec4(color * inBounds, inBounds);\n}    \n    \nvec4 DisplayMaterial(in vec2 fragCoord, in vec2 uv, in Material selectedMaterial)\n{\n    const float xSpacing = 0.015;\n    \n    vec4 finalColor = vec4(0.0);\n    \n    float text = WriteBaseColorString(vec2(xSpacing, 0.075), uv, fragCoord, 1.1, selectedMaterial.mBaseColor); \n    vec4 sliderColor = DisplaySlider(uv, 0.18, selectedMaterial.mBaseColor.r, vec3(1, 0, 0));\n    sliderColor += DisplaySlider(uv, 0.225, selectedMaterial.mBaseColor.g, vec3(0, 0, 1));\n    sliderColor += DisplaySlider(uv, 0.27, selectedMaterial.mBaseColor.b, vec3(0, 1, 0));\n    \n    text += WriteRoughnessString(vec2(xSpacing, 0.3), uv, fragCoord, 1.1, selectedMaterial.mRoughness); \n    sliderColor += DisplaySlider(uv, 0.365, selectedMaterial.mRoughness, vec3(1.0));\n\n    text += WriteMetallicString(vec2(xSpacing, 0.4), uv, fragCoord, 1.1, selectedMaterial.mMetallic);\n\tsliderColor += DisplaySlider(uv, 0.455, selectedMaterial.mMetallic, vec3(1.0));\n\n    text += WriteReflectanceString(vec2(xSpacing, 0.5), uv, fragCoord, 1.1, selectedMaterial.mReflectance);\n    sliderColor += DisplaySlider(uv, 0.55, selectedMaterial.mReflectance, vec3(1.0));  \n    \n    text += WriteAmbientString(vec2(xSpacing, 0.6), uv, fragCoord, 1.1, selectedMaterial.mAmbient);\n    sliderColor += DisplaySlider(uv, 0.65, selectedMaterial.mAmbient, vec3(1.0));\n\n    text += WriteDiffuseString(vec2(xSpacing, 0.75), uv, fragCoord, 1.1, selectedMaterial.mDiffuseType);\n \tvec4 buttonColor = DisplayClickBox(uv, 0.75, vec3(0.5)); \n    \n    text += WriteMicrofacetString(vec2(xSpacing, 0.805), uv, fragCoord, 1.1, selectedMaterial.mMicrofacetDistributionType);\n\tbuttonColor += DisplayClickBox(uv, 0.8, vec3(0.5)); \n    \n    text += WriteGeometricAttenuationString(vec2(xSpacing, 0.865), uv, fragCoord, 1.1, selectedMaterial.mGeometricAttenuationType);\n \tbuttonColor += DisplayClickBox(uv, 0.85, vec3(0.5)); \n    \n    finalColor = vec4(((1.0 - buttonColor.w) * finalColor.rgb) + vec3(buttonColor.w) * buttonColor.rgb, buttonColor.w);\n    finalColor = vec4(((1.0 - text) * finalColor.rgb) + vec3(text) * vec3(0.0), text);\n    finalColor = vec4(((1.0 - sliderColor.w) * finalColor.rgb) + (vec3(sliderColor.w) * sliderColor.rbg), text + sliderColor.w);\n    \n    return finalColor;\n}\n\n// Scene\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\n\n//////////////////////////////////////////////////\n// Modes\nconst float ATTRACT_MODE \t\t= 0.0;\nconst float EDIT_MODE \t\t\t= 1.0;\nconst float MONTE_CARLO_MODE \t= 2.0;\n\n//////////////////////////////////////////////////\n// Implementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 sceneInfo = LoadValueBufferA(txSceneModeInfo);\n    float sceneMode = sceneInfo.x;\n    \n    vec3 finalColor = texture(iChannel0, uv).rgb;\n    \n    if(sceneMode == EDIT_MODE)\n    {\n      \tint materialIndex = int(sceneInfo.y);\n        \n        // Menu\n        const float menuWidth = 0.3;\n        float edge = step(menuWidth, uv.x);\n    \tfinalColor = (1.0 - edge) * (finalColor * 0.5 + vec3(0.5)) + edge * finalColor;    \n        \n        float text = WriteEditString(vec2(0.015, 0.005), uv, fragCoord, 2.1); \n        text += WriteMaterialIndexString(vec2(0.015, 0.1), uv, fragCoord, 1.0, materialIndex); \n        finalColor.rgb = ((1.0 - text) * finalColor.rgb) + vec3(text) * vec3(0.0);\n        \n        if((materialIndex >= 0) && (materialIndex < NUMBER_OF_MATERIALS))\n        {\n        \tMaterial selectedMaterial = LoadMaterial(materialIndex);  \n            \n            vec4 materialMenuColor = DisplayMaterial(fragCoord, uv, selectedMaterial);            \n            finalColor = step(materialMenuColor.w, 0.0) * finalColor + step(0.0, materialMenuColor.w) * materialMenuColor.rgb;\n        }\n    }\n    else if(sceneMode == MONTE_CARLO_MODE)\n    {\n       int iteration = iFrame - int(sceneInfo.z);\n       finalColor = finalColor / float(iteration);\n        \n       float text = WriteIterationString(vec2(0.015, 0.0), uv, fragCoord, 1.1, iteration); \n       finalColor.rgb = ((1.0 - text) * finalColor.rgb) + vec3(text);\n    }\n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Data Storage and Slider Implementation\n//\n// References\n// https://www.shadertoy.com/view/MddGzf\n\n//////////////////////////////////////////////////\n// Constants\nconst float     PI \t\t\t     = 3.14159265359;\n\n//////////////////////////////////////////////////\n// Helpers \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float rc = 1.0 - c;\n    \n    return mat3(rc * axis.x * axis.x + c,          rc * axis.x * axis.y - axis.z * s, rc * axis.z * axis.x + axis.y * s,\n                rc * axis.x * axis.y + axis.z * s, rc * axis.y * axis.y + c,          rc * axis.y * axis.z - axis.x * s,\n                rc * axis.z * axis.x - axis.y * s, rc * axis.y * axis.z + axis.x * s, rc * axis.z * axis.z + c);\n}\n\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\nconst vec2 txPreviousKeyboard = vec2(0.0, 1.0);\nconst vec2 txPreviousMouse = vec2(0.0, 2.0);\n\nconst vec2 txCameraPosition = vec2(1.0, 0.0);\nconst vec2 txCameraForward = vec2(1.0, 1.0);\nconst vec2 txCameraRight = vec2(1.0, 2.0);\n\n//////////////////////////////////////////////////\n// Materials\nconst int NUMBER_OF_MATERIALS = 11;\nconst vec4 txMaterials = vec4(3.0, 0.0, 3.0 + float(NUMBER_OF_MATERIALS), 3.0);\n\nstruct Material\n{\n    vec3    mBaseColor;\n    float \tmRoughness;\n    \n    float \tmMetallic;\n    float   mReflectance;\n    float   mAmbient;\n    \n    int\t\tmDiffuseType;\n    int \tmMicrofacetDistributionType;\n    int\t\tmGeometricAttenuationType;\n};\n  \n// Metallics don't use reflectance\n#define METALLIC 1.0, 0.0     \n\n// Diffuse Types\nconst int LAMBERT_DIFFUSE \t\t\t= 0;\nconst int DISNEY_DIFFUSE  \t\t\t= 1;\n    \n// Microfacet Distribution Types\nconst int GGX_MICROFACET \t \t\t= 0;    \nconst int BECKMAN_MICROFACET \t\t= 1;\n\n// Geometric Attenuation Types\nconst int VSMITH_GGX_GEOMETRIC \t\t= 0;\nconst int UE4_GEOMETRIC \t\t\t= 1;\nconst int COOK_TORRANCE_GEOMETRIC \t= 2;\n\n#define DEFAULT_TYPES LAMBERT_DIFFUSE, GGX_MICROFACET, VSMITH_GGX_GEOMETRIC\n\nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nconst vec3 gold = vec3(1.0, 0.71, 0.29);\nconst vec3 copper = vec3(0.95, 0.64, 0.54);\nconst vec3 iron = vec3(0.56, 0.57, 0.58);\nconst vec3 aluminum = vec3(0.91, 0.92, 0.92);\nconst vec3 silver = vec3(0.95, 0.93, 0.88);\n\nvoid ResetMaterialsScene()\n{\n    float defaultAmbient = 0.05;\n    \n    // Plane\n    gMaterials[0] = Material(silver, 0.01, METALLIC, defaultAmbient, DEFAULT_TYPES); \n    gMaterials[1] = Material(vec3(0.0), 0.25, 0.0, 0.05, defaultAmbient, DEFAULT_TYPES); // Wood\n        \n    // Spheres\n    \n    // Metallics\n    gMaterials[2] = Material(iron, 0.22, METALLIC, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[3] = Material(gold, 0.1, METALLIC, defaultAmbient, DEFAULT_TYPES);  \n    gMaterials[5] = Material(silver, 0.75, METALLIC, defaultAmbient, DEFAULT_TYPES);   \n    gMaterials[6] = Material(copper, 0.2, METALLIC, defaultAmbient, DEFAULT_TYPES);\n\n    // dielectric \n   \tgMaterials[4] = Material(vec3(0.9, 0.1, 0.1), 0.9, 0.0, 0.05, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[7] = Material(vec3(0.9, 0.1, 0.1), 0.1, 0.0, 0.05, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[10] = Material(vec3(0.9, 0.1, 0.1), 0.02, 0.0, 0.15, defaultAmbient, DEFAULT_TYPES);  \n    gMaterials[9] = Material(vec3(0.9, 0.1, 0.1), 0.02, 0.0, 0.8, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[8] = Material(vec3(0.9, 0.1, 0.1), 0.02, 0.0, 0.4, defaultAmbient, DEFAULT_TYPES);\n}\n\n//////////////////////////////////////////////////\n// Camera\nstruct Camera\n{\n\tvec3 mPosition;\n    vec3 mForward;\n    vec3 mRight;\n};\nCamera gCamera;\n   \n//////////////////////////////////////////////////\n// Editor\nvec2 CheckSlider(in vec4 mouseCoords, in float height)\n{\n    vec2 clickUV = mouseCoords.zw / iResolution.xy;\n    float cursorX = mouseCoords.x / iResolution.x;\n    float inSliderBounds = step(0.015, clickUV.x)*step(clickUV.x, 0.29) *step(clickUV.y, 1.0-(height+0.01))*step(1.0-(height+0.04), clickUV.y);\n    return vec2(inSliderBounds, Saturate((cursorX - 0.015) / 0.275) * inSliderBounds);   \n}\n\nfloat CheckClickBox(in vec4 mouseCoords, in float height)\n{\n    vec2 clickUV = mouseCoords.zw / iResolution.xy;\n    float inBounds = step(0.01, clickUV.x)*step(clickUV.x, 0.29) *step(clickUV.y, 1.0-(height))*step(1.0-(height+0.035), clickUV.y);\n    return inBounds;   \n}\n\n//////////////////////////////////////////////////\n// Loading and Saving\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nMaterial LoadMaterial(in int materialIndex)\n{\n    vec4 materialInfo0 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 0.0));\n    vec4 materialInfo1 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 1.0));\n    vec4 materialInfo2 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 2.0));\n\n    return Material(materialInfo0.xyz, materialInfo0.w, materialInfo1.x, materialInfo1.y, \n                    materialInfo1.z, int(materialInfo2.x), int(materialInfo2.y), int(materialInfo2.z));\n}\n\nvoid LoadMaterials()\n{\n    for(int materialIndex = 0; materialIndex < NUMBER_OF_MATERIALS; ++materialIndex)\n    {\n    \tgMaterials[materialIndex] = LoadMaterial(materialIndex);\n    }\n}\n\nvoid StoreMaterial(in vec2 re, in Material material, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 materialInfo0 = vec4(material.mBaseColor.xyz, material.mRoughness);\n    vec4 materialInfo1 = vec4(material.mMetallic, material.mReflectance, material.mAmbient, 0.0);\n    vec4 materialInfo2 = vec4(material.mDiffuseType, material.mMicrofacetDistributionType, material.mGeometricAttenuationType, 0.0);\n\n    StoreValue(re, materialInfo0, fragColor, fragCoord);\n    StoreValue(re + vec2(0.0, 1.0), materialInfo1, fragColor, fragCoord);\n    StoreValue(re + vec2(0.0, 2.0), materialInfo2, fragColor, fragCoord);\n}\n\nvoid StoreMaterials(inout vec4 fragColor, in vec2 fragCoord)\n{\n    for(int materialIndex = 0; materialIndex < NUMBER_OF_MATERIALS; ++materialIndex)\n    {\n    \tStoreMaterial(txMaterials.xy + vec2(materialIndex, 0.0), gMaterials[materialIndex], fragColor, fragCoord);\n    }\n}\n   \nvoid LoadCamera()\n{\n    vec3 cameraPosition = LoadValue(txCameraPosition.xy).xyz;\n    vec3 cameraForward  = LoadValue(txCameraForward.xy).xyz;\n\tvec3 cameraRight = LoadValue(txCameraRight.xy).xyz;\n    gCamera = Camera(cameraPosition, cameraForward, cameraRight);\n}\n\nvoid StoreCamera(inout vec4 fragColor, in vec2 fragCoord) \n{\n    StoreValue(txCameraPosition, vec4(gCamera.mPosition, 0.0), fragColor, fragCoord);\n    StoreValue(txCameraForward, vec4(gCamera.mForward, 0.0), fragColor, fragCoord);\n    StoreValue(txCameraRight, vec4(gCamera.mRight, 0.0), fragColor, fragCoord);\n}\n\nvoid UpdateCamera()\n{\n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 1.75) * (PI * 1.15) : 0.8;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05;\n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 3.5;\n    gCamera.mPosition.xyz = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    gCamera.mForward.xyz = yRotationMatrix * xRotationMatrix * vec3(0.0, 0.0, -1.0);\n    gCamera.mRight.xyz = yRotationMatrix * xRotationMatrix * vec3(1.0, 0.0, 0.0);\n}\n\n//////////////////////////////////////////////////\n// Keys\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nbool GeyKeyState(in float key)\n{\n\treturn (texture(iChannel1, vec2(key, 0.25)).x > 0.5);   \n}\n\nstruct KeyboardState\n{\n    bool mKeyModeForward[2];\n\tbool mKeyModeBackwards[2];\n\tbool mKeyW[2];\n\n    bool mKeyS[2];\n};\nKeyboardState gKeyboardState;\n    \nvoid LoadKeyboardState()\n{\n    vec4 previousKeyboardState = LoadValue(txPreviousKeyboard);\n    \n    // current keys\n    gKeyboardState.mKeyModeForward[0]   = GeyKeyState(KEY_D) || GeyKeyState(KEY_RIGHT);\n    gKeyboardState.mKeyModeBackwards[0] = GeyKeyState(KEY_A) || GeyKeyState(KEY_LEFT);\n    gKeyboardState.mKeyW[0] = GeyKeyState(KEY_W);\n    gKeyboardState.mKeyS[0] = GeyKeyState(KEY_S);\n  \n    // previous keys\n    gKeyboardState.mKeyModeForward[1] \t= (previousKeyboardState.x > 0.0);\n    gKeyboardState.mKeyModeBackwards[1] = (previousKeyboardState.y > 0.0);\n    gKeyboardState.mKeyW[1] = (previousKeyboardState.z > 0.0);\n    gKeyboardState.mKeyS[1] = (previousKeyboardState.w > 0.0);\n}\n\nvoid StoreKeyboardState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 previousKeyboardState = vec4(float(gKeyboardState.mKeyModeForward[0]), float(gKeyboardState.mKeyModeBackwards[0]), float(gKeyboardState.mKeyW[0]), float(gKeyboardState.mKeyS[0]));\n    StoreValue(txPreviousKeyboard, previousKeyboardState, fragColor, fragCoord);\n}\n \nbool WasKeyJustPressed(in float key)\n{\n    if(key == KEY_RIGHT)\n    {\n        return (gKeyboardState.mKeyModeForward[0] && (gKeyboardState.mKeyModeForward[1] == false));\n    }    \n\telse if(key == KEY_LEFT)\n    {\n        return (gKeyboardState.mKeyModeBackwards[0] && (gKeyboardState.mKeyModeBackwards[1] == false));\n    }\n    return false;\n}\n\n//////////////////////////////////////////////////\n// Modes\nconst float ATTRACT_MODE \t\t= 0.0;\nconst float EDIT_MODE \t\t\t= 1.0;\nconst float MONTE_CARLO_MODE \t= 2.0;\n\nfloat UpdateSceneMode(in float currentSceneMode)\n{\n    if(WasKeyJustPressed(KEY_LEFT))\n    {\n        currentSceneMode = (currentSceneMode >= MONTE_CARLO_MODE) ? ATTRACT_MODE : (currentSceneMode + 1.0);\n    }\n    else if(WasKeyJustPressed(KEY_RIGHT))\n    {\n        currentSceneMode = (currentSceneMode <= ATTRACT_MODE) ? MONTE_CARLO_MODE : (currentSceneMode - 1.0);\n    } \n    return currentSceneMode;\n}\n\nint NextDiffuseType(in int currentDiffuseType)\n{\n    return (currentDiffuseType >= DISNEY_DIFFUSE) ? 0 : (currentDiffuseType + 1);\n}\n\nint NextMicrofacetType(int currentMicrofacetType)\n{\n    return (currentMicrofacetType >= BECKMAN_MICROFACET) ? 0 : (currentMicrofacetType + 1);\n}\n\nint NextGeometricAttenuationType(int currentGeometricAttenuationType)\n{\n    return (currentGeometricAttenuationType >= COOK_TORRANCE_GEOMETRIC) ? 0 : (currentGeometricAttenuationType + 1);\n}\n\nvoid ApplyOptions(in int materialIndex, in float previousMouseX)\n{\n    vec2 redColorSlider \t= CheckSlider(iMouse, 0.18);\n    vec2 greenColorSlider \t= CheckSlider(iMouse, 0.225);\n    vec2 blueColorSlider \t= CheckSlider(iMouse, 0.27);\n    \n    vec2 roughnessSlider \t= CheckSlider(iMouse, 0.365);\n    vec2 metallicSlider \t= CheckSlider(iMouse, 0.455);\n    vec2 reflectanceSlider \t= CheckSlider(iMouse, 0.55);\n    vec2 ambientSlider \t\t= CheckSlider(iMouse, 0.65);\n    \n\tfor(int i = 0; i < NUMBER_OF_MATERIALS; ++i)\n    {\n        if(i == materialIndex)\n        {\n            gMaterials[i].mBaseColor.r = (redColorSlider.x > 0.0) ? redColorSlider.y : gMaterials[i].mBaseColor.r;\n            gMaterials[i].mBaseColor.g = (greenColorSlider.x > 0.0) ? greenColorSlider.y : gMaterials[i].mBaseColor.g;\n            gMaterials[i].mBaseColor.b = (blueColorSlider.x > 0.0) ? blueColorSlider.y : gMaterials[i].mBaseColor.b;\n\n            gMaterials[i].mRoughness \t= max((roughnessSlider.x > 0.0) ? roughnessSlider.y : gMaterials[i].mRoughness, 0.01); // min roughness is 0.01  \n            gMaterials[i].mMetallic \t= (metallicSlider.x > 0.0) ? metallicSlider.y : gMaterials[i].mMetallic;\n            gMaterials[i].mReflectance \t= (reflectanceSlider.x > 0.0) ? reflectanceSlider.y : gMaterials[i].mReflectance;\n            gMaterials[i].mAmbient \t\t= (ambientSlider.x > 0.0) ? ambientSlider.y : gMaterials[i].mAmbient;\n            \n            if(previousMouseX < 0.0)\n            {\n                gMaterials[i].mDiffuseType = (CheckClickBox(iMouse, 0.75) > 0.0) ? NextDiffuseType(gMaterials[i].mDiffuseType) : gMaterials[i].mDiffuseType;\n                gMaterials[i].mMicrofacetDistributionType = (CheckClickBox(iMouse, 0.8) > 0.0) ? NextMicrofacetType(gMaterials[i].mMicrofacetDistributionType) : gMaterials[i].mMicrofacetDistributionType;\n                gMaterials[i].mGeometricAttenuationType = (CheckClickBox(iMouse, 0.85) > 0.0) ? NextGeometricAttenuationType(gMaterials[i].mGeometricAttenuationType) : gMaterials[i].mGeometricAttenuationType;\n            }\n    \t}\n    }\n}\n\n//////////////////////////////////////////////////\n// Implementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if((fragCoord.x > 15.0) || (fragCoord.y > 3.0))\n    \tdiscard;\n        \n    vec4 sceneInfo = LoadValue(txSceneModeInfo);   \n    vec4 previousMouse = LoadValue(txPreviousMouse);\n    LoadCamera();\n \tLoadMaterials();\n    LoadKeyboardState();\n    \n    if(iFrame == 0)\n    {\n        sceneInfo = vec4(ATTRACT_MODE, -1.0, 0.0, 0.0);\n        ResetMaterialsScene();\n        \n        UpdateCamera();\n    }\n    else if(iFrame == 1)\n    {\n        sceneInfo.x = EDIT_MODE;\n    }\n    else\n    {\n        float previousSceneMode = sceneInfo.x;      \n        float currentSceneMode = UpdateSceneMode(previousSceneMode);\n        \n        if(previousSceneMode != currentSceneMode)\n        {\n         \tsceneInfo.zw = vec2(iFrame, iTime);   \n        }\n        \n        if(currentSceneMode == ATTRACT_MODE)\n        {\n \t\t\tUpdateCamera();\n        }\n        else if(currentSceneMode == EDIT_MODE)\n        {\n            if(iMouse.z > 0.0)\n            {\n                float pendingMaterialIndex = texture(iChannel2, iMouse.xy / iChannelResolution[2].xy).w;\n                const float menuWidth = 0.3;\n                if(iMouse.z > (menuWidth * iResolution.x))\n                {\n                    sceneInfo.y  = pendingMaterialIndex;\n                }\n\n                int currentMaterialIndex = int(sceneInfo.y);\n                if((currentMaterialIndex >= 0) && (currentMaterialIndex < NUMBER_OF_MATERIALS))\n                {\n                    ApplyOptions(currentMaterialIndex, previousMouse.z);\n            \t}\n            }\n        } \n        sceneInfo = vec4(currentSceneMode, sceneInfo.y, sceneInfo.z, sceneInfo.w);\n    }\n    \n    fragColor = vec4(0.0);\n    \n    StoreValue(txSceneModeInfo, sceneInfo, fragColor, fragCoord);\n    StoreValue(txPreviousMouse, iMouse, fragColor, fragCoord);\n    StoreCamera(fragColor, fragCoord);\n    StoreMaterials(fragColor, fragCoord);\n    StoreKeyboardState(fragColor, fragCoord);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsfGzn",
       "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sfGzn",
       "filepath": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png",
       "type": "cubemap",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Scene Display\n\n// References:\n//\n// PBR\n// https://www.shadertoy.com/view/MlB3DV\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n// http://www.trentreed.net/blog/physically-based-shading-and-image-based-lighting/\n// \n// Monte Carlo References\n// https://www.shadertoy.com/view/MsdGzl\n// https://www.shadertoy.com/view/Xtt3Wn\n\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\nconst vec2 txCameraPosition = vec2(1.0, 0.0);\nconst vec2 txCameraForward = vec2(1.0, 1.0);\nconst vec2 txCameraRight = vec2(1.0, 2.0);\n\n\nconst int NUMBER_OF_MATERIALS = 11;\nconst vec4 txMaterials = vec4(3.0, 0.0, 3.0 + float(NUMBER_OF_MATERIALS), 3.0);\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_BOUNCES   \t2\n#define     SHADOWS_ENABLED     \t1\n\n//////////////////////////////////////////////////\n// General Constants and Globals\nconst float     PI \t\t\t     = 3.14159265359;\nconst float     MAX_DISTANCE \t = 10.0;\nconst float     EPSILON \t\t = 0.001;\nconst float \tMONTE_CARLO_MODE = 2.0;\n\nvec4 \t\t\tgSceneInfo;\nfloat \t\t\tgTimeValue;\nfloat \t\t\tgSA;\n\n//////////////////////////////////////////////////\n// Helpers \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Hash(in float seed)\n{\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec3 GammaCorrect(in vec3 color)\n{\n    return pow(color, vec3(2.2));\n}\n\nvec3 GammaEncode(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 SampleCubeMap(in vec3 direction, in float x)\n{\n    vec3 sharp = GammaCorrect(texture(iChannel0, direction).rgb);\n    vec3 blurry = texture(iChannel1, direction).rgb;\n    \n    //vec3 linearGammaColor = textureLodEXT(iChannel0, direction, mix(0.0, 8.0, saturate(x))).rgb; :(\n    vec3 linearGammaColor = mix(sharp, blurry, Saturate(x));\n    \n    return linearGammaColor;\n}\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel3, (0.5 + re) / iChannelResolution[3].xy, -100.0);\n}\n\nvec3 RandomDirection(in float seed, in vec3 startingDirection)\n{\n    startingDirection = normalize(startingDirection);\n    \n    vec3 direction = normalize(vec3(Hash(78.233 + seed), Hash(10.873 + seed), Hash(27.873 + seed)));\n    direction = (dot(direction, startingDirection) < 0.0) ? -direction : direction;\n    return direction;\n}\n\nvec3 RandomDirectionAroundRange(in float seed, in float range, in vec3 startingDirection)\n{\n    vec3 direction = RandomDirection(seed, startingDirection);\n    direction = (dot(direction, startingDirection) < range) ? startingDirection : direction;\n    return direction;\n}\n\n//////////////////////////////////////////////////\n// Materials\nstruct Material\n{\n    vec3    mBaseColor;\n    float \tmRoughness;\n    float \tmMetallic;\n    float   mReflectance;\n    float   mAmbient;\n    \n    int\t\tmDiffuseType;\n    int \tmMicrofacetDistributionType;\n    int\t\tmGeometricAttenuationType;\n    \n    int \tmIndex;\n};\n    \n// Diffuse Types\nconst int LAMBERT_DIFFUSE \t\t\t= 0;\nconst int DISNEY_DIFFUSE  \t\t\t= 1;\n    \n// Microfacet Distribution Types\nconst int GGX_MICROFACET \t \t\t= 0;    \nconst int BECKMAN_MICROFACET \t\t= 1;\n\n// Geometric Attenuation Types\nconst int VSMITH_GGX_GEOMETRIC \t\t= 0;\nconst int UE4_GEOMETRIC \t\t\t= 1;\nconst int COOK_TORRANCE_GEOMETRIC \t= 2;\n\n    \nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nMaterial LoadMaterial(in int materialIndex)\n{\n    vec4 materialInfo0 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 0.0));\n    vec4 materialInfo1 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 1.0));\n    vec4 materialInfo2 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 2.0));\n\n    return Material(materialInfo0.xyz, materialInfo0.w, materialInfo1.x, materialInfo1.y, \n                    materialInfo1.z, int(materialInfo2.x), int(materialInfo2.y), int(materialInfo2.z), materialIndex);\n}\n\nvoid LoadMaterials()\n{  \n    for(int i = 0; i < NUMBER_OF_MATERIALS; ++i)\n    {\n    \tgMaterials[i] = LoadMaterial(i);\n    }\n}\n\n//////////////////////////////////////////////////\n// Geometry\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n};    \n\nstruct Sphere\n{\n    vec3    \tmCenter;\n    float   \tmRadius;\n};\n\nstruct Plane\n{\n    vec3    \tmNormal;\n    float   \tmD;\n};\n        \n//////////////////////////////////////////////////\n// Intersection Helpers   \nstruct IntersectionPoint\n{\n    vec3        mPoint;\n    vec3        mNormal;\n    float       mT;\n    Material    mMaterial;\n};\n    \nIntersectionPoint GetClosestIntersection(in IntersectionPoint a, in IntersectionPoint b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;  \n}\n  \nbool IsIntersectionValid(in IntersectionPoint a)\n{\n    return (a.mT < (MAX_DISTANCE - EPSILON));  \n}\n\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE, gMaterials[0])\n\n//////////////////////////////////////////////////\n// Intersection Tests\nIntersectionPoint RayPlaneIntersectionTest(in Ray ray, in Plane plane)\n{\n    IntersectionPoint intersection = INVALID_INTERSECTION;\n    \n    float numerator = plane.mD - dot(plane.mNormal, ray.mPosition);\n    float denominator = dot(plane.mNormal, ray.mDirection);\n    if(abs(denominator) > EPSILON)\n    {\n        float t = numerator / denominator;\n        if(t > EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = plane.mNormal;\n            intersection.mT = t;\n        }\n    }\n    return intersection;\n}\n\nIntersectionPoint RaySphereIntersectionTest(in Ray ray, in Sphere sphere)\n{   \n    IntersectionPoint intersection = INVALID_INTERSECTION;\n\n    vec3 eDistance = ray.mPosition - sphere.mCenter;\n    \n    float b = dot(eDistance, normalize(ray.mDirection));\n    float c = dot(eDistance, eDistance) - (sphere.mRadius * sphere.mRadius);\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        if(discriminant >= EPSILON)\n        {\n            float t = max(-b - sqrt(discriminant), 0.0); // clamp t to zero incase it started inside the sphere\n\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = normalize(intersection.mPoint - sphere.mCenter);\n            intersection.mT = t;         \n        } \n       \n    }\n    return intersection;\n}\n\nIntersectionPoint CheckSceneForIntersection(in Ray currentRay)\n{\n    float sphereRadius = 0.5;\n    \n    // Spheres\n    Sphere sphere0 = Sphere(vec3(-1.5, 0.0, -1.5), sphereRadius);  \n    Sphere sphere1 = Sphere(vec3(-1.5, 0.0, 0.0), sphereRadius);  \n    Sphere sphere2 = Sphere(vec3(-1.5, 0.0, 1.5), sphereRadius);\n    Sphere sphere3 = Sphere(vec3(0.0, 0.0, -1.5), sphereRadius);\n    Sphere sphere4 = Sphere(vec3(0.0, 0.0, 0.0), sphereRadius);\n    Sphere sphere5 = Sphere(vec3(0.0, 0.0, 1.5), sphereRadius);\n    Sphere sphere6 = Sphere(vec3(1.5, 0.0, -1.5), sphereRadius);\n    Sphere sphere7 = Sphere(vec3(1.5, 0.0, 0.0), sphereRadius);\n    Sphere sphere8 = Sphere(vec3(1.5, 0.0, 1.5), sphereRadius);\n\n    // Check scene for intersection   \n    IntersectionPoint sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere0);\n    sphereIntersection0.mMaterial = gMaterials[2];\n\n    IntersectionPoint sphereIntersection1 = RaySphereIntersectionTest(currentRay, sphere1);\n    sphereIntersection1.mMaterial = gMaterials[3];\n    IntersectionPoint closestIntersection = GetClosestIntersection(sphereIntersection0, sphereIntersection1);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere2);\n    sphereIntersection0.mMaterial = gMaterials[4];  \n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere3);\n    sphereIntersection0.mMaterial = gMaterials[5];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere4);\n    sphereIntersection0.mMaterial = gMaterials[6];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere5);\n    sphereIntersection0.mMaterial = gMaterials[7];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere6);\n    sphereIntersection0.mMaterial = gMaterials[8];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere7);\n    sphereIntersection0.mMaterial = gMaterials[9];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere8);\n    sphereIntersection0.mMaterial = gMaterials[10];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    // Ground Plane \n    Plane plane0 = Plane(vec3(0.0, 1.0, 0.0), -0.5);  \n    IntersectionPoint planeIntersection = RayPlaneIntersectionTest(currentRay, plane0);\n\n    planeIntersection.mMaterial = gMaterials[1];  \n    planeIntersection.mMaterial.mBaseColor = texture(iChannel2, planeIntersection.mPoint.xz * vec2(1.5)).rgb;\n    \n    vec2 tile = mod(planeIntersection.mPoint.xz + vec2(0.1), vec2(2.0));\n    if((tile.x + tile.y < 2.0) && (max(abs(planeIntersection.mPoint.x), abs(planeIntersection.mPoint.z)) < 25.0))\n    {\n        planeIntersection.mMaterial = gMaterials[0];\n    }\n    closestIntersection = GetClosestIntersection(closestIntersection, planeIntersection);\n     \n    return closestIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Specular BRDF - Normal Distribution Function (NDF)\n\nfloat BeckmannMicrofacetDistribution(in float NdotH, in float roughnessSquared)\n{\n    float NHSquared = NdotH * NdotH;\n\n    return (1.0 / roughnessSquared * NHSquared * NHSquared) * (exp(-((1.0 - NHSquared) / (roughnessSquared * NHSquared))));\n}\n\nfloat GGXDistribution(in float NdotH, in float roughnessSquared)\n{\n\t// Divide by PI is applied later\n\t//float roughnessSquared = roughness * roughness;\n\t//float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n\t//return roughnessSquared / (f * f);\n    \n    //float roughnessSquared = roughness * roughness;\n    //float NdotHSquared = NdotH * NdotH;\n    //float density = NdotHSquared * roughnessSquared + (1.0 - NdotHSquared);\n    //return ((NdotH > 0.0) ? 1.0 : 0.0) * roughnessSquared / (PI * density * density);   \n    \n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (f * f);\n}\n  \nfloat GetMicrofacetDistribution(in int type, in float NdotH, in float roughnessSquared)\n{\n\tif(type == GGX_MICROFACET)\n    {\n        return GGXDistribution(NdotH, roughnessSquared);\n    }\n    return BeckmannMicrofacetDistribution(NdotH, roughnessSquared); // Otherwise we'll assume beckmann\n}\n\n//////////////////////////////////////////////////////\n// Geometric Attenuation\n\n//////////////////////////////////////////////////////\n// Cook Torrance Geometric Attenuation\nfloat CookTorranceGeometricAttenuation(in float NdotH, in float NdotL, in float VdotH, in float NdotV)\n{\n\treturn (min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)));\n}\n\n//////////////////////////////////////////////////////\n// GGXSmith\n//\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n// http://graphicrants.blogspot.co.uk/2013/08/specular-brdf-reference.html\nfloat VSmithGGXCorrelated(in float NdotL, in float NdotV, in float roughnessSquared)\n{\n\t// Original formulation of G_SmithGGX Correlated\n\t//float lambda_l = (-1.0 + sqrt(1.0 + roughnessSquared * (1.0 - NdotV * NdotV) / NdotV * NdotV)) * 0.5;\n    //float lambda_v = (-1.0 + sqrt(1.0 + roughnessSquared * (1.0 - NdotL * NdotL) / NdotL * NdotL)) * 0.5;\n \t\n \t//float G_SmithGGXCorrelated = 1.0 / (1.0 + lambda_v + lambda_l);\n \t//float V_SmithGGXCorrelated = G_SmithGGXCorrelated / (4.0 * NdotL * NdotV);\n\n    //return G_SmithGGXCorrelated * V_SmithGGXCorrelated;\n    \n \t// This is the optimized version\n \t// Caution : the \" NdotL *\" and \" NdotV *\" are explicitely inversed , this is not a mistake.\n \tfloat Lambda_GGXV = NdotL * sqrt((-NdotV * roughnessSquared + NdotV) * NdotV + roughnessSquared);\n \tfloat Lambda_GGXL = NdotV * sqrt((-NdotL * roughnessSquared + NdotL) * NdotL + roughnessSquared);\n\n\treturn Saturate(0.5 / (Lambda_GGXV + Lambda_GGXL));\n}\n\n//////////////////////////////////////////////////////\n// Unreal\n//\n// http://graphicrants.blogspot.co.uk/2013/08/specular-brdf-reference.html\nfloat UE4GeometricAttenuation(in float roughnessSquared, in float NdotV)\n{\n\tfloat k = roughnessSquared / 2.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GetGeometricAttenuation(int type, in float NdotH, in float NdotL, in float VdotH, in float NdotV, in float roughnessSquared)\n{\n    if(type == VSMITH_GGX_GEOMETRIC)\n    {\n        return VSmithGGXCorrelated(NdotV, NdotL, roughnessSquared);\n    }\n    else if(type == UE4_GEOMETRIC)\n    {\n        return UE4GeometricAttenuation(roughnessSquared, NdotV);\n    }\n    return CookTorranceGeometricAttenuation(NdotH, NdotL, VdotH, NdotV); // Otherwise we'll assume cook torrance\n}\n\n//////////////////////////////////////////////////////\n// Fresnel \nvec3 SchlickFresnel(in float u, in vec3 fresnelReflectanceIndex0, in float fresnelReflectanceIndex90)\n{\n    return fresnelReflectanceIndex0 + (fresnelReflectanceIndex90 - fresnelReflectanceIndex0) * pow(Saturate(1.0 - u), 5.0);\n}\n\n//////////////////////////////////////////////////////\n// Diffuse\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float linearRoughness)\n{\n    float energyBias = mix(0.0, 0.5, linearRoughness);\n    float energyFactor = mix(1.0, 1.0 / 1.51,  linearRoughness);\n    float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness;\n    \n    vec3 f0 = vec3(1.0);\n    float lightScatter = SchlickFresnel(NdotL,f0, fd90).x;\n    float viewScatter = SchlickFresnel(NdotV, f0, fd90).x;\n    return lightScatter * viewScatter * energyFactor;\n}\n\nfloat GetDiffuse(in int type, in float NdotV, in float NdotL, in float LdotH, in float linearRoughness)\n{\n    if(type == DISNEY_DIFFUSE)\n    {\n        return DisneyDiffuse(NdotV, NdotL, LdotH, linearRoughness) / PI;\n    }\n    return 1.0 / PI; // otherwise we assume lambert\n}\n\nstruct DirectionalLight\n{\n    vec3 mDirection;\n    vec3 mColor;\n}; \n\nstruct BRDFOutput\n{\n\tvec3 mDiffuse;\n    vec3 mSpecular;\n    vec3 mLighting;\n    vec3 mBackgroundReflectionColor;\n};\n\nBRDFOutput GetBRDFOutput(in vec3 point, in vec3 normal, in vec3 eye, in vec3 lightDirection, in vec3 lightColor, in float attenutation, in Material material)\n{  \n    BRDFOutput returnValue;\n    \n    // Determine some values\n    float roughness = max(material.mRoughness, 0.01); // min roughness is 0.01\n    float roughnessSquared = roughness * roughness;\n    \n    vec3 viewVector = normalize(eye - point);   \n    vec3 halfVector = normalize(lightDirection + viewVector);\n\t\n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = abs(dot(normal, viewVector)) + EPSILON;\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float LdotH = Saturate(dot(lightDirection, halfVector));\n    \n    // D = MicrofacetDistribution\n    float microfacetDistribution = GetMicrofacetDistribution(material.mMicrofacetDistributionType, NdotH, roughnessSquared);\n    \n    // G = Geometric attenuation\n    float geometricAttenuation = GetGeometricAttenuation(material.mGeometricAttenuationType, NdotH, NdotL, VdotH, NdotV, roughnessSquared);\n    \n    // F = Fresnel\n    float reflectanceSquared = material.mReflectance * material.mReflectance;\n    //vec3 f0 = ((material.mReflectance) * (1.0 - material.mMetallic)) + (material.mBaseColor * material.mMetallic);    \n    vec3 f0 = (0.16 * (reflectanceSquared) * (1.0 - material.mMetallic)) + (material.mBaseColor * material.mMetallic);    \n    \n    float f90 = Saturate(50.0 * dot(f0, vec3(0.33)));\n    vec3 fresnel = SchlickFresnel(LdotH, f0, f90);\n    \n    // Diffuse \n    vec3 diffuseColor = ((1.0 - material.mMetallic) * material.mBaseColor);\n    returnValue.mDiffuse = diffuseColor * GetDiffuse(material.mDiffuseType, NdotV, NdotL, LdotH, roughness);\n\n    // Specular\n    returnValue.mSpecular = (fresnel * microfacetDistribution * geometricAttenuation) / PI;\n    \n    // Lighting\n    returnValue.mLighting = NdotL * lightColor * attenutation;\n    \n    vec3 reflectionDirection = reflect(-viewVector, normal); \n    returnValue.mBackgroundReflectionColor = SampleCubeMap(reflectionDirection.xyz, material.mRoughness);\n    \n    return returnValue;\n}\n\nBRDFOutput ApplyDirectionalLight(in DirectionalLight light, in Material material, in vec3 point, in vec3 normal, in vec3 eye, in bool castShadow)\n{\n    vec3 lightDirection = normalize(-light.mDirection);\n    BRDFOutput returnValue = GetBRDFOutput(point, normal, eye, lightDirection, light.mColor, 1.0, material);\n                 \n    // Cast a ray to check for shadows\n    float shadow = 1.0;\n#if SHADOWS_ENABLED\n    if(castShadow)\n    {\n    \tvec3 shadowRayDirection = (gSceneInfo.x == MONTE_CARLO_MODE) ? RandomDirectionAroundRange(float(iFrame), 0.7, lightDirection) : lightDirection;\n    \tRay shadowRay = Ray(point + (EPSILON * normal), shadowRayDirection);\n    \tIntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n    \tshadow = IsIntersectionValid(lightIntersection) ? 0.0 : shadow; // Determine if we hit an object and are in a shadow region \n    }\n#endif // SHADOWS_ENABLED\n    returnValue.mLighting *= shadow;\n    \n\treturn returnValue;\n}\n\nBRDFOutput AddBRDFOutput(in BRDFOutput a, in BRDFOutput b)\n{\n\tBRDFOutput returnValue;\n    \n    returnValue.mDiffuse =  max(a.mDiffuse, b.mDiffuse);\n    returnValue.mSpecular = max(a.mSpecular, b.mSpecular);\n    returnValue.mLighting = a.mLighting + b.mLighting;\n    returnValue.mBackgroundReflectionColor = a.mBackgroundReflectionColor;\n    \n    return returnValue;\n}\n\nBRDFOutput CalculateLighting(in Material material, in vec3 point, in vec3 normal, in vec3 eye)\n{\n    BRDFOutput returnValue;\n    \n    DirectionalLight directionalLight = DirectionalLight(vec3(0.0, -1.0, 0.0), vec3(1.0));;    \n    returnValue = ApplyDirectionalLight(directionalLight, material, point, normal, eye, true);\n\n    directionalLight.mDirection = normalize(vec3(15.0 * sin(gTimeValue), -8.0, 15.0 * cos(gTimeValue)));\n    returnValue = AddBRDFOutput(returnValue, ApplyDirectionalLight(directionalLight, material, point, normal, eye, true));\n    \n    directionalLight.mDirection = normalize(vec3(-15.0 * cos(-gTimeValue), -8.0, 15.0 * sin(-gTimeValue)));\n    returnValue = AddBRDFOutput(returnValue, ApplyDirectionalLight(directionalLight, material, point, normal, eye, true));\n    \n    return returnValue;\n}\n\nvec4 CalculateColor(in Ray ray, in float sa, in int currentFrameIndex)\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n\n    int materialIndex = NUMBER_OF_MATERIALS;\n \tfloat previousRoughness = 0.0;   \n\n    IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\tbool isIntersectionValid = IsIntersectionValid(currentIntersection);\n   \n    if(isIntersectionValid)\n    {\n        vec3 point = currentIntersection.mPoint;\n        vec3 normal = currentIntersection.mNormal;\n        materialIndex = currentIntersection.mMaterial.mIndex;\n\t\tpreviousRoughness = currentIntersection.mMaterial.mRoughness;\n        \n        BRDFOutput brdfOutput = CalculateLighting(currentIntersection.mMaterial, point, normal, ray.mPosition);\n\n        vec3 ambientColor = (currentIntersection.mMaterial.mAmbient * currentIntersection.mMaterial.mBaseColor); \n        \n        if(gSceneInfo.x != MONTE_CARLO_MODE)\n        {\n        \taccumulatedColor = ((brdfOutput.mDiffuse + brdfOutput.mSpecular * brdfOutput.mBackgroundReflectionColor) * brdfOutput.mLighting + ambientColor);        \n        }\n        else\n        {\n            accumulatedColor = ((brdfOutput.mDiffuse + brdfOutput.mSpecular) * brdfOutput.mLighting + ambientColor);        \n        }\n        colorMask *= brdfOutput.mSpecular;\n\n        // Determine the bounce direction of the ray incase we need it\n        vec3 reflectionDirection = reflect(ray.mDirection, normal);\n        reflectionDirection = RandomDirectionAroundRange(float(currentFrameIndex) / 37.81, mix(1.0, 0.5, currentIntersection.mMaterial.mRoughness), reflectionDirection);\n        ray.mDirection = reflectionDirection;       \n        ray.mPosition = point + ray.mDirection * EPSILON;  \n    }\n    else\n    {\n        accumulatedColor = SampleCubeMap(ray.mDirection, 0.0);\n    }\n     \n    // Only apply the bounces if we actually hit something\n   \tif((gSceneInfo.x == MONTE_CARLO_MODE) && isIntersectionValid)\n    {\n        vec3 sceneColor = vec3(0.0);\n        for(int bounceIndex = 0; bounceIndex < NUMBER_OF_BOUNCES; ++bounceIndex)\n        {\n            if(isIntersectionValid == false)\n            {\n                break;\n            }\n            \n            ray.mDirection = normalize(ray.mDirection);\n            IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\n            // Only apply the bounces if we actually hit something\n            isIntersectionValid = IsIntersectionValid(currentIntersection);\n            if(isIntersectionValid)\n            {\n                vec3 point = currentIntersection.mPoint;\n                vec3 normal = currentIntersection.mNormal;\n                previousRoughness = currentIntersection.mMaterial.mRoughness;\n    \n                BRDFOutput brdfOutput = CalculateLighting(currentIntersection.mMaterial, point, normal, ray.mPosition);\n\n                vec3 ambientColor = (currentIntersection.mMaterial.mAmbient * currentIntersection.mMaterial.mBaseColor); \n                vec3 sceneColor = ((brdfOutput.mDiffuse + brdfOutput.mSpecular * brdfOutput.mBackgroundReflectionColor) * brdfOutput.mLighting + ambientColor);        \n\n                // Add direct lighting\n                accumulatedColor += sceneColor * colorMask;\n                colorMask *= brdfOutput.mSpecular;\n\n                vec3 reflectionDirection = reflect(ray.mDirection, normal);\n                reflectionDirection = RandomDirectionAroundRange(float(currentFrameIndex) / 37.87, mix(1.0, 0.5, currentIntersection.mMaterial.mRoughness), reflectionDirection);\n                ray.mDirection = reflectionDirection;\n                ray.mPosition = point + ray.mDirection * EPSILON;           \n            }\n            else\n            {\n                sceneColor =  SampleCubeMap(ray.mDirection, previousRoughness).rgb;\n                accumulatedColor += sceneColor * colorMask;\n            }\n        }  \n    }\n \treturn vec4(accumulatedColor, float(materialIndex));   \n}\n\n//////////////////////////////////////////////////\n// Implementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LoadMaterials();\n    \n    gSceneInfo = LoadValue(txSceneModeInfo);\n    gTimeValue = (gSceneInfo.x == MONTE_CARLO_MODE) ? gSceneInfo.w : iTime;\n\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    float aspect = (iResolution.x / iResolution.y);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * aspect, (screenCoord.y * 2.0 - 1.0));\n \n    vec3 cameraPosition = LoadValue(txCameraPosition.xy).xyz;\n    vec3 cameraForward = LoadValue(txCameraForward.xy).xyz;\n    vec3 cameraRight = LoadValue(txCameraRight.xy).xyz;\n\n    if(iFrame == 0)\n    {\n    \tcameraPosition = vec3(0.0, 0.0, 3.5);\n        cameraForward = vec3(0.0, 0.0, -1.0);\n    \tcameraRight = vec3(1.0, 0.0, 0.0);\n        \n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 cameraUp = -cross(cameraForward, cameraRight);  \n    vec3 cameraDirection = normalize(cameraForward + (aspectRatioAdjustedUVs.x * cameraRight) + (aspectRatioAdjustedUVs.y * cameraUp));\n    \n    gSA = 0.0;\n    int currentMonteCarloFrame = iFrame - int(gSceneInfo.z);\n    \n    if(gSceneInfo.x == MONTE_CARLO_MODE)\n    {\n        gSA = Hash(dot(fragCoord, vec2(12.9898, 78.233)) + 1113.1 * (float(currentMonteCarloFrame)));\n    \tvec2 cameraOffset = -0.5 + vec2(Hash(gSA + 13.271), Hash(gSA + 63.216));\n\n        cameraOffset *= (1.0 / iResolution.xy);\n    \tcameraDirection = normalize(cameraDirection + (cameraOffset.x * cameraRight) + (cameraOffset.y * cameraUp));    \n    }\n    \n    Ray ray = Ray(cameraPosition, cameraDirection);\n    fragColor = CalculateColor(ray, gSA, currentMonteCarloFrame);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Monte Carlo Rendering\n//\n// Monte Carlo References\n// https://www.shadertoy.com/view/MsdGzl\n// https://www.shadertoy.com/view/Xtt3Wn\n\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\nconst float MONTE_CARLO_MODE = 2.0;\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel2, (0.5 + re) / iChannelResolution[2].xy, -100.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 sceneInfo = LoadValueBufferA(txSceneModeInfo);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sceneColor = texture(iChannel0, uv);\n\n    if((iFrame > 0) && (sceneInfo.x == MONTE_CARLO_MODE))\n    {\n   \t\tvec3 accumulatedColor = texture(iChannel1, uv).rgb;    \n    \tsceneColor = vec4(accumulatedColor.rgb + sceneColor.rgb, 1.0); \n    }  \n    fragColor = sceneColor;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4ltGD8",
    "date": "1708400582",
    "viewed": 285,
    "name": "Bomberman",
    "description": "Bomberman\nInitially wrote this about ~8 years ago but never finished it. Spent some time recently cleaning it up and figured I'd make it public despite some remaining issues. \nControls:\nPlayer0: Arrows+Space\nPlayer1: WASD+Q\nPlayer2: IJKL+U\nPlayer3: GVBN+F",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "game",
     "sdf",
     "sprite",
     "multipass",
     "bomberman"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4d33Dj",
       "filepath": "https://soundcloud.com/junechikuma/june-chikuma-nes-bomberman",
       "type": "musicstream",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Post\n// See Buffer C for additional visual settings\n\n// References:\n// [SH16C] Contra by knarkowicz    - https://www.shadertoy.com/view/XltGDr\n// CRT Effect by Jasper \t\t   - https://www.shadertoy.com/view/4sf3Dr\n// FixingPixelArt by TimothyLottes - https://www.shadertoy.com/view/XsjSzR\n\n//////////////////////////////////////////////////\n// Post Settings\n#define POST_EFFECTS  \t1\n#define CRT_CURVATURE \t1\n#define SCANLINES\t\t1\n\n//////////////////////////////////////////////////\n// Debugging Settings\n#define DISPLAY_SPRITE_SHEET 0\n\n//////////////////////////////////////////////////\n// Helpers\nvec2 CRTCurvature(in vec2 uv, in float strength)\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = (strength * abs(uv.yx)) * vec2(0.3334, 0.5);\n    uv = uv + uv * offset * offset;\n    return Saturate(uv * 0.5 + 0.5);\n}\n\nfloat Scanline(in float position)\n{\n    return sin((position * iResolution.y * 2.0)) * 0.1;\n}\n\n//////////////////////////////////////////////////\n// Implementation \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if POST_EFFECTS    \n\n#if CRT_CURVATURE    \n    vec2 gameUV = CRTCurvature(uv, 0.425);\n#else\n    vec2 gameUV = uv;\n#endif       \n    vec4 gameColor = texture(iChannel0, gameUV);\n   \n    float vignette = (gameUV.x * gameUV.y * (1.0 - gameUV.x) * (1.0 - gameUV.y));\n    vignette = Saturate(pow(16.0 * vignette, 0.3));\n\n    const float k_brightness = 1.5;  \n    vec3 finalColor = (gameColor.rgb * vignette * k_brightness);\n#if SCANLINES\n    finalColor = finalColor - Scanline(gameUV.y);\n#endif // SCANLINES\n\n#else    \n    vec4 gameColor = texture(iChannel0, uv);\n#endif // POST_EFFECTS    \n        \n#if DISPLAY_SPRITE_SHEET    \n    const int k_spriteIndex = 0;\n    vec4 spriteSheetColor = texture(iChannel1, (uv * 16.0 + vec2(float(k_spriteIndex) * 16.0, 0.0)) / iChannelResolution[1].xy);\n    finalColor = spriteSheetColor.rgb;\n#endif\n\n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Game state and gameplay\n\n//////////////////////////////////////////////////\n// Constants\nconst float BOMB_FUSE_TIME = 3.0; // 3 seconds\nconst float BOMB_EXPLOSION_TIME = 1.0;\nconst uint MAX_BOMB_LEVEL = 4U;\nconst uint MAX_FLAME_LEVEL = 19U;\nconst uint MAX_SKATE_LEVEL = 7U;\n\n// Facing Direction\nconst float DIRECTION_UP \t= 0.0;\nconst float DIRECTION_DOWN \t= 1.0;\nconst float DIRECTION_RIGHT = 2.0;\nconst float DIRECTION_LEFT \t= 3.0;\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\n// Same as LoadValueBufferA but with bound checking\nvec4 LoadTileValueBufferA(in vec2 re)\n{\n    if ((re.x >= txPlayField.x) && (re.y >= txPlayField.y) && (re.x <= txPlayField.z) && (re.y <= txPlayField.w - 1.0))\n    {\n    \treturn LoadValueBufferA(re);\n    }\n    return vec4(0.0);\n}\n\nvec4 LoadValueBufferB(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\n////////////////////////////////////////////////////////\n// Random\nfloat GetRandomValue(in float seed, in int startValue, in int range)\n{\n    vec3 value = texture(iChannel3, seed * (iTime + 1.0) * vec2(12.9898, 78.233 + iTime)).rgb;\n    return floor(mod((value.x + value.y * 7.13 + value.z * 131.0), float(range)) + float(startValue));    \n}\n\nfloat GetRandomStartingBlock(in vec2 tileIndex)\n{\n\treturn clamp(GetRandomValue(tileIndex.x + tileIndex.y * float(CELLS_WIDE), -5, 6), float(BREAKABLE_BLOCK), float(FREE_SPACE));   \n}\n\nfloat GetRandomPowerup(in vec2 tileIndex)\n{\n\treturn clamp(GetRandomValue(tileIndex.x + tileIndex.y * float(CELLS_WIDE), FREE_SPACE, FLAME_POWER_UP + 2), float(FREE_SPACE), float(FLAME_POWER_UP));   \n}\n\n////////////////////////////////////////////////////////\n// Tiles\nvec4 GetTileInfo(in vec2 tileIndex)\n{\n\treturn LoadValueBufferA(txPlayField.xy + tileIndex);\n}\n\nbool IsFreeTile(in int tileType)\n{\n    return ((tileType >= FREE_SPACE) && (tileType < BOMB));\n}\n\nvec4 ResetTile(vec2 tileIndex)\n{\n    float tileType = float(UNBREAKABLE_BLOCK); // Initially set all blocks as unbreakble\n\n    // Set random free blocks, breakable ect\n    if (((mod(tileIndex.x, 2.0) != 0.0) && (mod(tileIndex.y, 2.0) != 0.0)) == false)\n    {\n        tileType = GetRandomStartingBlock(tileIndex);\n    }\n\n    // Clear out space near the corners\n    if (length((tileIndex - vec2(7.0, 6.0))) > 8.25)\n    {\n        tileType = float(FREE_SPACE);\n    }\n    return vec4(tileType, 0.0, 0.0, 0.0f);\n}\n\n////////////////////////////////////////////////////////\n// Bomberman\nstruct BombSlots\n{\n    vec2    mBombTile0;\n    vec2    mBombTile1;\n    vec2    mBombTile2;\n    vec2    mBombTile3;\n};\n\nstruct Bomberman\n{\n\tvec2 \t\tmPosition;\n    float   \tmDirection;\n    float \t\tmAnimation;\n    \n    BombSlots \tmBombSlots;\n    \n    // Could pack these together\n    uint \t\tmBombLevel;  \n    uint \t\tmFlameLevel;\n    uint \t\tmSkateLevel;   \t\n    \n    uint \t\tmCurrentBombFreeSlot;\n    uint\t   \tmCurrentBombCount;\n};\n    \nBomberman gBomberman0;\nBomberman gBomberman1;\nBomberman gBomberman2;\nBomberman gBomberman3;\n     \n#define ResetBombSlots BombSlots(vec2(-1.0), vec2(-1.0), vec2(-1.0), vec2(-1.0))\n#define CreateDefaultBomberman(position, direction) Bomberman(position, direction, 0., ResetBombSlots, 1U, 2U, 1U, 0U, 0U)    \n\nvec2 ConvertPackedFloatToVec2(in float x)\n{\n    return vec2(mod(x, 100.0), floor(x * 0.01));\n}\n\nfloat ConvertVec2ToPackedFloat(in vec2 v)\n{\n    return (v.x + v.y * 100.0);\n}\n\nBomberman LoadBomberman(in vec2 re)\n{\n    vec4 bombermanInfo0 = LoadValueBufferA(re);\n    vec4 bombermanInfo1 = LoadValueBufferA(re + vec2(1.0, 0.0));\n    vec4 bombermanInfo2 = LoadValueBufferA(re + vec2(2.0, 0.0));\n    \n    vec2 bomb0Location = ConvertPackedFloatToVec2(bombermanInfo1.w); \n    vec2 bomb1Location = ConvertPackedFloatToVec2(bombermanInfo2.x); \n    vec2 bomb2Location = ConvertPackedFloatToVec2(bombermanInfo2.y); \n    vec2 bomb3Location = ConvertPackedFloatToVec2(bombermanInfo2.z); \n    \n    uint currentBombCount = 4U;\n    uint currentBombFreeSlot = 0U;\n    \n    bool bombTile0 = (bomb0Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb0Location).x) == BOMB);\n    bool bombTile1 = (bomb1Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb1Location).x) == BOMB);\n    bool bombTile2 = (bomb2Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb2Location).x) == BOMB);\n    bool bombTile3 = (bomb3Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb3Location).x) == BOMB);\n\n    if (bombTile3 == false)\n    {\n        currentBombFreeSlot = 3U;\n        bomb3Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n    \n    if (bombTile2 == false)\n    {\n        currentBombFreeSlot = 2U;\n        bomb2Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n\n    if (bombTile1 == false)\n    {\n        currentBombFreeSlot = 1U;\n        bomb1Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n\n    if (bombTile0 == false)\n    {\n        currentBombFreeSlot = 0U;\n        bomb0Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n    \n    return Bomberman(bombermanInfo0.xy, // position \n                     bombermanInfo0.z, // direction \n                     bombermanInfo0.w, // animation\n                     // bomb locations\n       \t\t\t     BombSlots(bomb0Location, bomb1Location, bomb2Location, bomb3Location),\n                     uint(bombermanInfo1.x), // bomb level\n                     uint(bombermanInfo1.y), // flame level \n                     uint(bombermanInfo1.z), // skate level\n                     // extra bomb info\n                     currentBombFreeSlot, currentBombCount);\n}\n\nvoid StoreBomberman(in vec2 re, in Bomberman b, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 bombermanInfo0 = vec4(b.mPosition, b.mDirection, b.mAnimation);  \n    vec4 bombermanInfo1 = vec4(b.mBombLevel, b.mFlameLevel, b.mSkateLevel, ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile0));\n    vec4 bombermanInfo2 = vec4(ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile1), ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile2),\n                               ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile3), 0.0);\n\n    StoreValue(re, bombermanInfo0, fragColor, fragCoord);\n    StoreValue(re + vec2(1.0, 0.0), bombermanInfo1, fragColor, fragCoord);\n    StoreValue(re + vec2(2.0, 0.0), bombermanInfo2, fragColor, fragCoord);\n}\n\n////////////////////////////////////////////////////////\n// Inputs\nstruct BombermanInput\n{\n    float mHorizontalMovement;\n\tfloat mVerticalMovement;\n    bool  mPlaceBomb;\n    float mLastBombTime;\n};\n\nBombermanInput gBomberman0Inputs;\nBombermanInput gBomberman1Inputs;\nBombermanInput gBomberman2Inputs;\nBombermanInput gBomberman3Inputs;\n\n////////////////////////////////////////////////////////\n// Gameplay\nbool CheckIfValidMove(in vec2 position, in vec2 movementDirection)\n{\n    vec2 normalizedMovementDirection = normalize(movementDirection);\n    vec4 currentTile = GetTileInfo(position);\n    vec2 targetPosition = position + movementDirection;\n    \n    vec2 targetTile = (position + normalizedMovementDirection);\n    \n    if ((targetPosition.x >= -0.25) && (targetPosition.x < float(CELLS_WIDE) - 0.5) \n\t\t&& (targetPosition.y >= -0.25) && (targetPosition.y < float(CELLS_TALL) - 0.5)) \n    {\n    \treturn (IsFreeTile(int(GetTileInfo(targetTile).x)) || IsFreeTile(int(GetTileInfo(targetPosition).x)));\n    }\n    return false;    \n}\n\nvoid HandleMovementInput(inout vec2 position, out float direction, inout float animation, in uint skateLevel, in BombermanInput inputs)\n{\n    const float k_defaultBombermanSpeed = 2.4;\n    const float k_speedIncreaseRate = 0.5;\n    \n    float bombermanSpeed = (k_defaultBombermanSpeed + (float(skateLevel) * k_speedIncreaseRate)) * iTimeDelta;\n\n    float xMovement = bombermanSpeed * inputs.mHorizontalMovement;\n    if ((xMovement != 0.0) && CheckIfValidMove(position, vec2(xMovement, 0.0)))\n    {\n        position.x += xMovement;\n        direction = (xMovement > 0.0) ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    } \n\n    float yMovement = bombermanSpeed * inputs.mVerticalMovement;\n    if ((yMovement != 0.0) && CheckIfValidMove(position, vec2(0.0, yMovement)))\n    {\n    \tposition.y += yMovement;\n        direction = (yMovement > 0.0) ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n    \n    const float k_walkAnimationLength = 40.0;\n    animation = ((xMovement + yMovement) != 0.0) ? (mod(animation + 1.0, k_walkAnimationLength)) : (animation += -sign(animation));\n}\n\nvoid UpdateBombSlot(inout BombSlots bombSlots, in vec2 tileIndex, in uint freeSlot)\n{\n    if (freeSlot == 0U)\n    {\n        bombSlots.mBombTile0 = tileIndex;\n    }\n    else if (freeSlot == 1U)\n    {\n        bombSlots.mBombTile1 = tileIndex;\n    }\n    else if (freeSlot == 2U)\n    {\n        bombSlots.mBombTile2 = tileIndex;\n    }\n    else if (freeSlot == 3U)\n    {\n        bombSlots.mBombTile3 = tileIndex;\n    }\n}\n\nvoid UpdateBombermanTile(inout vec4 tileInfo, in uint flameLevel, in bool placeBomb, in bool canPlaceBomb)\n{\n    int tileType = int(tileInfo.x);\n    if (canPlaceBomb && (tileType == FREE_SPACE) && placeBomb)\n    {\n        tileInfo.x = float(BOMB);\n        tileInfo.y = BOMB_FUSE_TIME;\n        tileInfo.z = float(EXPLOSION_DIRECTION_ALL);\n        \n        float floatFlameLevel = float(flameLevel);\n        tileInfo.w = floatFlameLevel;\n    }\n    else if ((tileType == BOMB_POWER_UP) || (tileType == FLAME_POWER_UP) || (tileType == SKATE_POWER_UP))\n    {\n        tileInfo.x = float(FREE_SPACE);\n        tileInfo.z = 0.0;\n    }   \n}\n\nvoid UpdateBomberman(inout Bomberman bomberman, inout vec4 tileInfo, in BombermanInput inputs)\n{         \n    vec2 bombermanTileIndex = GetTileIndex(ConvertTileCoordsToScreenUV(bomberman.mPosition.xy));\n    vec4 bombermanTileInfo = LoadValueBufferA(txPlayField.xy + bombermanTileIndex);\n\tint tileType = int(bombermanTileInfo.x);   \n    \n    bomberman.mBombLevel = min(bomberman.mBombLevel + ((tileType == BOMB_POWER_UP) ? 1U : 0U), MAX_BOMB_LEVEL);\n    bomberman.mFlameLevel = min(bomberman.mFlameLevel + ((tileType == FLAME_POWER_UP) ? 1U : 0U), MAX_FLAME_LEVEL);\n    bomberman.mSkateLevel = min(bomberman.mSkateLevel + ((tileType == SKATE_POWER_UP) ? 1U : 0U), MAX_SKATE_LEVEL);\n    bomberman.mPosition = (tileType == EXPLOSION) ? vec2(-100.0) : bomberman.mPosition;\n    \n    if ((tileType == FREE_SPACE) && (bomberman.mCurrentBombCount < bomberman.mBombLevel) && inputs.mPlaceBomb)\n    {\n        UpdateBombSlot(bomberman.mBombSlots, bombermanTileIndex, bomberman.mCurrentBombFreeSlot);\n    }   \n    HandleMovementInput(bomberman.mPosition, bomberman.mDirection, bomberman.mAnimation, bomberman.mSkateLevel, inputs);\n}\n\nBombermanInput LoadInputs(in vec2 re)\n{\n    vec4 inputs = LoadValueBufferB(re).xyzw;    \n    return BombermanInput(inputs.x, inputs.y, (inputs.z > 0.0), inputs.w);\n}\n\n//////////////////////////////////////////////////\n// Implementation \nvoid UpdateTile(inout vec4 tileInfo, in vec4 comparisionTile, in uint explosionDirection, in bool isBomb, in bool isBreakableBlock)\n{\n    if ((int(comparisionTile.x) == EXPLOSION) \n        && (comparisionTile.w > 0.0)\n        && ((uint(comparisionTile.z) == EXPLOSION_DIRECTION_ALL) \n        || (uint(comparisionTile.z) == explosionDirection)))\n    {\n        tileInfo.w = isBomb ? tileInfo.w : (isBreakableBlock ? 0.0 : comparisionTile.w - 1.0);\n        tileInfo.x = isBreakableBlock ? float(COLLAPSING_BLOCK) : float(EXPLOSION);\n        tileInfo.y = isBomb ? BOMB_EXPLOSION_TIME : ((int(tileInfo.x) == EXPLOSION) ? max(tileInfo.y, comparisionTile.y) : (comparisionTile.y - iTimeDelta));              \n        tileInfo.z = isBomb ? float(EXPLOSION_DIRECTION_ALL) : float(explosionDirection);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Don't compute gameplay outside of the data area\n    if ((fragCoord.x > float(CELLS_WIDE)) || (fragCoord.y > float(CELLS_TALL + 1U))) discard;\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    float timeInMode = iTime - gameInfo.z;\n    \n    float previousGameMode = gameInfo.x;\n    \n    gBomberman0 = LoadBomberman(txBomberman0Info);\n    gBomberman1 = LoadBomberman(txBomberman1Info);\n    gBomberman2 = LoadBomberman(txBomberman2Info);\n    gBomberman3 = LoadBomberman(txBomberman3Info);\n     \n    vec4 tileInfo = LoadValueBufferA(fragCoord.xy - 0.5);\n    vec2 tileIndex = floor(vec2(fragCoord.x, fragCoord.y - 1.0));\n           \n    if (gameInfo.x == MODE_MATCH_RESET)\n    { \n        tileInfo = ResetTile(tileIndex);\n        \n        gBomberman0 = CreateDefaultBomberman(vec2(0.0), DIRECTION_UP);\n        gBomberman1 = CreateDefaultBomberman(vec2(float(CELLS_WIDE - 1U), float(CELLS_TALL - 1U)), DIRECTION_DOWN);\n        gBomberman2 = CreateDefaultBomberman(vec2(0.0, float(CELLS_TALL - 1U)), DIRECTION_DOWN);\n        gBomberman3 = CreateDefaultBomberman(vec2(float(CELLS_WIDE - 1U), 0.0), DIRECTION_UP);\n                \n        gameInfo.x = MODE_GAMEPLAY;\n    }\n    else if (gameInfo.x == MODE_GAMEPLAY)\n    {              \n        uint aliveCount = 0U;\n                \n        if (IsBombermanAlive(gBomberman0.mPosition.x))\n        {\n            aliveCount += 1U;           \n            bool isBombermanTile = (floor(gBomberman0.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman0Inputs = LoadInputs(txBomberman0Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman0.mFlameLevel, gBomberman0Inputs.mPlaceBomb, (gBomberman0.mCurrentBombCount < gBomberman0.mBombLevel));\n            }\n            UpdateBomberman(gBomberman0, tileInfo, gBomberman0Inputs);\n        }\n         \n        if (IsBombermanAlive(gBomberman1.mPosition.x))\n        {\n            aliveCount += 1U;   \n            bool isBombermanTile = (floor(gBomberman1.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman1Inputs = LoadInputs(txBomberman1Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman1.mFlameLevel, gBomberman1Inputs.mPlaceBomb, (gBomberman1.mCurrentBombCount < gBomberman1.mBombLevel));\n            }\n            UpdateBomberman(gBomberman1, tileInfo, gBomberman1Inputs);\n        }\n        \n        if (IsBombermanAlive(gBomberman2.mPosition.x))\n        {\n            aliveCount += 1U;   \n            bool isBombermanTile = (floor(gBomberman2.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman2Inputs = LoadInputs(txBomberman2Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman2.mFlameLevel, gBomberman2Inputs.mPlaceBomb, (gBomberman2.mCurrentBombCount < gBomberman2.mBombLevel));\n            }\n            UpdateBomberman(gBomberman2, tileInfo, gBomberman2Inputs);\n        }\n        \n        if (IsBombermanAlive(gBomberman3.mPosition.x))\n        {\n            aliveCount += 1U;    \n            bool isBombermanTile = (floor(gBomberman3.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman3Inputs = LoadInputs(txBomberman3Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman3.mFlameLevel, gBomberman3Inputs.mPlaceBomb, (gBomberman3.mCurrentBombCount < gBomberman3.mBombLevel));\n            }\n            UpdateBomberman(gBomberman3, tileInfo, gBomberman3Inputs);\n        }\n        \n        // End the match if only one player remains\n        gameInfo.x = (aliveCount <= 1U) ? MODE_MATCH_OVER : gameInfo.x;\n        \n        int currentTileType = int(tileInfo.x);\n        \n        if (currentTileType != UNBREAKABLE_BLOCK)\n        {\n            // Update Tiles\n            vec4 leftTileInfo  = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(-1.0, 0.0));\n            vec4 rightTileInfo = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(1.0, 0.0));\n            vec4 upTileInfo    = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(0.0, -1.0));\n            vec4 downTileInfo  = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(0.0, 1.0));     \n            \n            bool isBreakableBlock = (currentTileType == BREAKABLE_BLOCK);\n            bool isExplosion = (currentTileType == EXPLOSION) || (currentTileType == COLLAPSING_BLOCK);\n            bool isCollapsingBlock = (currentTileType == COLLAPSING_BLOCK);\n            bool isBomb = (currentTileType == BOMB);\n\n            float previousExplosionType = 0.0;\n            if (isExplosion || isCollapsingBlock)\n        \t{\n                if (tileInfo.y <= 0.0)\n                {\n                \ttileInfo.x = (currentTileType == COLLAPSING_BLOCK) ? GetRandomPowerup(tileIndex) : float(FREE_SPACE);\n                    tileInfo.z = 0.0;\n                }\n                previousExplosionType = tileInfo.z;\n                tileInfo.w = 0.0;\n        \t}\n            \n\t\t\tif (isCollapsingBlock == false)\n            {\n                UpdateTile(tileInfo, leftTileInfo, EXPLOSION_DIRECTION_RIGHT, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, rightTileInfo, EXPLOSION_DIRECTION_LEFT, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, upTileInfo, EXPLOSION_DIRECTION_DOWN, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, downTileInfo, EXPLOSION_DIRECTION_UP, isBomb, isBreakableBlock);\n            }\n\n            // Update bomb, flame and collapsing block timers\n            if ((isExplosion || isCollapsingBlock || isBomb) && (tileInfo.y > 0.0))\n            {\n                tileInfo.y -= iTimeDelta;\n                if (isBomb && (tileInfo.y <= 0.0))\n                {\n                    tileInfo.x = float(EXPLOSION);\n                    tileInfo.y = BOMB_EXPLOSION_TIME;\n                }\n            }\n        }    \n    }\n    else if (gameInfo.x == MODE_MATCH_OVER)\n    {\n        gameInfo.x = (timeInMode > 3.0) ? MODE_AWARD : gameInfo.x;\n    }\n    else if (gameInfo.x == MODE_AWARD)\n    {\n        gameInfo.x = (timeInMode > 10.0) ? MODE_MATCH_RESET : gameInfo.x;\n    }\n    gameInfo.z = (previousGameMode != gameInfo.x) ? iTime : gameInfo.z;\n    \n    // Store game state\n    fragColor = vec4(0.0);\n \n    StoreValue(txGameInfo, gameInfo, fragColor, fragCoord);\n    StoreValue(txPlayField, tileInfo, fragColor, fragCoord);\n     \n    StoreBomberman(txBomberman0Info, gBomberman0, fragColor, fragCoord);\n    StoreBomberman(txBomberman1Info, gBomberman1, fragColor, fragCoord);\n    StoreBomberman(txBomberman2Info, gBomberman2, fragColor, fragCoord);\n    StoreBomberman(txBomberman3Info, gBomberman3, fragColor, fragCoord);\t\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 2,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Keyboard Input\nvec4 LoadValueBufferB(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\n////////////////////////////////////////////////////////\n// Controls\nstruct ControlSet\n{\n    float mLeftKey;\n\tfloat mUpKey;\n    float mRightKey;\n    float mDownKey;\n    float mBombKey;\n};\n\n#define CalculateKeyCode(x) ((float(x) + 0.5) / 256.0)\n\n// Player 0\nconst float KEY_LEFT  = CalculateKeyCode(37);\nconst float KEY_UP    = CalculateKeyCode(38);\nconst float KEY_RIGHT = CalculateKeyCode(39);\nconst float KEY_DOWN  = CalculateKeyCode(40);\nconst float KEY_SPACE = CalculateKeyCode(32);\nControlSet gControlSet0 = ControlSet(KEY_LEFT, KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_SPACE);\n\n// Player 1\nconst float KEY_A     = CalculateKeyCode(65);\nconst float KEY_W     = CalculateKeyCode(87);\nconst float KEY_D     = CalculateKeyCode(68);\nconst float KEY_S     = CalculateKeyCode(83);\nconst float KEY_Q     = CalculateKeyCode(81);\nControlSet gControlSet1 = ControlSet(KEY_A, KEY_W, KEY_D, KEY_S, KEY_Q);\n\n// Player 2\nconst float KEY_J     = CalculateKeyCode(74);\nconst float KEY_I     = CalculateKeyCode(73);\nconst float KEY_K     = CalculateKeyCode(76);\nconst float KEY_L     = CalculateKeyCode(75);\nconst float KEY_U     = CalculateKeyCode(85);\nControlSet gControlSet2 = ControlSet(KEY_J, KEY_I, KEY_K, KEY_L, KEY_U);\n\n// Player 3\nconst float KEY_V     = CalculateKeyCode(86);\nconst float KEY_G     = CalculateKeyCode(71);\nconst float KEY_N     = CalculateKeyCode(78);\nconst float KEY_B     = CalculateKeyCode(66);\nconst float KEY_F     = CalculateKeyCode(70);\nControlSet gControlSet3 = ControlSet(KEY_V, KEY_G, KEY_N, KEY_B, KEY_F);\n    \nbool CheckKey(in float key)\n{\n\treturn texture(iChannel2, vec2(key, 0.25)).x > 0.5;   \n}\n\nvec4 CheckKeyboardInput(in ControlSet controlSet, in float lastBombTime)\n{\n    vec4 results = vec4(0.0, 0.0, 0.0, (abs(iTime - lastBombTime) > 0.25) ? 0.0 : lastBombTime);\n    \n    results.x -= CheckKey(controlSet.mLeftKey) ? 1.0 : 0.0;\n    results.x += CheckKey(controlSet.mRightKey) ? 1.0 : 0.0;\n    results.y -= CheckKey(controlSet.mDownKey) ? 1.0 : 0.0;\n    results.y += CheckKey(controlSet.mUpKey) ? 1.0 : 0.0;\n       \n    // Last bomb time is used to determine the bomb key was released before another bomb can be placed\n    if (CheckKey(controlSet.mBombKey)) \n    { \n        if (lastBombTime == 0.0)\n        {\n            results.z += 1.0; \n            results.w = iTime;\n        }\n    }\n    return results;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    fragColor = vec4(0.0);\n    \n    float playerToUpdate = mod(float(iFrame), 4.0);\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    \n    float bomberman0TimeSinceBomb = LoadValueBufferB(txBomberman0Command).w;\n    float bomberman1TimeSinceBomb = LoadValueBufferB(txBomberman1Command).w;\n    float bomberman2TimeSinceBomb = LoadValueBufferB(txBomberman2Command).w;\n    float bomberman3TimeSinceBomb = LoadValueBufferB(txBomberman3Command).w;       \n\n    vec4 bomberman0Inputs = CheckKeyboardInput(gControlSet0, bomberman0TimeSinceBomb);\n    vec4 bomberman1Inputs = CheckKeyboardInput(gControlSet1, bomberman1TimeSinceBomb);\n    vec4 bomberman2Inputs = CheckKeyboardInput(gControlSet2, bomberman2TimeSinceBomb);\n    vec4 bomberman3Inputs = CheckKeyboardInput(gControlSet3, bomberman3TimeSinceBomb);\n\n    StoreValue(txBomberman0Command, bomberman0Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman1Command, bomberman1Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman2Command, bomberman2Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman3Command, bomberman3Inputs, fragColor, fragCoord);\t\t  \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Game Display Buffer\n\n//////////////////////////////////////////////////\n// Debugging Settings\n#define     SHOW_ALBEDO             \t0\n#define     SHOW_NORMALS            \t0\n#define     SHOW_LIGHTING               0\n\n//////////////////////////////////////////////////\n// Settings\n#define ULTRA_QUALITY       4\n#define HIGH_QUALITY\t    3\t\t\n#define MEDIUM_QUALITY\t\t2\n#define LOW_QUALITY\t\t    1\n\n#define QUALITY_MODE \t\tULTRA_QUALITY\n\n//////////////////////////////////////////////////\n// Advanced Settings\n#define     NUMBER_OF_STEPS         30\n\n#if (QUALITY_MODE >= ULTRA_QUALITY) \n#define \tGRASS_NOISE\t\t\t\t1\n#else\n#define \tGRASS_NOISE\t\t\t\t0\n#endif\n\n//////////////////////////////////////////////////\n// Common Globals\nvec3 gCloseIntersection;\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 30.0; // VR needs 20\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n// Scene\nconst int EDGE_BLOCK\t\t\t= 20;\nconst int GROUND\t\t\t\t= 30;\n\n// Bomberman Material Indexes\nconst int BOMBERMAN_WHITE\t\t= 100;\nconst int BOMBERMAN_BLACK\t\t= 101;\nconst int BOMBERMAN_RED\t\t\t= 102;\nconst int BOMBERMAN_BLUE\t\t= 103;\nconst int BOMBERMAN_PINK\t\t= 104;\nconst int BOMBERMAN_SKIN\t\t= 105;\nconst int BOMBERMAN_GOLD\t\t= 106;\n\nstruct BombermanColorSet\n{\n    int \tmPrimaryColor;\n    int \tmSecondaryColor;\n    int \tmBodyColor;\n};\nconst BombermanColorSet gColorSet0 = BombermanColorSet(BOMBERMAN_WHITE, BOMBERMAN_PINK, BOMBERMAN_BLUE);\nconst BombermanColorSet gColorSet1 = BombermanColorSet(BOMBERMAN_BLACK, BOMBERMAN_PINK, BOMBERMAN_BLACK);\nconst BombermanColorSet gColorSet2 = BombermanColorSet(BOMBERMAN_RED, BOMBERMAN_PINK, BOMBERMAN_RED);\nconst BombermanColorSet gColorSet3 = BombermanColorSet(BOMBERMAN_BLUE, BOMBERMAN_PINK, BOMBERMAN_BLUE);\n            \n// Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nstruct Bomberman\n{\n\tvec2 \tmPosition;\n    float   mDirection;\n    float   mAnimation;\n};\n    \nBomberman LoadBomberman(in vec2 re)\n{\n    vec4 bombermanInfo = LoadValueBufferA(re);  \n    return Bomberman(bombermanInfo.xy, bombermanInfo.z, bombermanInfo.w);\n}\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    vec2\t\tmStartingTileIndex;\n    vec2\t\tmEndingTileIndex;\n    float       mT;\n    int\t\t    mMaterialIndex;\n};  \n\n#define CreateIntersectionData(x, y)    \tIntersectionData(vec2(-1.0), vec2(-1.0), x, y)\n#define InvalidIntersectionData    \t\t\tIntersectionData(vec2(-1.0), vec2(-1.0), MAX_DISTANCE, -1)\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if (a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\nstruct AABB\n{\n\tvec3 mMin;\n    vec3 mMax;\n};\n           \n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfBox(in vec3 p, in vec3 boxSize)\n{\n\tvec3 d = abs(p) - boxSize;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfCylinder(in vec3 p, in vec3 cylinderDimensions)\n{\n\treturn length(p.xz - cylinderDimensions.xy) - cylinderDimensions.z;\n}\n\nfloat sdfSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdfCapsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\nfloat udfRoundedBox(in vec3 p, in vec3 boxSize, in float radius)\n{\n\treturn length(max(abs(p) - boxSize, 0.0)) - radius;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin(in float a, in float b, in float k)\n{\n    float h = Saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opBlend(in float a, in float b)\n{\n    return smin(a, b, 0.005);\n}\n\n//////////////////////////////////////////////////////\n// Noise\nfloat Hash(in vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(i), Hash(i + vec2(1.0, 0.0)), u.x), mix(Hash(i + vec2(0.0, 1.0)), Hash(i + vec2(1.0)), u.x), u.y);   \n}\n\nfloat FractalBrownianMotion(in vec2 p)\n{\n   float f \n     = Noise(p) * 16.0\n   \t + Noise(p * 2.0) * 8.0\n     + Noise(p * 4.0) * 4.0\n     + Noise(p * 8.0) * 2.0\n     + Noise(p * 16.0);\n    \n    return f / (1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0);\n}\n\nbool AABBIntersection(in Ray ray, in AABB aabb, out float tMin, out float tMax)\n{\n    for(int i = 0; i < 3; i++)\n    {\n        float inverseDirection = 1.0 / ray.mDirection[i];\n        float t0 = (aabb.mMin[i] - ray.mPosition[i]) * inverseDirection;\n        float t1 = (aabb.mMax[i] - ray.mPosition[i]) * inverseDirection;\n        \n        if (inverseDirection < 0.0)\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        \n        tMin = max(t0, tMin);\n        tMax = min(t1, tMax);\n        \n        if (tMax <= tMin)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Scene\nconst vec3 k_playFieldHalfSize = vec3(0.75, 0.035, 0.5);\nconst vec3 k_playFieldOffset = vec3(0.0, 0.1, 0.0);\nconst AABB k_playField = AABB(-k_playFieldHalfSize + k_playFieldOffset, k_playFieldHalfSize + k_playFieldOffset);\nconst vec3 k_playFieldSize = abs(k_playField.mMax - k_playField.mMin);\n\n// Ground\nconst vec3 k_groundHalfSize = vec3(0.5 * k_playFieldSize.x, 0.25 * k_playFieldSize.y, 0.5 * k_playFieldSize.z);\nconst vec3 k_groundCenter = k_playField.mMin + k_groundHalfSize;\n\n// Blocks\nconst vec3 k_tileSize = vec3(k_playFieldSize.x / (float(CELLS_WIDE) + 2.0), k_playFieldSize.y * 0.375, k_playFieldSize.z / (float(CELLS_TALL) + 2.0));\nconst vec3 k_tileHalfSize = k_tileSize * 0.5;\nconst vec3 k_edgeBlockHalfSize = vec3(k_tileHalfSize.x, k_playFieldSize.y, k_tileHalfSize.z);\n\n// Power Ups\nconst vec3 k_powerUpSize = vec3(k_tileHalfSize.z * 0.65, k_tileHalfSize.y * 0.5, k_tileHalfSize.z * 0.65);\n\nvec3 GetTileCenter(in vec2 tileIndex)\n{\n    vec2 offsetTileIndex = floor(tileIndex + vec2(1.0));\n \n    return vec3(k_playField.mMin.x + k_tileHalfSize.x + offsetTileIndex.x * k_tileSize.x,\n\t\t\t\tk_groundCenter.y + k_groundHalfSize.y + k_tileHalfSize.y,\n    \t\t\tk_playField.mMin.z + k_tileHalfSize.z + offsetTileIndex.y * k_tileSize.z);\n}\n\nvec3 GetBombermanPosition(in vec2 position)\n{    \n    vec2 bomberman2DPosition = k_playField.mMin.xz + k_tileHalfSize.xz + (position.xy + 1.0) * k_tileSize.xz;\n    return vec3(bomberman2DPosition.x, (k_groundCenter.y + k_groundHalfSize.y) + k_tileHalfSize.y, bomberman2DPosition.y);\n}\n\nvec3 GetBombermanForward(in float direction)\n{\n    const vec3[] k_bombermanForward = vec3[](vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec3(1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0)); \n    return k_bombermanForward[uint(direction)];\n}\n\nvec3 GetBombermanRight(in float direction)\n{\n    const vec3[] k_bombermanRight = vec3[](vec3(1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0)); \n    return k_bombermanRight[uint(direction)];\n}\n\nIntersectionData CheckBomberman(in Bomberman bomberman, in vec3 position, in vec2 tileIndex, in BombermanColorSet colorSet)\n{\n    IntersectionData primaryIntersection = InvalidIntersectionData;\n    vec2 bombermanTileIndex = GetTileIndex(ConvertTileCoordsToScreenUV(bomberman.mPosition.xy)); \n    vec2 tileDistance = abs(tileIndex - bombermanTileIndex);\n    \n    if ((tileDistance.x <= 1.0) && (tileDistance.y <= 1.0))\n    {\n    \tvec3 bombermanPosition = GetBombermanPosition(bomberman.mPosition) + vec3(k_tileHalfSize.x * 0.125, 0.0, k_tileHalfSize.z * 0.25); \n        vec3 bombermanForward = GetBombermanForward(bomberman.mDirection);\n        vec3 bombermanRight = GetBombermanRight(bomberman.mDirection);\n\n        vec3 offsetPosition = bombermanPosition - position;\n\n#if QUALITY_MODE >= MEDIUM_QUALITY   \n        float headT = sdfSphere(offsetPosition + vec3(0.0, 0.05, 0.0), k_tileHalfSize.z * 0.65);\n        primaryIntersection.mT = headT;\n        primaryIntersection.mMaterialIndex = colorSet.mPrimaryColor;\n\n        // Body\n        IntersectionData bodyIntersection;\n        bodyIntersection.mT = min(primaryIntersection.mT, sdfCapsule(position, bombermanPosition + vec3(0.0, 0.04, 0.0), bombermanPosition + vec3(0.0, 0.03, 0.0), k_tileHalfSize.z * 0.45));\n        bodyIntersection.mMaterialIndex = colorSet.mBodyColor;\n\t\tprimaryIntersection = GetClosestIntersection(bodyIntersection, primaryIntersection);\n        \n        IntersectionData pinkIntersection;\n        pinkIntersection.mMaterialIndex = colorSet.mSecondaryColor;  \n        pinkIntersection.mT = sdfSphere((offsetPosition - (bombermanForward * 0.012) + vec3(0.0, 0.07, 0.0)), k_tileHalfSize.z * 0.3);    \n\n        // Hands\n        vec3 handHeightOffset = vec3(0.0, 0.015, 0.0);\n        float handRotation = bomberman.mAnimation / 20.0 * PI;\n        vec3 handForwardOffset = sin(handRotation) * bombermanForward * 0.01;\n        \n        pinkIntersection.mT = min(pinkIntersection.mT, sdfSphere((offsetPosition - (bombermanRight * 0.02) + handHeightOffset + handForwardOffset), k_tileHalfSize.z * 0.25));\n        pinkIntersection.mT = min(pinkIntersection.mT, sdfSphere((offsetPosition - (bombermanRight * -0.02) + handHeightOffset - handForwardOffset), k_tileHalfSize.z * 0.25));     \n        primaryIntersection = GetClosestIntersection(pinkIntersection, primaryIntersection);\n\n        // Face\n        IntersectionData skinIntersection;\n        vec3 bombermanSkinBoxSize = vec3(k_tileHalfSize.x * 0.3, k_tileHalfSize.y * 0.3, k_tileHalfSize.x * 0.3) * (vec3(1.0) - (0.70 * abs(bombermanForward)));\n        skinIntersection.mT = udfRoundedBox(offsetPosition + vec3(0.0, 0.05, 0.0) + (bombermanForward * 0.0125), bombermanSkinBoxSize, 0.001);\n\n        skinIntersection.mT = opBlend(skinIntersection.mT, headT);\n        skinIntersection.mMaterialIndex = BOMBERMAN_SKIN;  \n        primaryIntersection = GetClosestIntersection(skinIntersection, primaryIntersection);\n\n        // Eyes\n        const float k_eyeRadius = 0.006;\n        const float k_eyeForward = 0.015;\n        const float k_eyeSpacing = 0.0075;\n\n        IntersectionData eyeIntersection;\n        eyeIntersection.mMaterialIndex = BOMBERMAN_BLACK;\n        vec3 eyeTop = bombermanPosition + vec3(0.0, 0.052, 0.0) + (bombermanForward * k_eyeForward);\n        vec3 eyeBottom = bombermanPosition + vec3(0.0, 0.0485, 0.0) + (bombermanForward * k_eyeForward);\n\n        eyeIntersection.mT = sdfCapsule(position, eyeBottom + (bombermanRight * k_eyeSpacing), eyeTop + (bombermanRight * k_eyeSpacing), k_eyeRadius);\n        eyeIntersection.mT = min(eyeIntersection.mT, sdfCapsule(position, eyeBottom + (bombermanRight * -k_eyeSpacing), eyeTop + (bombermanRight * -k_eyeSpacing), k_eyeRadius));\n        primaryIntersection = GetClosestIntersection(eyeIntersection, primaryIntersection);\n\n#elif QUALITY_MODE >= LOW_QUALITY      \n        primaryIntersection.mT = sdfSphere(bombermanPosition - position, gTileHalfSize.z);\n        primaryIntersection.mMaterialIndex = colorSet.mPrimaryColor;\n\n        IntersectionData pinkIntersection;\n        pinkIntersection.mT = sdfSphere((bombermanPosition - (bombermanForward * 0.02) + vec3(0.0, 0.03, 0.0)) - position, gTileHalfSize.z * 0.3);\n        pinkIntersection.mMaterialIndex = colorSet.mSeconadryColor;  \n\n        primaryIntersection = GetClosestIntersection(pinkIntersection, primaryIntersection);\n#endif // QUALITY_MODE >= LOW_QUALITY \n    }\n    return primaryIntersection;\n}\n\nIntersectionData CheckBombermen(in vec3 position, in vec2 tileIndex)\n{ \n\tBomberman bomberman0 = LoadBomberman(txBomberman0Info);\n    Bomberman bomberman1 = LoadBomberman(txBomberman1Info);\n    Bomberman bomberman2 = LoadBomberman(txBomberman2Info);\n    Bomberman bomberman3 = LoadBomberman(txBomberman3Info);\n     \n    IntersectionData bombermanIntersection = GetClosestIntersection(\n           GetClosestIntersection(CheckBomberman(bomberman0, position, tileIndex, gColorSet0), CheckBomberman(bomberman1, position, tileIndex, gColorSet1)),                                                                 \n           GetClosestIntersection(CheckBomberman(bomberman2, position, tileIndex, gColorSet2), CheckBomberman(bomberman3, position, tileIndex, gColorSet3)));\n\n    bombermanIntersection.mStartingTileIndex = tileIndex;\n    bombermanIntersection.mEndingTileIndex = tileIndex;  \n    \n    return bombermanIntersection;\n}\n\nIntersectionData CheckTileIntersection(in vec3 position, in vec2 tileIndex)\n{\n    IntersectionData tileIntersection = InvalidIntersectionData;\n    \n    vec3 tileCenter = GetTileCenter(tileIndex);\n            \n    if ((tileIndex.x >= 0.0) && (tileIndex.y >= 0.0) && (tileIndex.x < float(CELLS_WIDE)) && (tileIndex.y < float(CELLS_TALL)))\n    {\n        vec4 tileInfo = LoadValueBufferA(txPlayField.xy + tileIndex);   \n\t\tint tileType = int(tileInfo.x);\n        \n        if ((tileType == BREAKABLE_BLOCK) || (tileType == UNBREAKABLE_BLOCK) || (tileType == COLLAPSING_BLOCK))\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_tileHalfSize);\n            tileIntersection.mMaterialIndex = int(tileInfo.x);\n        }\n        else if (tileType == EXPLOSION)\n        {\n            tileIntersection.mMaterialIndex = EXPLOSION;\n\n            const vec3 k_horizontalExplosionOffset = vec3(k_tileHalfSize.x, 0.0, 0.0);\n            const vec3 k_verticalExplosionOffset = vec3(0.0, 0.0, k_tileHalfSize.z);\n            float explosionRadius = k_tileHalfSize.z * 0.9 * Saturate(tileInfo.y * 10.0);\n\n            vec3 explosionCenter = vec3(tileCenter.x, k_playField.mMin.y + k_tileHalfSize.z * 0.9, tileCenter.z);\n\n            uint explosionFlags = uint(tileInfo.z);\n            if ((explosionFlags & EXPLOSION_DIRECTION_LEFT) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter, explosionCenter + k_horizontalExplosionOffset * 2.0, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_RIGHT) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter - k_horizontalExplosionOffset * 2.0, explosionCenter, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_UP) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter, explosionCenter + k_verticalExplosionOffset * 2.0, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_DOWN) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter - k_verticalExplosionOffset * 2.0, explosionCenter, explosionRadius));\n            }\n        }\n        else if (tileType == BOMB)\n        {\n            float radiusMix = (sin(tileInfo.y * 10.0) + 1.0) * 0.5;\n            float bombRadius = mix(k_tileHalfSize.z * 0.9, k_tileHalfSize.z * 1.05, radiusMix);\n            \n            tileIntersection.mT = sdfSphere(tileCenter - position, bombRadius);\n            tileIntersection.mMaterialIndex = BOMBERMAN_BLACK;        \n        }\n        else if ((tileType == BOMB_POWER_UP) || (tileType == FLAME_POWER_UP) || (tileType == SKATE_POWER_UP))\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_powerUpSize);\n            tileIntersection.mMaterialIndex = tileType;\n        }         \n    }\n    else\n    {\n        bool xEdge = (tileIndex.x == -1.0) || (tileIndex.x == float(CELLS_WIDE));\n        bool yEdge = (tileIndex.y == -1.0) || (tileIndex.y == float(CELLS_TALL));\n            \n        if (xEdge || yEdge)\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_edgeBlockHalfSize);\n        \ttileIntersection.mMaterialIndex = EDGE_BLOCK;\n        }\n    }   \n    return tileIntersection;\n}\n\nIntersectionData CheckSceneForIntersection(in vec3 position, in vec2 startingTileIndex, in vec2 endingTileIndex)\n{\n#if GRASS_NOISE\n    vec3 grassOffset = vec3(0.0, Noise((position.xz + vec2(2.0)) * iResolution.y * 0.5) * 0.0075, 0.0);\n    IntersectionData sceneIntersection = CreateIntersectionData(sdfBox(k_groundCenter - position, k_groundHalfSize + grassOffset), GROUND);\n#else\n    IntersectionData sceneIntersection = CreateIntersectionData(sdfBox(k_groundCenter - position, k_groundHalfSize), GROUND);\n#endif // GRASS_NOISE\n       \n    IntersectionData bombermanIntersection = CheckBombermen(position, startingTileIndex);\n    sceneIntersection = GetClosestIntersection(sceneIntersection, bombermanIntersection);      \n\n    // Starting tile collision\n    IntersectionData tileIntersection = CheckTileIntersection(position, startingTileIndex);\n    sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    \n    bool checkX = (abs(endingTileIndex.x - startingTileIndex.x) > 0.01);\n\tbool checkY = (abs(endingTileIndex.y - startingTileIndex.y) > 0.01);           \n    \n    if (checkX)\n    {\n        tileIntersection = CheckTileIntersection(position, vec2(endingTileIndex.x, startingTileIndex.y));\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    if (checkY)\n    {\n        tileIntersection = CheckTileIntersection(position, vec2(startingTileIndex.x, endingTileIndex.y));\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    if (checkX && checkY)\n    {\n        tileIntersection = CheckTileIntersection(position, endingTileIndex.xy);\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    // Adjacent tiles, doing some duplicate work here :(\n    const int k_adjacentTilesToCheck = 1;\n     \n    for (int x = -k_adjacentTilesToCheck; x <= k_adjacentTilesToCheck; ++x)\n    {\n        for (int y = -k_adjacentTilesToCheck; y <= k_adjacentTilesToCheck; ++y)\n        {                     \n            vec2 currentTileIndex = (startingTileIndex + vec2(x, y));    \n            if (currentTileIndex != startingTileIndex)\n            {\n\t\t\t\ttileIntersection = CheckTileIntersection(position, currentTileIndex);\n            \tsceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n            }\n    \t}\n    }\n    \n    return sceneIntersection;\n}\n\nvec2 CalculateTileUV(in vec2 point)\n{\n    return (point - k_playField.mMin.xz) / k_playFieldSize.xz;\n}\n\nvec2 CalculateTileIndex(in vec3 intersectionPoint)\n{\n    vec2 tileUV = CalculateTileUV(intersectionPoint.xz);    \n    return GetTileIndex(tileUV);\n}\n\nIntersectionData CheckSceneForIntersection(in Ray ray)\n{\n    IntersectionData sceneIntersection = InvalidIntersectionData;\n    vec2 closeTileIndex = vec2(-1.0);  \n    vec2 farTileIndex = vec2(-1.0);\n    \n    float tMin = -100.0;\n    float tMax = 100.0;\n    \n    if (AABBIntersection(ray, k_playField, tMin, tMax))\n    { \n        gCloseIntersection = ray.mPosition + (tMin * ray.mDirection);\n        vec2 closeTileUV = CalculateTileUV(gCloseIntersection.xz); \n        closeTileIndex = GetTileIndex(closeTileUV);\n        \n        vec3 farIntersection = ray.mPosition + (tMax * ray.mDirection);\n        vec2 farTileUV = CalculateTileUV(farIntersection.xz); \n        farTileIndex = GetTileIndex(farTileUV);\n             \n        sceneIntersection = CheckSceneForIntersection(ray.mPosition, closeTileIndex, farTileIndex);\n    }\n    sceneIntersection.mStartingTileIndex = closeTileIndex;\n    sceneIntersection.mEndingTileIndex = farTileIndex;\n    \n    return sceneIntersection;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = InvalidIntersectionData;\n    \n    float t = 0.0;   \n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection);    \n        sceneIntersection = CheckSceneForIntersection(currentRay);    \n        t += sceneIntersection.mT; // Step forward\n    }    \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 position, in vec2 startingTileIndex, in vec2 endingTileIndex, in float d0T) \n{\n    IntersectionData d0 = CheckSceneForIntersection(position, startingTileIndex, endingTileIndex);\n    IntersectionData dX = CheckSceneForIntersection(position - vec3(EPSILON, 0.0, 0.0), startingTileIndex, endingTileIndex);\n    IntersectionData dY = CheckSceneForIntersection(position - vec3(0.0, EPSILON, 0.0), startingTileIndex, endingTileIndex);\n    IntersectionData dZ = CheckSceneForIntersection(position - vec3(0.0, 0.0, EPSILON), startingTileIndex, endingTileIndex);\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n    return fract(sin(p * mat2(12.98, 78.23, 127.99, 311.33)) * 43758.54);\n}\n\nvec3 WorleyNoise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 n = fract(uv);\n    vec3 minD = vec3(9.0);\n    \n    for (float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 point = sin(32.0 * Hash2D(i + vec2(x, y))) * 0.5 + 0.5;\n            float d = length(vec2(x, y) + point - n);\n            \n            minD = (d < minD.x) ? vec3(d, minD.xy) \n               \t : (d < minD.y) ? vec3(minD.x, d, minD.y) \n               \t : (d < minD.z) ? vec3(minD.xy, d) \n                 : minD;\n        }\n    }\n    return minD;\n}\n\nvec2 GetPowerUpUVs(in vec3 point, in vec3 normal, in int powerUp)\n{\n\tvec2 tileIndex = CalculateTileIndex(point); \n    vec3 tileCenter = GetTileCenter(tileIndex);\n    normal = abs(normal);\n    \n    vec2 sampleUV = vec2(0.0);\n    if (normal.y > 0.5)\n    {\n    \tsampleUV = (((point.xz - tileCenter.xz) / k_powerUpSize.xz) + vec2(1.0)) * 0.5;\n    }\n    else if (normal.x > 0.5)\n    {\n    \tsampleUV = (((point.yz - tileCenter.yz) / k_powerUpSize.yz) + vec2(1.0)) * 0.5;\n    }\n    else if (normal.z > 0.5)\n    {\n    \tsampleUV = (((point.xy - tileCenter.xy) / k_powerUpSize.xy) + vec2(1.0)) * 0.5;\n    }\n    sampleUV = sampleUV * (vec2(16.0) / iChannelResolution[1].xy) + (float(powerUp) * vec2(16.0, 0.0) / iChannelResolution[1].xy);\n   \n    return sampleUV;\n}\n\nvec3 GetDiffuseColor(in vec3 intersectionPoint, in vec3 normal, in int materialIndex)\n{\n    const vec3 bombermanColors[] = vec3[](vec3(1.0), vec3(0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.93, 0.51, 0.65), vec3(0.96, 0.9, 0.76));\n\n    vec3 diffuse = vec3(0.0);\n\t\t\n    if (materialIndex == BREAKABLE_BLOCK)\n    {\n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);   \n        vec3 noise = WorleyNoise((intersectionPoint.xz + tileIndex * 17.3) * 30.0);\n        float tint = (noise.z - noise.x);\n        \n        diffuse = mix(vec3(0.35, 0.25, 0.15), vec3(0.7, 0.5, 0.3), tint);\n#else\n        diffuse = vec3(0.8, 0.6, 0.4);        \n#endif \n    }\n    else if (materialIndex == UNBREAKABLE_BLOCK)\n    {\n        diffuse = vec3(0.20);\n #if QUALITY_MODE >= MEDIUM_QUALITY       \n    \tvec2 tileUV = CalculateTileUV(intersectionPoint.xz);   \n        vec2 t = fract(tileUV * vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0) - vec2(0.25));   \n        \n        if((t.x < 0.5) || (t.y < 0.5))\n        {\n            diffuse = vec3(0.35);\n        }\n#endif \n    }\n    else if (materialIndex == COLLAPSING_BLOCK)\n    {\n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);   \n        vec3 noise = WorleyNoise((intersectionPoint.xz + tileIndex * 17.3) * 30.0);\n        float tint = (noise.z - noise.x);\n        \n        diffuse = mix(vec3(0.35, 0.25, 0.15), vec3(1.0, 0.25, 0.0), tint);\n#else\n        diffuse = vec3(1.0, 0.25, 0.0);        \n#endif \n    }\n    else if (materialIndex == EXPLOSION)\n    {\n        float flameTint = Saturate(dot(normal, vec3(0.0, -1.0, 0.0)));\n        float flameTintSquared = flameTint * flameTint;\n        diffuse = mix(vec3(1.0, 0.25, 0.0), vec3(1.0, 0.6, 0.2), flameTintSquared * flameTintSquared);\n    }\n    else if (materialIndex == EDGE_BLOCK)\n    {\n        diffuse = vec3(0.5);\n    }\n    else if (materialIndex == GROUND)\n    {\n        diffuse = vec3(0.0, 0.5, 0.0); \n        \n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);\n        if (mod(tileIndex.x + tileIndex.y, 2.0) < 1.0)\n        {\n            diffuse = vec3(0.0, 0.425, 0.0);\n        }\n#endif\n    }\n    else if ((materialIndex >= BOMB_POWER_UP) && (materialIndex <= FLAME_POWER_UP))\n    {\n\t\tdiffuse = texture(iChannel1, GetPowerUpUVs(intersectionPoint, normal, materialIndex - BOMB_POWER_UP)).rgb;      \n#if QUALITY_MODE >= MEDIUM_QUALITY\n\t\tdiffuse = (diffuse.r >= 0.95) ? mix(diffuse, vec3(1.0, 1.0, 0.0), mod(iTime * 15.0, 2.0)) : diffuse;       \n#endif\n    }\n    else if ((materialIndex >= BOMBERMAN_WHITE) && (materialIndex <= BOMBERMAN_SKIN))\n    {\n        diffuse = bombermanColors[materialIndex - BOMBERMAN_WHITE];\n    }  \n    return diffuse;\n}\n\nfloat ApplyDirectionalLight(in vec3 point, in vec3 normal, in vec3 lightDirection, in vec2 startingTileIndex, in vec2 endingTileIndex, in float t)\n{\n    float nDotL = Saturate(dot(normal, lightDirection)); \n    // Eventually apply shadows here\n    return nDotL;\n}\n\nfloat CalculateLighting(in vec3 point, in vec3 normal, in vec2 startingTileIndex, in vec2 endingTileIndex, in float t)\n{\n    const vec3 lightDirection = normalize(vec3(0.5, -1.0, 0.5));\n    float lighting = ApplyDirectionalLight(point, normal, lightDirection, startingTileIndex, endingTileIndex, t);\n    \n    // Wrap lighting\n    const float k_wrapAmount = 0.5;\n    lighting = (lighting + k_wrapAmount) / (1.0 + k_wrapAmount);\n    \n    const float k_ambientLight = 0.3;\n    lighting = min(lighting + k_ambientLight, 1.0);\n\n    return lighting;\n}\n\nvec3 ThreeDimensionalDisplay(in vec3 cameraPosition, in vec3 cameraDirection)\n{\n    vec3 finalColor = vec3(0.0);\n  \n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint, intersection.mStartingTileIndex, intersection.mEndingTileIndex, intersection.mT); \n       \tvec3 diffuse = GetDiffuseColor(intersectionPoint, normal, intersection.mMaterialIndex);\n        \n        float lighting = CalculateLighting(intersectionPoint, normal, intersection.mStartingTileIndex, intersection.mEndingTileIndex, intersection.mT);\n#if SHOW_ALBEDO       \n    \tfinalColor = diffuse;  \n#elif SHOW_NORMALS\n        finalColor = normal * 0.5 + vec3(0.5);\n#elif SHOW_LIGHTING\n        finalColor = vec3(lighting);\n#else\n        finalColor = (diffuse * lighting);\n#endif // SHOW_NORMALS        \n    }\n    else\n    {\n#if QUALITY_MODE == ULTRA_QUALITY\n\t\tfinalColor = vec3(0.6, 0.6, 1.0) * (1.0 - FractalBrownianMotion(cameraDirection.xz));\n#else\n        finalColor = vec3(0.6, 0.6, 1.0);\n#endif\n    }  \n\treturn finalColor;\n}\n\n//////////////////////////////////////////////////\n// Font\n\nfloat DrawCharacter(inout vec2 p, in int c)\n{\n    float fC = float(c);\n    float color = 0.0;\n\tif (p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)\n    {\n        color = step(texture(iChannel2, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);\n    }\n    p.x -= 0.5;\n    return color;\n}\n\n#define DrawWhite(c, x) c += DrawCharacter(x, 87); c += DrawCharacter(x, 104); c += DrawCharacter(x, 105); c += DrawCharacter(x, 116); c += DrawCharacter(x, 101)\n#define DrawBlack(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 108); c += DrawCharacter(x, 97); c += DrawCharacter(x, 99); c += DrawCharacter(x, 107)\n#define DrawRed(c, x) c += DrawCharacter(x, 82); c += DrawCharacter(x, 101); c += DrawCharacter(x, 100);\n#define DrawBlue(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 108); c += DrawCharacter(x, 117); c += DrawCharacter(x, 101);\n#define DrawBomber(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 111); c += DrawCharacter(x, 109); c += DrawCharacter(x, 98); c += DrawCharacter(x, 101); c += DrawCharacter(x, 114)\n#define DrawWins(c, x) c += DrawCharacter(x, 87); c += DrawCharacter(x, 105); c += DrawCharacter(x, 110); c += DrawCharacter(x, 115)\n#define DrawDraw(c, x) c += DrawCharacter(x, 68); c += DrawCharacter(x, 114); c += DrawCharacter(x, 97); c += DrawCharacter(x, 119)\n\n//////////////////////////////////////////////////\n// Implementation \n\nvec3 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv, in vec2 textUVs)\n{\n    vec3 sceneColor = vec3(0.0);\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    \n    if ((gameInfo.x == MODE_GAMEPLAY) || (gameInfo.x == MODE_MATCH_OVER) || (gameInfo.x == MODE_AWARD))\n    {  \n    \tsceneColor = ThreeDimensionalDisplay(cameraPosition, cameraDirection);\n        \n        float characterMask = 0.0;\n\n        if (gameInfo.x == MODE_AWARD) // Win Screen\n        {\n            Bomberman bomberman0 = LoadBomberman(txBomberman0Info);\n            Bomberman bomberman1 = LoadBomberman(txBomberman1Info);\n            Bomberman bomberman2 = LoadBomberman(txBomberman2Info);\n            Bomberman bomberman3 = LoadBomberman(txBomberman3Info);\n        \n            const float k_textScale = 8.0;\n            const float k_spaceAmount = 0.5f;\n            \n            textUVs = textUVs * k_textScale + vec2(0.0, -3.25);\n            vec3 textColor = vec3(1.0);\n        \n            bool shouldBrighten = true;\n        \n            // Tint the screen the color of the winner\n            if (IsBombermanAlive(bomberman0.mPosition.x))\n            {   \n                textUVs.x -= 2.8;\n            \n                textColor = vec3(1.0, 1.0, 1.0);\n                DrawWhite(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n                \n                shouldBrighten = false;\n            }\n            else if (IsBombermanAlive(bomberman1.mPosition.x))\n            {\n                textUVs.x -= 3.0;\n            \n                textColor = vec3(0.0, 0.0, 0.0);\n                DrawBlack(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else if (IsBombermanAlive(bomberman2.mPosition.x))\n            {\n                textUVs.x -= 3.1;\n            \n                textColor = vec3(1.0, 0.0, 0.0);\n                DrawRed(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else if (IsBombermanAlive(bomberman3.mPosition.x))\n            {\n                textUVs.x -= 3.0;\n            \n                textColor = vec3(0.0, 0.0, 1.0);\n                DrawBlue(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else\n            {\n                textUVs.x -= 5.8;            \n                DrawDraw(characterMask, textUVs);\n                shouldBrighten = false;\n            }\n            \n            // Darken or brighten the screen for easier text reading\n            sceneColor = shouldBrighten ? mix(sceneColor, vec3(1.0), 0.7) : (sceneColor * 0.7);\n            sceneColor = mix(sceneColor, textColor, characterMask);\n        }    \n    }\n    return sceneColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 adjustedUVs = vec2((uv.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), uv.y * 2.0 - 1.0) * 0.75; \n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float zRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x - 0.5) * (PI * 0.5) : 0.0; // Multiply by 0.1 to slow down the rotation \n    mat3 zRotationMatrix = Create3x3RotationMatrix(vec3(0.0, 0.0, -1.0), zRotationValue);\n           \n    const float k_distanceFromOrigin = 0.75;\n    vec3 cameraPosition = vec3(k_distanceFromOrigin * sin(zRotationValue) * cos(xRotationValue), k_distanceFromOrigin * cos(zRotationValue) * cos(xRotationValue), k_distanceFromOrigin * sin(xRotationValue));\n    vec3 cameraDirection = normalize(zRotationMatrix * xRotationMatrix * vec3(adjustedUVs.x, -1.0, adjustedUVs.y));\n   \n    // We use yy to account for the aspect ratio  \n    vec2 textUVs = (fragCoord.xy / iResolution.yy);\n   \n    vec3 finalColor = DisplayScene(cameraPosition, cameraDirection, uv, textUVs);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Sprite Sheet\n// References: [SH16C] Contra by knarkowicz - https://www.shadertoy.com/view/XltGDr\n\n#define RGB(r, g, b) vec3(float(r), float(g), float(b)) / 255.0\n\n// Each powerup sprite is 16x16\n\nconst vec2 k_powerUpSize = vec2(16.0);\nconst vec4 k_bombPowerUp = vec4(0.0, 0.0, k_powerUpSize.xy);\nconst vec4 k_skatePowerUp = vec4(k_powerUpSize.x, 0.0, 2.0 * k_powerUpSize.x, k_powerUpSize.y);\nconst vec4 k_flamePowerUp = vec4(2.0 * k_powerUpSize.x, 0.0, 3.0 * k_powerUpSize.x, k_powerUpSize.y);\n\nbool IsWithinDimensions(in vec2 fragCoord, in vec4 area)\n{\n    if ((fragCoord.x >= area.x) && (fragCoord.y >= area.y) && (fragCoord.x < area.z) && (fragCoord.y < area.w))\n    {\n        return true;\n    }\n    return false;\n}\n\nvec3 DisplayBombPowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_bombPowerUp.x);\n    float y = floor(fragCoord.y - k_bombPowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n\n   \tconst vec3 k_backGreen = RGB(51, 148, 82);\n\tconst vec3 k_bombBlack = RGB(33, 38, 30);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    \n    spriteColor = (y == 14.0) ? ((x >= 5.0 && x <= 10.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 13.0) ? ((x >= 3.0 && x <= 11.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : (x == 13.0 ? RGB(209, 60, 30) : (x == 12.0 ? RGB(255, 255, 255) : k_backGreen)))) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : RGB(51, 148, 82))) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 2.0 && x <= 13.0) ? (x == 5.0 || x == 6.0 ? RGB(255, 255, 255) : k_bombBlack) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 2.0 && x <= 13.0) ? (x == 5.0 || x == 6.0 ? RGB(255, 255, 255) : k_bombBlack) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n\tspriteColor = (y == 9.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 8.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x >= 3.0 && x <= 12.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x >= 5.0 && x <= 10.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\n    return spriteColor;\n}\n\nvec3 DisplayFlamePowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_flamePowerUp.x);\n    float y = floor(fragCoord.y - k_flamePowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n    \n    const vec3 k_backGreen = RGB(51, 148, 82);\n    const vec3 k_black = RGB(0, 0, 0);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    const vec3 k_flameYellow = RGB(255, 180, 0);\n    \n    spriteColor = (y == 14.0) ? ((x >= 5.0 && x <= 13.0) ? ((x == 5.0 || x == 9.0 || x == 12.0 || x == 13.0) ? RGB(127, 26, 4) : RGB(51, 148, 82))  : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 13.0) ? ((x >= 3.0 && x <= 14.0) ? ((x == 3.0 || x == 4.0 || x == 6.0 || x == 8.0 || x == 9.0 || x == 11.0 || x == 13.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0 || x == 12.0 ? RGB(255, 202, 0) : k_backGreen)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 14.0 || x == 10.0 || x == 7.0 || x == 2.0) ? RGB(127, 26, 4) : RGB(255, 202, 0))  : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 2.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 9.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 8.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x >= 5.0 && x <= 9.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x >= 2.0 && x <= 13.0) ? ((x == 2.0 || x == 13.0) ? RGB(127, 26, 4) : (x >= 5.0 && x <= 9.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x >= 2.0 && x <= 13.0) ? ((x == 2.0 || x == 13.0) ? RGB(127, 26, 4) : (x >= 6.0 && x <= 8.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x >= 3.0 && x <= 12.0) ? ((x == 3.0 || x == 12.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x >= 4.0 && x <= 11.0) ? RGB(127, 26, 4) : ((x == 0.0 || x == 15.0) ? k_edgeRed : RGB(51, 148, 82))) : spriteColor; \n    \n    return spriteColor;\n}\n\nvec3 DisplaySkatePowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_skatePowerUp.x);\n    float y = floor(fragCoord.y - k_skatePowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n    \n    const vec3 k_backGreen = RGB(51, 148, 82);\n    const vec3 k_black = RGB(0, 0, 0);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    const vec3 k_skateBlue = RGB(5, 119, 252);\n    const vec3 k_skateOrange = RGB(219, 113, 5);\n    \n    spriteColor = (y == 14.0) ? ((x >= 6.0 && x <= 13.0) ? ((x >= 6.0 && x <= 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n    spriteColor = (y == 13.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : ((x < 9.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 5.0 && x <= 13.0) ? ((x == 5.0 || x == 13.0) ? k_black : ((x < 9.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 9.0) ? ((x >= 3.0 && x <= 13.0) ? (((x >= 3.0 && x <= 5.0) || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 8.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 2.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 3.0 || x == 6.0 || x == 9.0 || x == 12.0 || x == 14.0) ? k_black : ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x == 2.0 || x == 7.0 || x == 8.0 || x == 13.0 || x == 4.0 ||x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x >= 3.0 && x <= 6.0 || x >= 9.0 && x <= 12.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x == 2.0 || x == 7.0 || x == 8.0 || x == 13.0 || x == 4.0 ||x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x >= 3.0 && x <= 6.0 || x >= 9.0 && x <= 12.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x == 3.0 || x == 6.0 || x == 9.0 || x == 12.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    \n    return spriteColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 finalColor = vec3(0.0);\n    \n    // Early out if not within bounds\n    if ((fragCoord.x > (k_powerUpSize.x * 4.0)) || (fragCoord.y > k_powerUpSize.y)) \n    {\n        discard;\n    }\n    \n    if (iFrame == 0)\n    {\n        finalColor = vec3(0.0, 0.0, 0.0);     \n        finalColor += IsWithinDimensions(fragCoord, k_bombPowerUp) ? DisplayBombPowerUp(fragCoord) : vec3(0);\n        finalColor += IsWithinDimensions(fragCoord, k_skatePowerUp) ? DisplaySkatePowerUp(fragCoord) : vec3(0);\n        finalColor += IsWithinDimensions(fragCoord, k_flamePowerUp) ? DisplayFlamePowerUp(fragCoord) : vec3(0);            \n    }\n    else\n    {\n        finalColor = texture(iChannel0, uv).rgb;\n    }\t\n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Tile info\n// x = tile type, y = tile timer, z = tile explosion direction, w = explosion steps remaining\nconst int UNBREAKABLE_BLOCK = -2;\nconst int BREAKABLE_BLOCK \t= -1;\nconst int FREE_SPACE\t\t=  0;\nconst int BOMB_POWER_UP\t\t=  1;\nconst int SKATE_POWER_UP\t=  2;\nconst int FLAME_POWER_UP\t=  3;\nconst int EXPLOSION\t\t\t=  4;\nconst int COLLAPSING_BLOCK \t= -3;\nconst int BOMB\t\t\t\t=  20;\n\n// Stage is 15 by 13\nconst uint CELLS_WIDE = 15U;\nconst uint CELLS_TALL = 13U;\n\n// Explosion Directions\nconst uint EXPLOSION_DIRECTION_LEFT  = 1U;\nconst uint EXPLOSION_DIRECTION_UP    = 2U;\nconst uint EXPLOSION_DIRECTION_RIGHT = 4U;\nconst uint EXPLOSION_DIRECTION_DOWN  = 8U;\nconst uint EXPLOSION_DIRECTION_ALL   = 15U;\n\n// Storage register/texel addresses\nconst vec2 txGameInfo = vec2(0.0, 0.0); // x = game mode\nconst vec4 txBombermanInfo = vec4(1.0, 0.0, 8.0, 1.0);\nconst vec2 txBomberman0Info = vec2(1.0, 0.0);\nconst vec2 txBomberman1Info = vec2(5.0, 0.0);\nconst vec2 txBomberman2Info = vec2(9.0, 0.0);\nconst vec2 txBomberman3Info = vec2(13.0, 0.0);\n\n// x = horizontal movement, y = vertical movement, z = bomb key, w = time since last bomb key press\nconst vec2 txBomberman0Command = vec2(1.0, 0.0); \nconst vec2 txBomberman1Command = vec2(2.0, 0.0); \nconst vec2 txBomberman2Command = vec2(3.0, 0.0); \nconst vec2 txBomberman3Command = vec2(4.0, 0.0); \n\nconst vec4 txPlayField = vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));\n\n//////////////////////////////////////////////////\n// Game Modes \nconst float MODE_MATCH_RESET = 0.0;\nconst float MODE_GAMEPLAY = 1.0;\nconst float MODE_MATCH_OVER = 2.0;\nconst float MODE_AWARD = 3.0;\n\n////////////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec2 Saturate(in vec2 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvec2 GetTileIndex(in vec2 uv)\n{\n    return floor(vec2(uv.x, uv.y) * vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0)) - 1.0;\n}\n\nvec2 ConvertTileCoordsToScreenUV(in vec2 tileCoords)\n{\n    return (tileCoords + vec2(1.5)) / vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0);\n}\n\nbool IsBombermanAlive(in float xPosition)\n{\n    return (xPosition >= -10.0);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MtV3Ry",
    "date": "1484961464",
    "viewed": 691,
    "name": "Colored Mandelbrot Set",
    "description": "Colored Mandelbrot Set\nBased on https://blogs.msdn.microsoft.com/shawnhar/2006/12/12/technicolor-julias/",
    "likes": 0,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "mandelbrot"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 uv = fragCoord.xy / iResolution.yy;\n    \n    float z = 1.0 + cos(iTime * 0.125) * 0.99;\n    vec2 o = (iMouse.z > 0.0) ? iMouse.xy / iResolution.xy * vec2(2.0) - vec2(2.2, 1.3) : -vec2(1.2, 0.32);    \n    vec2 c = (uv - vec2(0.5)) * z + o;\n    \n    vec2 v = vec2(0);\n    float m = 0.0; \n    const float r = 5.0;   \t    \n    for (int i = 0; i < 256; ++i)\n    {\n        v = vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y) + c;\n        m = (dot(v, v) < (r * r)) ? (m + 1.0) : m;\n        v = clamp(v, -r, r);\n    }  \n    fragColor = (int(m) != 256) ? sin(m / vec4(4, 8, 12, 1)) * 0.25 + 0.75 : vec4(0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtK3Rt",
    "date": "1476228850",
    "viewed": 873,
    "name": "Silly Spiral",
    "description": "Nothing special just thought it looked pretty cool.",
    "likes": 18,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "spiral"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Update 10/12/16: Hash function update to fix artifacts on mobile. \n\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n// noise functions based on iq's https://www.shadertoy.com/view/MslGD8\nfloat Hash(in vec2 p)\n{\n    return -1.0 + 2.0 * fract(sin(dot(p, vec2(12.0, 78.0))) * 43758.0);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\nfloat Spiral(in vec2 texCoord, in float rotation)\n{   \n    float spiral = sin(50.0 * (pow(length(texCoord), 0.25) - 0.02 * atan(texCoord.x, texCoord.y) - rotation));\n    return clamp(spiral, 0.0, 1.0);\n}\n\nvec3 ColoredSpiral(in vec2 texCoord, in float rotation, in vec3 c0, in vec3 c1)\n{\n    return mix(c0, c1, Spiral(texCoord, rotation));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec4 finalColor = vec4(1.0);\n\n    vec2 portalCenter = vec2(sin(iTime * 2.0), cos(iTime * 2.0)) * 0.025;\n    vec2 portalTexCoord = portalCenter + vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    vec2 pushDirection = normalize(portalTexCoord + vec2(EPSILON));\n    float noise = Noise(pushDirection + iTime) * 0.15 * length(portalTexCoord);\n\n    portalTexCoord = portalTexCoord + (-noise * pushDirection);\n    float r = length(portalTexCoord);\n\n    vec3 portalColor = ColoredSpiral(portalTexCoord, 0.1 * iTime, vec3(0.0, 0.6, 0.0), vec3(0.35, 1.0, 0.0)); \n    finalColor.rgb = mix(finalColor.rgb, mix(portalColor, vec3(0.6, 1.0, 0.35), 0.01 + (r * r)), step(r, 1.0));     \n\n    fragColor = finalColor;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlcSRf",
    "date": "1480747628",
    "viewed": 1000,
    "name": "2D Rope Example",
    "description": "A simple 2D rope demo I quickly hacked together.  Could be improved with stretching/tension forces.  May revisit it later.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "interactive",
     "multipass",
     "rope"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float MAX_ROPE_POINTS = 20.0;\nconst vec4 txRopePoints = vec4(0.0, 0.0, MAX_ROPE_POINTS, 0.0);\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadRope(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy);\n}\n\nfloat Saturate(in float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 Saturate(in vec2 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat sdfCapsule(in vec2 p, in vec2 pointA, in vec2 pointB, in float radius)\n{\n    vec2 lineBA = pointB - pointA;\n    vec2 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = (iResolution.x / iResolution.y);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    uv.x *= aspectRatio;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(int i = 0; i < int(MAX_ROPE_POINTS - 1.0); ++i)\n    {\n        float ropeIndex = float(i);\n        vec2 currentPoint = LoadRope(vec2(ropeIndex - 0.5, 0.0)).xy;\n        vec2 nextPoint = LoadRope(vec2(ropeIndex + 1.0 - 0.5, 0.0)).xy;\n\n        if((distance(currentPoint, nextPoint) > 0.0) && (sdfCapsule(uv, currentPoint, nextPoint, 0.075) < 0.0))\n        {\n            finalColor = vec3(mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), (ropeIndex / MAX_ROPE_POINTS)));\n        }\n    }\n\tfragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "const float MAX_ROPE_POINTS = 20.0;\nconst float MAX_ROPE_SEPERATION = 0.09;\nconst vec4 txRopePoints = vec4(0.0, 0.0, MAX_ROPE_POINTS, 0.0);\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadRope(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy);\n}\n\nvoid StoreRope(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvec4 ConstrainRope(in vec4 ropeParameters, in float forceIndex)\n{\n    const float gravityAmount = 0.98;\n    vec2 gravity = iTimeDelta * vec2(0.0, -gravityAmount);\n    \n    vec2 forcePoint = LoadRope(vec2(forceIndex - 0.5, 0.0)).xy;\n    vec2 q = ropeParameters.xy - forcePoint.xy;\n    float pointDistance = length(q);\n\n    if(pointDistance <= 0.0) // catching bug if distance == 0.0\n    {\n        ropeParameters.xy += gravity;\n    }\n    else\n    {\n        float pastLimit = max(pointDistance - MAX_ROPE_SEPERATION, 0.0);\n\n        // clamp rope distance\n        vec2 towardsPrev = normalize(q);\n        ropeParameters.xy += -towardsPrev * pastLimit; \n\n        // is a hack\n        const float tension = 0.01;\n        ropeParameters.zw += -towardsPrev * tension;\n    }  \n    return ropeParameters;\n}\n\nvec4 MoveRope(in vec4 ropeParameters, in float index)\n{\n    const float gravityAmount = 0.98;\n    if(index >= 1.0)\n    {\n        vec2 gravity = iTimeDelta * vec2(0.0, -gravityAmount);\n        ropeParameters.zw += gravity;\n        ropeParameters.xy += ropeParameters.zw;\n\n        ropeParameters = ConstrainRope(ropeParameters, index - 1.0);\n    }\n    return ropeParameters;\n}\n\nvec2 gPinPoint = vec2(0.0, 0.9);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     float aspectRatio = (iResolution.x / iResolution.y);\n    \n     // don't compute rope if not needed\n    if(fragCoord.x > MAX_ROPE_POINTS || fragCoord.y > 2.0) discard;\n\n    vec4 ropeParameters = LoadRope(fragCoord.xy - 0.5);\n    \n    if(iFrame <= 1) ropeParameters = vec4(gPinPoint.x, gPinPoint.y + floor(fragCoord.x) * -MAX_ROPE_SEPERATION, 0.0, 0.0);\n\n    if((iMouse.z > 0.0) && (fragCoord.x >= 1.0))\n    { \n        ropeParameters = vec4((2.0 * (iMouse.xy / iResolution.xy) - 1.0), 0.0, 0.0);\n        ropeParameters.x *= aspectRatio;\n    }  \n    ropeParameters = MoveRope(ropeParameters, fragCoord.x);\n    \n    fragColor = vec4(0.0);  \n    StoreRope(txRopePoints, ropeParameters, fragColor, fragCoord);\n}",
     "name": "Buf A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4tVSzz",
    "date": "1482595710",
    "viewed": 979,
    "name": "Open Sign",
    "description": "a simple sdf open sign with glow",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "glow",
     "multipass"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Combine\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 signColor = texture(iChannel0, uv).rgb;\n    vec3 blurredSamples = texture(iChannel1, uv).rgb * 5.0;\n\tfragColor = vec4(signColor + blurredSamples, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Scene\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         32\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 20.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\nconst float \tRED_DIM\t\t= 4.0;\nconst float \tRED_LIT\t\t= 3.0;\nconst float \tBLUE_LIT \t= 2.0;\nconst float \tBLUE_DIM \t= 1.0;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n    \n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(in vec3 p, in vec3 boxSize)\n{\n  \tvec3 d = abs(p) - boxSize;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xy) - torusDimensions.x, p.z);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfCapsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    float lightTimer = mod(iTime, 6.0);\n    \n    IntersectionData oIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 1.0) ? RED_DIM : RED_LIT);\n    oIntersectionData.mT = sdTorus(p - vec3(-2.1, 0.0, 0.0), vec2(1.0, 0.1));\n    \n\tIntersectionData pIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 2.0) ? RED_DIM : RED_LIT);\n    pIntersectionData.mT = sdfCapsule(p, vec3(-0.6, -1.0, 0.0), vec3(-0.6, 1.0, 0.0), 0.1);\n    pIntersectionData.mT = min(pIntersectionData.mT, sdfCapsule(p, vec3(-0.6, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.1));\n    pIntersectionData.mT = min(pIntersectionData.mT, sdfCapsule(p, vec3(-0.6, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 0.1));\n    float halfLoop = sdTorus(p - vec3(0.0, 0.5, 0.0), vec2(0.5, 0.1));\n    pIntersectionData.mT = min(pIntersectionData.mT, (p.x < 0.0) ?  MAX_DISTANCE : halfLoop);\n    \n    IntersectionData eIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 3.0) ? RED_DIM : RED_LIT);\n    eIntersectionData.mT = sdfCapsule(p, vec3(1.0, -1.0, 0.0), vec3(1.0, 1.0, 0.0), 0.1);\n    eIntersectionData.mT = min(eIntersectionData.mT, sdfCapsule(p, vec3(1.0, 0.0, 0.0), vec3(1.8, 0.0, 0.0), 0.1));\n    eIntersectionData.mT = min(eIntersectionData.mT, sdfCapsule(p, vec3(1.0, 1.0, 0.0), vec3(1.8, 1.0, 0.0), 0.1));\n    eIntersectionData.mT = min(eIntersectionData.mT, sdfCapsule(p, vec3(1.0, -1.0, 0.0), vec3(1.8, -1.0, 0.0), 0.1));\n       \n    IntersectionData nIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 4.0) ? RED_DIM : RED_LIT);\n    nIntersectionData.mT = sdfCapsule(p, vec3(2.3, -1.0, 0.0), vec3(2.3, 1.0, 0.0), 0.1);\n    nIntersectionData.mT = min(nIntersectionData.mT, sdfCapsule(p, vec3(3.4, -1.0, 0.0), vec3(2.3, 1.0, 0.0), 0.1));\n    nIntersectionData.mT = min(nIntersectionData.mT, sdfCapsule(p, vec3(3.4, -1.0, 0.0), vec3(3.4, 1.0, 0.0), 0.1));\n    \n    oIntersectionData = GetClosestIntersection(oIntersectionData, pIntersectionData);\n    eIntersectionData = GetClosestIntersection(eIntersectionData, nIntersectionData);\n    oIntersectionData = GetClosestIntersection(oIntersectionData, eIntersectionData);\n    \n    IntersectionData edgeIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 0.5) ? BLUE_DIM : BLUE_LIT);\n    edgeIntersectionData.mT = sdfCapsule(p, vec3(4.0, -1.5, 0.0), vec3(4.0, 1.5, 0.0), 0.1);\n    edgeIntersectionData.mT = min(edgeIntersectionData.mT, sdfCapsule(p, vec3(-3.7, -1.5, 0.0), vec3(-3.7, 1.5, 0.0), 0.1));\n    edgeIntersectionData.mT = min(edgeIntersectionData.mT, sdfCapsule(p, vec3(4.0, -1.5, 0.0), vec3(-3.7, -1.5, 0.0), 0.1));\n    edgeIntersectionData.mT = min(edgeIntersectionData.mT, sdfCapsule(p, vec3(4.0, 1.5, 0.0), vec3(-3.7, 1.5, 0.0), 0.1));\n    \n    oIntersectionData = GetClosestIntersection(oIntersectionData, edgeIntersectionData);\n    \n    return oIntersectionData;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }    \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 CalculateLighting(in vec3 normal, in vec3 albedo, in float ambient)\n{       \n    vec3 n = normalize(normal);\n    vec3 l = normalize(vec3(0.0, 0.0, -1.0));\n    return (albedo * ambient) + albedo * Saturate(dot(n, l));\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    // Gets the intersection point from the camera ray to camera facing plane that the core is on\n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == RED_LIT)\n        {\n\t\t\tdiffuse = vec3(1.0, 0.2, 0.2);\n        }\n        else if(intersection.mMaterialIndex == RED_DIM)\n        {\n            diffuse = vec3(0.125, 0.05, 0.05);\n        }\n        else if(intersection.mMaterialIndex == BLUE_LIT)\n        {\n\t\t\tdiffuse = vec3(0.2, 0.2, 1.0);\n        }\n        else if(intersection.mMaterialIndex == BLUE_DIM)\n        {\n            diffuse = vec3(0.05, 0.05, 0.125);\n        }\n        finalColor += CalculateLighting(normal, diffuse, ambient);         \n    }\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.3) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x * 0.5 - 0.25) * (PI * 1.0) : 0.0; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 4.0;\n    vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n    fragColor = DisplayScene(cameraPosition, cameraDirection, 0.4);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Horizontal blur with limit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelOffset = vec2(1.0, 0.0) / iResolution.xy;\n    \n    float weight = 8.0;\n    vec3 horizontalSamples = texture(iChannel0, uv).rgb * weight;\n    \n    const int horizontalHalfSampleCount = 16;\n    for(int i = 1; i < horizontalHalfSampleCount; ++i)\n    {\n        float currentWeight = float(horizontalHalfSampleCount - i);\n        \n        vec3 sampleA = texture(iChannel0, uv + pixelOffset * float(i)).rgb;\n    \thorizontalSamples += (length(sampleA) > 0.6) ? sampleA * currentWeight : vec3(0.0);\n        weight += currentWeight;\n        \n    \tvec3 sampleB = texture(iChannel0, uv - pixelOffset * float(i)).rgb;\n        horizontalSamples += (length(sampleB) > 0.6) ? sampleB * currentWeight: vec3(0.0);\n        weight += currentWeight;\n    }\n    horizontalSamples *= (1.0 / weight);\n\n\tfragColor = vec4(horizontalSamples, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Vertical blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelOffset = vec2(0.0, 1.0) / iResolution.xy;\n    \n    float weight = 0.0;\n    vec3 verticalSamples = vec3(0.0);\n    \n    const int verticalHalfSampleCount = 16;\n    for(int i = 1; i < verticalHalfSampleCount; ++i)\n    {\n        float currentWeight = float(verticalHalfSampleCount - i);\n        \n    \tverticalSamples += texture(iChannel0, uv + pixelOffset * float(i)).rgb * currentWeight;\n        weight += currentWeight;\n    \tverticalSamples += texture(iChannel0, uv - pixelOffset * float(i)).rgb * currentWeight;\n        weight += currentWeight;\n    }\n    verticalSamples *= (1.0 / weight);\n    \n\tfragColor = vec4(verticalSamples, 1.0);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MlyXR1",
    "date": "1484513120",
    "viewed": 1301,
    "name": "Simple Shadowmap",
    "description": "A simple sdf shadowmap example.  Still need to fix aliasing/artifact issues.",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "sdf",
     "shadow",
     "spotlight",
     "multipass",
     "shadowmap"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         128\n#define \tAA \t\t\t\t\t\t2\n#define \tPOISSON_SAMPLING\t\t1\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 500.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\nconst float \tTORUS \t\t\t= 2.0;\nconst float \tGROUND \t\t\t= 1.0;\n\n//////////////////////////////////////////////////\n// Globals\nmat4 gLightViewMatrix;\nvec3 gLightPosition;\nvec3 gLightDirection;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfPlane(in vec3 p, in vec4 normal)\n{\n  \t// n must be normalized\n\treturn dot(p, normal.xyz) + normal.w;\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);\n    \n    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));\n    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale); \n    IntersectionData torusIntersectionData = IntersectionData(sdfTorus(p + curvePoint, vec2(2.0, 0.5)), TORUS);\n\n    return GetClosestIntersection(planeIntersectionData, torusIntersectionData);\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n\n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }   \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nmat4 CreateViewMatrix(in vec3 cameraPosition, in vec3 cameraForward, in vec3 cameraUp)\n{\n    vec3 rightAxis = normalize(cross(cameraForward, cameraUp));\n\n    mat4 viewMatrix = mat4(rightAxis.xyz, 0.0,\n\t\t\t\t\t\t   cameraUp.xyz, 0.0,\n                           cameraForward.xyz, 0.0,\n                           cameraPosition.xyz, 1.0);\n    \n    return viewMatrix;\n}\n\nvec2 CalculateShadowMapUV(in mat4 shadowMapMatrix, in vec3 position, in float aspectRatio)\n{\n    vec3 lightPosition = vec3(shadowMapMatrix[3][0], shadowMapMatrix[3][1], shadowMapMatrix[3][2]); \n    \n    vec3 lightWorldDirection = normalize(position.xyz - lightPosition);\n    vec3 shadowMapCameraRayDirection = (vec4(lightWorldDirection.xyz, 1.0) * shadowMapMatrix).xyz;\n    shadowMapCameraRayDirection /= shadowMapCameraRayDirection.z;\n    \n    vec2 textureCoords = shadowMapCameraRayDirection.xy / vec2(aspectRatio, 1.0);\n    textureCoords = textureCoords * 0.5 + 0.5;\n    \n    return textureCoords;\n}\n\nfloat SampleShadowMap(in vec2 shadowCoords)\n{\n    return texture(iChannel0, shadowCoords).r;\n}\n\nvec2 SamplePoissonDisk(in int i)\n{\n    if(i == 0) \t\t{ return vec2(-0.942016240, -0.39906216); }\n    else if(i == 1) { return vec2( 0.945586090, -0.76890725); }\n    else if(i == 2) { return vec2(-0.094184101, -0.92938870); }\n    else \t\t\t{ return vec2( 0.344959380,  0.29387760); }\n}\n\nfloat SampleShadowMap(in vec3 point, in float shadowMapBias)\n{\n\tconst float shadowMapMaxDistance = 23.0;\n    \n    float shadow = 1.0;\n    \n    vec3 pointToLight = point - gLightPosition;\n    float distanceToLight = length(pointToLight);\n    \n    vec2 shadowCoords = CalculateShadowMapUV(gLightViewMatrix, point, (iResolution.x / iResolution.y));\n    \n    if((shadowCoords.x > EPSILON && shadowCoords.y > EPSILON) && (shadowCoords.x < (1.0 - EPSILON) && shadowCoords.y < (1.0 - EPSILON)))\n    {\n#if POISSON_SAMPLING        \n        for(int i = 0; i < 4; ++i)\n        {\n            const float poissonDiskSpread = 0.00125;\n            float shadowMap = SampleShadowMap(shadowCoords + (SamplePoissonDisk(i) * poissonDiskSpread));\n            \n            float shadowMapDistance = (shadowMap * shadowMapMaxDistance);\n\n            if(shadowMapDistance < (distanceToLight - shadowMapBias))\n            {\n                shadow -= 0.25;\n            }   \n        }\n#else\n        float shadowMap = SampleShadowMap(shadowCoords);\n        float shadowMapDistance = (shadowMap * shadowMapMaxDistance);\n\n        if(shadowMapDistance < (distanceToLight - shadowMapBias))\n        {\n            shadow = 0.0;\n        }     \n#endif\n    }\n    return shadow;\n}\n\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)\n{       \n    vec3 lightToPoint = gLightPosition - point;\n    float spot = step(0.7, dot(normalize(lightToPoint), gLightDirection)) * Saturate(1.0 - length(lightToPoint) / 30.0);\n    float lighting = Saturate(dot(normal, -gLightDirection)) * spot;\n    \n    // Slope bias\n    float shadowMapBias = clamp(0.1 * tan(acos(Saturate(dot(normal, gLightDirection)))), 0.0, 0.1);\n    float shadow = SampleShadowMap(point, shadowMapBias);\n    \n    return (albedo * lighting * shadow) + (albedo * ambient);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n       \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        const float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == TORUS)\n        {\n\t\t\tdiffuse = vec3(1.0, 0.4, 0.0);\n        }\n        else if(intersection.mMaterialIndex == GROUND)\n        {\n            float tile = mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;\n            diffuse = vec3(0.5) + tile;\n        }\n        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, ambient);         \n    }\n    \n    vec3 fogColor = vec3(0.85, 0.85, 1.0);\n    float fogAmount = 1.0 - exp(-intersection.mT * 0.015);\n    finalColor = mix(finalColor, fogColor, fogAmount);\n                          \n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 finalColor = vec4(0.0);\n    \n    // Setup light\n    gLightPosition = vec3(0.0, 8.0, 0.0);\n    gLightDirection = normalize(vec3(0.0, 1.0, 0.0));\n    gLightViewMatrix = CreateViewMatrix(gLightPosition, gLightDirection, vec3(0.0, 0.0, -1.0));\n    \n    vec2 initialScreenCoord = (fragCoord.xy / iResolution.xy);\n#if (AA > 1)\n    for(int x = 0; x < AA; ++x)\n    {\n    \tfor(int y = 0; y < AA; ++y)\n        {\n    \t\tvec2 offset = vec2(float(x), float(y)) / float(AA) - 0.5; \t\n    \t\tvec2 screenCoord = ((fragCoord.xy + offset) / iResolution.xy);\n#else\n    \t\t// Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    \t\tvec2 screenCoord = (fragCoord.xy / iResolution.xy);   \n#endif\n            vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n            float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.3) : 0.0;\n            mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n            float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05; // Multiply by 0.1 to slow down the rotation ;   \n            mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n            // Determine our camera info\n            const float distanceFromOrigin = 8.0;\n            vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n            cameraPosition += vec3(0.0, 2.0, 0.0);\n            vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n            finalColor += DisplayScene(cameraPosition, cameraDirection);\n#if (AA > 1)\n    \t}\n    }\n\tfinalColor /= float(AA * AA);        \n#endif         \n\n    if(initialScreenCoord.x < 0.2 && initialScreenCoord.y > 0.8)\n    {\n        finalColor = texture(iChannel0, vec2(initialScreenCoord.x, (1.0 - initialScreenCoord.y)) * 5.0);\n    }\n\tfragColor = finalColor;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2017\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         128\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_SHADOW_MAP_DISTANCE\t\t= 23.0;\nconst float     EPSILON        \t\t\t \t= 0.001;\nconst float     PI              \t\t\t= 3.14159265359;\n\n//////////////////////////////////////////////////\n// Globals\nvec3 gCameraPosition;\nvec3 gCameraDirection;\n\n//////////////////////////////////////////////////////\n// Intersection Helpers   \nfloat GetClosestIntersection(in float a, in float b)\n{\n    if(a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfPlane(in vec3 p, in vec4 normal)\n{\n  \t// n must be normalized\n  \treturn dot(p, normal.xyz) + normal.w;\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nfloat CheckSceneForIntersection(in vec3 p)\n{\n    float planeT = sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0));\n    \n    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));\n    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale);\n    float torusT = sdfTorus(p + curvePoint, vec2(2.0, 0.5));\n\n    return GetClosestIntersection(planeT, torusT);\n}\n\nfloat Intersect(in Ray initialRay)\n{    \n    float sceneIntersection = MAX_SHADOW_MAP_DISTANCE;\n    \n    float t = 0.0;   \n \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection < EPSILON || t > MAX_SHADOW_MAP_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection; // Step forward\n    }\n    sceneIntersection = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nfloat DisplayShadowMap(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection); \n    return Intersect(cameraRay);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n    // Determine our camera info\n    gCameraPosition = vec3(0.0, 8.0, 0.0);\n    gCameraDirection = normalize(vec3(aspectRatioAdjustedUVs.x, -1.0, aspectRatioAdjustedUVs.y));\n\n    float t = DisplayShadowMap(gCameraPosition, gCameraDirection, 0.4);\n    float shadowMapValue = min(t / MAX_SHADOW_MAP_DISTANCE, 1.0);\n    \n\tfragColor = vec4(vec3(shadowMapValue), 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ltGXRV",
    "date": "1486308434",
    "viewed": 1638,
    "name": "Parallax Mapping Comparision",
    "description": "A quick comparison between some normal/parallax mapping techniques.  \nI feel like there's a bug somewhere with my implementation but I need to dig into it some more. \nPlease correct me if you notice any mistakes.",
    "likes": 28,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "normalmapping",
     "parallaxmapping",
     "pom",
     "steepparallaxmapping"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2017\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         48\n#define \tAA \t\t\t\t\t\t4\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 300.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\nconst float \tCUBE \t\t\t= 2.0;\nconst float \tGROUND \t\t\t= 1.0;\nconst vec3 \t\tBoxCenter \t\t= vec3(0.0, -2.0, 0.0);\nconst vec3 \t\tBoxSize \t\t= vec3(3.5, 10.0, 3.5);\n\n//////////////////////////////////////////////////\n// Globals\nvec3 gCameraPosition;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat DrawCharacter(inout vec2 p, in int c)\n{\n    float fC = float(c);\n    float color = 0.0;\n\tif(p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)\n    {\n        color = step(texture(iChannel1, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);\n    }\n    p.x -= 0.5;\n    return color;\n}\n\n#define DrawNone(c, x) c += DrawCharacter(x, 78); c += DrawCharacter(x, 111); c += DrawCharacter(x, 110); c += DrawCharacter(x, 101)\n#define DrawNormal(c, x) c += DrawCharacter(x, 78); c += DrawCharacter(x, 111); c += DrawCharacter(x, 114); c += DrawCharacter(x, 109); c += DrawCharacter(x, 97); c += DrawCharacter(x, 108)\n#define DrawMapping(c, x) c += DrawCharacter(x, 77); c += DrawCharacter(x, 97); c += DrawCharacter(x, 112); c += DrawCharacter(x, 112); c += DrawCharacter(x, 105); c += DrawCharacter(x, 110); c += DrawCharacter(x, 103)\n#define DrawParallax(c, x) c += DrawCharacter(x, 80); c += DrawCharacter(x, 97); c += DrawCharacter(x, 114); c += DrawCharacter(x, 97); c += DrawCharacter(x, 108); c += DrawCharacter(x, 108); c += DrawCharacter(x, 97); c += DrawCharacter(x, 120)\n#define DrawSteep(c, x) c += DrawCharacter(uv, 83); c += DrawCharacter(x, 116); c += DrawCharacter(x, 101); c += DrawCharacter(x, 101); c += DrawCharacter(x, 112)\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterial;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfBox(in vec3 p, in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfPlane(in vec3 p, in vec4 n)\n{\n\treturn dot(p, n.xyz) + n.w; // normal must be normalized\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);  \n    IntersectionData cubeIntersectionData = IntersectionData(sdfBox(p + BoxCenter, BoxSize), CUBE);\n\n    return GetClosestIntersection(planeIntersectionData, cubeIntersectionData);\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition);   \n        t += sceneIntersection.mT;\n    }   \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Normals\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nfloat SampleTexture(in vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nvec3 SampleNormalMap(in vec2 uv, in float height)\n{\n    const float strength = 40.0;    \n    float d0 = SampleTexture(uv.xy);\n    float dX = SampleTexture(uv.xy - vec2(EPSILON, 0.0));\n    float dY = SampleTexture(uv.xy - vec2(0.0, EPSILON));\n    return normalize(vec3((dX - d0) * strength, (dY - d0) * strength, 1.0));\n}\n\nvec3 CalculateNormalMapNormal(in vec2 uv, in float height, in vec3 normal, in vec3 tangent, in vec3 binormal)\n{   \n    vec3 normalMap = SampleNormalMap(uv, height).rgb;\n\treturn normalize((normal * normalMap.b) + (binormal * normalMap.g) + (tangent * normalMap.r));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)\n{       \n    return (albedo * Saturate(dot(normal, vec3(0.0, -1.0, 0.25)))) + (albedo * ambient);\n}\n\nvec3 ParallaxMapping(in vec3 position, inout vec3 normal, in float d, in int toggle)\n{\n    vec3 toBox = -position - BoxCenter;\n    vec3 uvBoxSize = vec3(BoxSize.x, 3.5, BoxSize.z);\n\n    vec2 textureCoords = (abs(normal.x) == 1.0) ? (toBox.zy / uvBoxSize.zy) : vec2(0.0);\n    textureCoords += (abs(normal.y) == 1.0) ? (toBox.xz / uvBoxSize.xz) : vec2(0.0);\n    textureCoords += (abs(normal.z) == 1.0) ? (toBox.xy / uvBoxSize.xy) : vec2(0.0);\n    textureCoords = (textureCoords * 0.5 + 0.5) + vec2(0.0, 0.5);   \n    \n    float height = SampleTexture(textureCoords);\n    \n    vec3 tangent = normalize(dFdy(textureCoords).y * dFdx(position) - dFdx(textureCoords).y * dFdy(position));\n    vec3 temp = cross(normal, tangent);\n    tangent = cross(temp, normal);\n    tangent = normalize(tangent);\n    vec3 binormal = cross(-tangent, normal);\n     \n    vec3 viewTangentSpace = normalize(gCameraPosition - position) * mat3(tangent, binormal, normal);\n   \n    const float scale = 0.04;\n    const float bias = 0.02; \n\tvec2 textureOffset = (viewTangentSpace.xy * (height * scale - bias)) / viewTangentSpace.z;\n    \n    // Steep Parallax Mapping and POM\n    const float numberOfSamples = 10.0;\n\tconst float stepSize = 1.0 / numberOfSamples;\n\tvec2 deltaOffset = textureOffset / numberOfSamples;\n\tfloat currentLayerDepth = 0.0;\n    float currentDepth = 0.0;       \n    \n    if ((toggle == 3) || (toggle == 4))  // Steep Parallax Mapping or POM\n    {   \n        for(float i = 0.0; i <= numberOfSamples; ++i)\n        {\n            currentDepth -= stepSize;           \n        \ttextureCoords += deltaOffset;\n            height = SampleTexture(textureCoords);\n            \n            if(currentDepth < height) \n            {\t\n                break;\n            }\n        }\n        \n        if (toggle == 4) // POM\n        {\n            vec2 previousTextureCoords = textureCoords - deltaOffset;\n            float collisionDepth = height - currentDepth;\n            float previousDepth = SampleTexture(previousTextureCoords) - currentDepth - stepSize;\n\n            float weight = collisionDepth / (collisionDepth - previousDepth);\n            textureCoords = mix(textureCoords, previousTextureCoords, weight);    \n            height = SampleTexture(textureCoords);\n        }\n    }\n    else if(toggle == 2) // Parallax Mapping  \n    {\n        textureCoords = textureCoords + textureOffset; \n        height = SampleTexture(textureCoords);\n    }\n\n    // Final Display\n    if((toggle >= 1) && (toggle <= 4))\n    {\n        normal = CalculateNormalMapNormal(textureCoords, height, normal, tangent, binormal);        \n    }\n    return SampleTexture(textureCoords) * vec3(0.85, 0.85, 1.0);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv)\n{\n    int toggle = int(floor(mod(iTime, 5.0)));\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n       \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        if(intersection.mMaterial == CUBE)\n        {\n\t\t\tdiffuse = ParallaxMapping(intersectionPoint, normal, intersection.mT, toggle);\n        }\n        else if(intersection.mMaterial == GROUND)\n        {\n            diffuse = vec3(0.5) + mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;\n        }\n        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, 0.2);     \n    }\n    finalColor = mix(finalColor, vec3(0.85, 0.85, 1.0), 1.0 - exp(-intersection.mT * 0.015));\n\n    \n    float character = 0.0;\n    if(toggle == 0)\n    {\n        DrawNone(character, uv);\n    }\n    else if(toggle == 1)\n    {\n        DrawNormal(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 2)\n    {\n        DrawParallax(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 3)\n    {\n        DrawSteep(character, uv);\n        uv.x -= 0.5;\n        DrawParallax(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 4)\n    {\n        character += DrawCharacter(uv, 80); \n        character += DrawCharacter(uv, 79); \n        character += DrawCharacter(uv, 77);\n    }\n    return vec4(mix(finalColor, vec3(1.0), character), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec4 finalColor = vec4(0.0);\n\n    float xRot = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRot);\n    float yRot = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.02;\n    mat3 yRotMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRot);\n    \n    const float originDistance = 8.0;\n    gCameraPosition = vec3(originDistance * sin(yRot) * cos(xRot), originDistance * sin(xRot), originDistance * cos(yRot) * cos(xRot)) + vec3(0.0, 4.0, 0.0);\n    vec2 offset = vec2(0.0);\n    \n#if (AA > 1)\n    for(int x = 0; x < AA; ++x)\n    {\n    \tfor(int y = 0; y < AA; ++y)\n        {\n    \t\toffset = vec2(float(x), float(y)) / float(AA) - 0.5; \t \n#endif // (AA > 1)\n            vec2 screenCoord = ((fragCoord.xy + offset) / iResolution.xy);\n            vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n            // Determine our camera info          \n            vec3 cameraDirection = normalize(yRotMatrix * xRotMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));                   \n            finalColor += DisplayScene(gCameraPosition, cameraDirection, ((fragCoord.xy + offset) / iResolution.yy) * 8.0);\n#if (AA > 1)\n    \t}\n    }\n\tfinalColor /= float(AA * AA);        \n#endif // (AA > 1)     \n\tfragColor = finalColor;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4lKSzK",
    "date": "1485061275",
    "viewed": 672,
    "name": "Worley/Cell Noise",
    "description": "Worley and Cell Noise\nHopefully I'm doing this right.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "noise",
     "worley",
     "cell"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 Hash2D(in vec2 p)\n{\n    return fract(sin(p * mat2(12.98, 78.23, 127.99, 311.33)) * 43758.54);\n}\n\nvec3 DisplayNoise(in vec4 d)\n{\n    float toggle = mod(floor(iTime * 0.5), 6.0);\n    \n    vec3 color = d.xxx;\n    \n    if(toggle == 1.0) \t\tcolor = vec3(1.0 - d.x);\n    else if(toggle == 2.0) \tcolor = vec3(d.y - d.x);     \n    else if(toggle == 3.0) \tcolor = vec3(d.z - d.y);\n    else if(toggle == 4.0) \tcolor = vec3(d.z - d.x);  \n    else if(toggle == 5.0) \tcolor = d.xyz;   \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy * 12.0;\n    vec2 i = floor(uv);\n    vec2 n = fract(uv);\n    vec4 minD = vec4(9.0);\n    \n    for (float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 point = sin(iTime + 32.0 * Hash2D(i + vec2(x, y))) * 0.5 + 0.5;\n            float d = length(vec2(x, y) + point - n);\n            \n            minD = (d < minD.x) ? vec4(d, minD.xyz) \n               \t : (d < minD.y) ? vec4(minD.x, d, minD.yz) \n               \t : (d < minD.z) ? vec4(minD.xy, d, minD.z) \n               \t : (d < minD.w) ? vec4(minD.xyz, d) \n                 : minD;\n        }\n    }\n    fragColor = vec4(DisplayNoise(minD), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}