{
 "userName": "AxleMike",
 "date": "2026-02-27T21:35:47.585Z",
 "numShaders": 11,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "Xls3DM",
    "date": "1422494432",
    "viewed": 664,
    "name": "A Simple Ray Tracer",
    "description": "My first ray tracer.  Basically a testbed to mess around in.",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raytracing",
     "raytracer",
     "sphere",
     "softshadows",
     "plane"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// A rough draft of a ray tracer, I need to go back through and fix some artifacts and optimize\n\n// References:\n// Used iq's noise example and anji's ray tracer as initial examples\n\n// https://www.shadertoy.com/view/lsf3WH\n// https://www.shadertoy.com/view/4dsGRn\n\n//////////////////////////////////////////////////\n// Settings\n//////////////////////////////////////////////////\n#define     NUMBER_OF_BOUNCES   \t4\n#define     MATERIALS_ENABLED   \t1\n#define     SHADOWS_ENABLED     \t1\n#define     SOFT_SHADOWS_ENABLED\t1\n#define \tSOFT_SHADOW_SAMPLES\t\t26 // 100 looks nice but is slow, need to optimize\n#define     SHOW_NORMALS        \t0\n\n//////////////////////////////////////////////////\n// Constants\n//////////////////////////////////////////////////\nconst float     PI \t\t\t\t = 3.14159265359;\nconst float     MAX_DISTANCE \t = 1000.0;\nconst float     EPSILON \t\t = 0.001;\n\n//////////////////////////////////////////////////\n// Helpers\n//////////////////////////////////////////////////  \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Noise(in vec2 uv)\n{ \n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453); \n} \n\nfloat ComputeFresnel(in float NdotV)\n{\n\tconst float fresnelReflectionIndex = 0.01;\n\tfloat fresnel = fresnelReflectionIndex + (1.0 - fresnelReflectionIndex) * pow((1.0 - NdotV), 5.0);\n    return fresnel;\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float rc = 1.0 - c;\n    \n    return mat3(rc * axis.x * axis.x + c,          rc * axis.x * axis.y - axis.z * s, rc * axis.z * axis.x + axis.y * s,\n                rc * axis.x * axis.y + axis.z * s, rc * axis.y * axis.y + c,          rc * axis.y * axis.z - axis.x * s,\n                rc * axis.z * axis.x - axis.y * s, rc * axis.y * axis.z + axis.x * s, rc * axis.z * axis.z + c);\n}\n\n//////////////////////////////////////////////////\n// Materials\n//////////////////////////////////////////////////  \nstruct Material\n{\n    vec3    mAlbedo;\n    vec3    mSpecular;\n    float   mMicrosurface;\n};\n    \nconst int NUMBER_OF_MATERIALS = 5;\nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nvoid InitializeMaterials()\n{\n    gMaterials[0] = Material(vec3(0.8, 0.8, 0.8), vec3(0.80), 1.0);\n    gMaterials[1] = Material(vec3(0.1, 1.0, 0.1), vec3(0.32), 0.3);\n    gMaterials[2] = Material(vec3(1.0, 0.7, 0.0), vec3(0.42), 0.1);\n    gMaterials[3] = Material(vec3(0.4, 0.4, 0.8), vec3(0.05), 0.2); \n    gMaterials[4] = Material(vec3(0.9, 0.1, 0.1), vec3(0.02), 0.2); \n}\n\n//////////////////////////////////////////////////\n// Geometry\n//////////////////////////////////////////////////\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n};    \n\nstruct Sphere\n{\n    vec3    mCenter;\n    float   mRadius;\n\n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n\nstruct Plane\n{\n    vec3    mNormal;\n    float   mD;\n    \n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n        \n//////////////////////////////////////////////////\n// Intersection Helpers\n//////////////////////////////////////////////////   \nstruct IntersectionPoint\n{\n    vec3        mPoint;\n    vec3        mNormal;\n    float       mT;\n    \n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n    \nIntersectionPoint GetClosestIntersection(in IntersectionPoint a, in IntersectionPoint b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;  \n}\n  \nbool IsIntersectionValid(in IntersectionPoint a)\n{\n    return (a.mT < (MAX_DISTANCE - EPSILON));  \n}\n\n//////////////////////////////////////////////////\n// Creation Helpers\n////////////////////////////////////////////////// \n#if MATERIALS_ENABLED\n#define CREATE_SPHERE(position, radius, material) Sphere(position, radius, material)\n#define CREATE_PLANE(normal, d, material) Plane(normalize(normal), d, material)\n#define CREATE_TRIANGLE(a, b, c, material) Triangle(a, b, c, material)\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE, gMaterials[0])\n#else\n#define CREATE_SPHERE(position, radius, material) Sphere(position, radius)    \n#define CREATE_PLANE(normal, d, material) Plane(normalize(normal), d)   \n#define CREATE_TRIANGLE(a, b, c) Triangle(a, b, c)\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE) \n#endif // MATERIALS_ENABLED  \n\n//////////////////////////////////////////////////\n// Intersection Tests\n////////////////////////////////////////////////// \nIntersectionPoint RayPlaneIntersectionTest(in Ray ray, in Plane plane)\n{\n    IntersectionPoint intersection = INVALID_INTERSECTION;\n    \n    float numerator = plane.mD - dot(plane.mNormal, ray.mPosition);\n    float denominator = dot(plane.mNormal, ray.mDirection);\n    if(abs(denominator) > EPSILON)\n    {\n        float t = numerator / denominator;\n        if(t > EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = plane.mNormal;\n            intersection.mT = t;\n\n#if MATERIALS_ENABLED\n            intersection.mMaterial = plane.mMaterial;\n#endif // MATERIALS_ENABLED   \n        }\n    }\n    return intersection;\n}\n\nIntersectionPoint RaySphereIntersectionTest(in Ray ray, in Sphere sphere)\n{   \n    IntersectionPoint intersection = INVALID_INTERSECTION;\n\n    float sRadiusSquared = sphere.mRadius * sphere.mRadius;\n    vec3 eDistance = ray.mPosition - sphere.mCenter;\n    \n    float b = dot(eDistance, ray.mDirection);\n    float c = dot(eDistance, eDistance) - sRadiusSquared;\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        float t = max(-b - sqrt(discriminant), 0.0); // clamp t to zero incase it started inside the sphere\n           \n        if(discriminant >= EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = normalize(intersection.mPoint - sphere.mCenter);\n            intersection.mT = t;\n      \n#if MATERIALS_ENABLED\n            intersection.mMaterial = sphere.mMaterial;\n#endif // MATERIALS_ENABLED          \n       }      \n    }\n    return intersection;\n}\n\nIntersectionPoint CheckSceneForIntersection(in Ray currentRay)\n{\n    // Spheres\n    Sphere sphere0 = CREATE_SPHERE(vec3(-1.3, -0.2, -0.2), 0.2 + pow(abs(sin(iTime * PI * 0.4 + 0.2) * 0.4), 2.0), gMaterials[1]);  \n    Sphere sphere1 = CREATE_SPHERE(vec3(-0.1, (sin(iTime * PI * 0.4) * 0.75) + 0.35, -0.5), 0.7, gMaterials[2]);  \n    Sphere sphere2 = CREATE_SPHERE(vec3(0.9, -0.05, 0.2), 0.4, gMaterials[3]);\n    Sphere sphere3 = CREATE_SPHERE(vec3(0.1 + (cos(iTime * PI * 0.4)), 0.8, 0.7), 0.5, gMaterials[4]);\n\n    // Check scene for intersection   \n    IntersectionPoint sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere0);\n    IntersectionPoint sphereIntersection1 = RaySphereIntersectionTest(currentRay, sphere1);\n    IntersectionPoint closestIntersection = GetClosestIntersection(sphereIntersection0, sphereIntersection1);\n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere2);\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere3);\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n   \n    // Ground Plane\n    Plane plane0 = CREATE_PLANE(vec3(0.0, 1.0, 0.0), -1.1, gMaterials[0]);  \n    IntersectionPoint planeIntersection = RayPlaneIntersectionTest(currentRay, plane0);\n    closestIntersection = GetClosestIntersection(closestIntersection, planeIntersection);\n     \n    return closestIntersection;\n}\n\n//////////////////////////////////////////////////\n// Lighting Helpers\n//////////////////////////////////////////////////\nstruct DirectionalLight\n{\n    vec3 mDirection;\n    vec3 mColor;\n}; \n    \nvec3 ApplyDirectionalLight(in DirectionalLight light, in IntersectionPoint geometryIntersection, in vec3 startingPoint)\n{\n    // Determine some values\n    vec3 normal = normalize(geometryIntersection.mNormal);\n    vec3 lightDirection = normalize(-light.mDirection);\n    vec3 viewVector = normalize(startingPoint - geometryIntersection.mPoint);\n    vec3 halfVector = normalize(lightDirection + viewVector);\n    \n    // Wolfgang's cook torrence approach from Programming Vertex and Pixel shaders \n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = Saturate(dot(normal, viewVector));\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float NHSquared = NdotH * NdotH;\n    float roughnessSquared = geometryIntersection.mMaterial.mMicrosurface * geometryIntersection.mMaterial.mMicrosurface;\n    \n    float microfacets = 0.0;\n    float geometricAttenuation = 0.0;\n    vec3 specular = vec3(0.0);\n    \n    float denom0 = roughnessSquared * NHSquared;\n    float denom1 = denom0 * NHSquared;\n    \n    if((abs(denom0) > EPSILON) && (abs(denom1) > EPSILON))\n    {\n    \tmicrofacets = (1.0 / denom1) * (exp(-((1.0 - NHSquared) / denom0))); // D\n    }\n   \tif(abs(VdotH) > EPSILON)\n    {\n    \tgeometricAttenuation = min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)); // G\n    }\n    float fresnel = ComputeFresnel(NdotV); // F\n    \n    float denom2 = PI * NdotL * NdotV;\n    if(abs(denom2) > EPSILON)\n    {\n    \tspecular = (fresnel * microfacets * geometricAttenuation) / denom2 * geometryIntersection.mMaterial.mSpecular;\n    }\n    vec3 lighting = ((NdotL * Saturate(1.5 * ((0.7 * NdotL * geometryIntersection.mMaterial.mAlbedo + specular)))))  * light.mColor;\n        \n    // Cast a ray to check for shadows\n    float shadow = 1.0;\n#if SHADOWS_ENABLED\n   \n#if SOFT_SHADOWS_ENABLED  \n    // Create slight varations around the incomming light direction for sampling\n    vec3 axis0 = normalize(cross(lightDirection, vec3(0.0, 1.0, 0.0)));\n    vec3 axis1 = normalize(cross(lightDirection, axis0));\n                       \n    for(int i = 0; i < SOFT_SHADOW_SAMPLES; ++i)\n    {   \n        float index = float(i);\n        float sampleIndex = index / float(SOFT_SHADOW_SAMPLES / 4) * 2.0 * PI + Noise(startingPoint.xz);\n     \tfloat pushAmount = (mod(index, 4.0) + 1.0) * 0.25;\n        vec3 offset = (cos(sampleIndex) * axis0 + sin(sampleIndex) * axis1) * pushAmount * 0.01;\n        \n    \tRay shadowRay = Ray(geometryIntersection.mPoint + (EPSILON * normal), (lightDirection + offset));\n    \tIntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n        shadow += IsIntersectionValid(lightIntersection) ? 0.0 : 1.0; // Determine if we hit an object and are in a shadow region\n    }\n    shadow /= float(SOFT_SHADOW_SAMPLES);\n#else\n    Ray shadowRay = Ray(geometryIntersection.mPoint + (EPSILON * normal), lightDirection);\n    IntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n    shadow = IsIntersectionValid(lightIntersection) ? 0.0 : shadow; // Determine if we hit an object and are in a shadow region\n#endif // SOFT_SHADOWS_ENABLED\n    \n#endif // SHADOWS_ENABLED\n    \n    return (lighting * shadow);\n}\n\nvec3 CalculateLighting(in IntersectionPoint intersection, in vec3 startingPoint)\n{\n    DirectionalLight directionalLight = DirectionalLight(vec3(0.4, -1.0, -0.8), vec3(1.0));    \n    return ApplyDirectionalLight(directionalLight, intersection, startingPoint);\n}\n\n//////////////////////////////////////////////////\n// Implementation\n//////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    InitializeMaterials();\n\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    float aspectRatio = (iResolution.x / iResolution.y);\n    vec2 uv =  2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec2 aspectRatioAdjustedUVs = vec2(uv.x * aspectRatio, uv.y);\n       \n    // Rotate the scene\n    float rotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * PI * 2.0 : (iTime * PI) * 0.1; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 rotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), rotationValue);\n    vec3 cameraPosition = vec3(2.0 * sin(rotationValue), 0.0, 2.0 * cos(rotationValue));\n    \n    // Determine the inital ray, the camera ray \n    vec3 cameraRayDirection = normalize(vec3(aspectRatioAdjustedUVs.xy, -1.0));\n    cameraRayDirection = (rotationMatrix * cameraRayDirection);\n    Ray ray = Ray(cameraPosition, cameraRayDirection);\n          \n    vec3 color = vec3(0.0);\n    \n    // Find the first collision\n    IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\n#if SHOW_NORMALS    \n    vec3 normal = currentIntersection.mNormal;\n#endif // SHOW_NORMALS\n    \n    vec3 specular = vec3(1.0); // Specular starts at one and will decrease with every bounce\n\tvec3 lighting = vec3(1.0); // Lighting starts at one so background cubemap will be lit\n \n    for(int i = 0; i < NUMBER_OF_BOUNCES; ++i)\n    {\n        // Only apply the bounces if we actually hit something\n        if(IsIntersectionValid(currentIntersection))\n        {\n            lighting = CalculateLighting(currentIntersection, ray.mPosition);\n            color += (lighting * specular);\n            \n            specular *= (currentIntersection.mMaterial.mSpecular); \n\n            // Determine the bounce direction of the ray and update the structure\n            ray.mDirection = reflect(ray.mDirection, currentIntersection.mNormal);\n            ray.mPosition = currentIntersection.mPoint + ray.mDirection * EPSILON;\n\n            // Trace the ray forward\n            currentIntersection = CheckSceneForIntersection(ray);\n        }\n        else\n        {\n            // We didn't hit anything, so return the texture cube color and break out!\n            color.rgb += texture(iChannel0, ray.mDirection).rgb * specular; \n            break; \n        }\n    }\n    \n#if SHOW_NORMALS    \n    fragColor = vec4(normal * 0.5 + 0.5, 1.0); // Modify the normal to go from [0,0] to [1,1]\n#else\n    fragColor = vec4(color.rgb, 1.0);\n#endif \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlfSzj",
    "date": "1437788127",
    "viewed": 634,
    "name": "Simple Text Example",
    "description": "Simple Text Example\n\nInitial implementation was based on https://www.shadertoy.com/view/XsBGRt\n\nI may take another pass at this and try to make it a bit more flexible.\n",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "text"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/**\n * References:\n *\n * - https://www.shadertoy.com/view/XsBGRt\n*/\n\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n\n#define SPACE(position) position.x -= 8.0 \n#define NEGATIVE(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n\n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\nfloat WriteString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    textCursor *= iResolution.xy;\n        \n    fragCoord = (fragCoord.xy * iResolution.xy) / scale;\n    vec2 textPos = floor(fragCoord.xy - (textCursor.xy  / scale) + 1.0);\n    \n    if (textPos.y < 1.0 || textPos.y > 8.0)\n    {\n        return 0.0;\n    }\n    \n    float bitVal = 0.0;\n\n    bitVal += LETTER_A(textPos);\n    bitVal += LETTER_B(textPos);\n    bitVal += LETTER_C(textPos);\n    bitVal += LETTER_D(textPos);\n    bitVal += LETTER_E(textPos);\n    bitVal += LETTER_F(textPos);\n    bitVal += LETTER_G(textPos);\n    bitVal += LETTER_H(textPos);\n    bitVal += LETTER_I(textPos);\n    bitVal += LETTER_J(textPos);\n    bitVal += LETTER_K(textPos);\n    bitVal += LETTER_L(textPos);\n    bitVal += LETTER_M(textPos);\n    bitVal += LETTER_N(textPos);\n    bitVal += LETTER_O(textPos);\n    bitVal += LETTER_P(textPos);   \n    bitVal += LETTER_Q(textPos);\n    bitVal += LETTER_R(textPos);\n    bitVal += LETTER_S(textPos);    \n    bitVal += LETTER_T(textPos);  \n    bitVal += LETTER_U(textPos);  \n    bitVal += LETTER_V(textPos);    \n    bitVal += LETTER_W(textPos);\n    bitVal += LETTER_X(textPos);\n    bitVal += LETTER_Y(textPos);\n    bitVal += LETTER_Z(textPos);\n    \n    SPACE(textPos);\n    \n    bitVal += NEGATIVE(textPos);\n    bitVal += NUMBER_1(textPos);\n    bitVal += NUMBER_2(textPos);\n    bitVal += NUMBER_3(textPos);\n    bitVal += NUMBER_4(textPos);\n    bitVal += NUMBER_5(textPos);\n    bitVal += NUMBER_6(textPos);\n    bitVal += NUMBER_7(textPos);\n    bitVal += NUMBER_8(textPos);\n    bitVal += NUMBER_9(textPos);\n    bitVal += NUMBER_0(textPos);\n\n    return bitVal;\n}\n\nfloat DisplayDigit(in int digit, out vec2 textPos)\n{\n    float bitVal = 0.0;\n    \n    if(digit == 0)      { bitVal += NUMBER_0(textPos); }\n    else if(digit == 1) { bitVal += NUMBER_1(textPos); }\n    else if(digit == 2) { bitVal += NUMBER_2(textPos); }\n    else if(digit == 3) { bitVal += NUMBER_3(textPos); }\n    else if(digit == 4) { bitVal += NUMBER_4(textPos); }\n    else if(digit == 5) { bitVal += NUMBER_5(textPos); }\n    else if(digit == 6) { bitVal += NUMBER_6(textPos); }\n    else if(digit == 7) { bitVal += NUMBER_7(textPos); }\n    else if(digit == 8) { bitVal += NUMBER_8(textPos); }\n    else if(digit == 9) { bitVal += NUMBER_9(textPos); }\n    \n    return bitVal;\n}\n\nfloat WriteInteger(in vec2 textCursor, in vec2 fragCoord, in float scale, in int number)\n{\n    const int MAX_NUMBER_OF_DIGITS = 8;\n    \n    textCursor *= iResolution.xy;\n\n    fragCoord = (fragCoord.xy * iResolution.xy) / scale;\n    vec2 textPos = floor(fragCoord.xy - (textCursor.xy / scale) + 1.0);   \n    \n    if (textPos.y < 1.0 || textPos.y > 8.0)\n    {\n        return 0.0;\n\t}\n      \n    float bitVal = 0.0;\n    \n    if(number < 0)\n    {\n     \tnumber = -number;\n        bitVal += NEGATIVE(textPos);\n    }\n    \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0));\n        foundNonZero = (digit != 0) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero)\n            {\n                bitVal += DisplayDigit(digit, textPos);\n            }\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 textPosition = vec2(0.1, 0.1);\n\n    float textBit = WriteString(textPosition, uv, 2.0);\n    \n    textPosition = vec2(0.1, 0.3);\n    textBit += WriteInteger(textPosition, uv, 2.0, int(iTime));\n    \n    vec3 fontColor = vec3(1.0);\n    fragColor = vec4(fontColor * textBit, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtjSDh",
    "date": "1444021607",
    "viewed": 3148,
    "name": "Parallax Scrolling Star Field",
    "description": "A rough parallax scrolling star field.",
    "likes": 17,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "parallax",
     "starfield"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Voronoi and fractal noise functions based on iq's https://www.shadertoy.com/view/MslGD8\n\nfloat Hash(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    return -1.0 + 2.0 * fract(sin(h) * 43758.5453);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    float h2 = dot(p, vec2(37.271, 377.632));\n    return -1.0 + 2.0 * vec2(fract(sin(h) * 43758.5453), fract(sin(h2) * 43758.5453));\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\nfloat FractalNoise(in vec2 p)\n{\n    p *= 5.0;\n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n\tfloat f = 0.5000 * Noise(p); p = m * p;\n\tf += 0.2500 * Noise(p); p = m * p;\n\tf += 0.1250 * Noise(p); p = m * p;\n\tf += 0.0625 * Noise(p); p = m * p;\n    \n    return f;\n}\n\nvec3 Voronoi(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j)\n    {\n        for(int i = -1; i <= 1; ++i)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = Hash2D(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\treturn vec3(md, mr);\n}\n\nvec3 ApplyFog(in vec2 texCoord)\n{\n    vec3 finalColor = vec3(0.0);\n    \n    vec2 samplePosition = (4.0 * texCoord.xy / iResolution.xy) + vec2(0.0, iTime * 0.0025);\n    float fogAmount = FractalNoise(samplePosition) * 0.175;\n        \n    vec3 fogColor = vec3(texCoord.xy / iResolution.xy + vec2(0.5, 0.0), sin(iTime) * 0.25 + 0.5);\n    finalColor = fogColor * fogAmount * vec3(sin(iTime) * 0.00125 + 0.75);  \n    \n    return finalColor;\n}\n\nvec3 AddStarField(vec2 samplePosition, float threshold)\n{\n    vec3 starValue = Voronoi(samplePosition);\n    if(starValue.x < threshold)\n    {\n        float power = 1.0 - (starValue.x / threshold);\n        return vec3(power * power * power);\n    }\n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxResolution = max(iResolution.x, iResolution.y);\n    \n\tvec3 finalColor = ApplyFog(fragCoord.xy);\n    \n    // Add Star Fields\n    vec2 samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.01);\n    finalColor += AddStarField(samplePosition * 16.0, 0.00125);\n    \n    samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.004);\n    finalColor += AddStarField(samplePosition * 20.0, 0.00125);\n    \n    samplePosition = (fragCoord.xy / maxResolution) + vec2(0.0, iTime * 0.0005 + 0.5);\n    finalColor += AddStarField(samplePosition * 8.0, 0.0007);\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lst3W2",
    "date": "1452574056",
    "viewed": 1413,
    "name": "Shadertris",
    "description": "A proof of concept. Still needs some work (pretty rough visually, no score, additional code clean up).\n\nControls\narrow keys: move\nrotate: a/d/space/up",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "game",
     "interactive",
     "multipass"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Based on iq's brick game: https://www.shadertoy.com/view/MddGzf\n\n// Modified has unique colors per block and some 5-pieces\n#define MODIFIED 1\n#define CLASSIC 2\n#define MODE MODIFIED\n\n#if (MODE == MODIFIED)\nconst int CELLS_WIDE = 13;\nconst float NUM_BLOCK_TYPES = 8.0;\n#else\nconst int CELLS_WIDE = 10;\nconst float NUM_BLOCK_TYPES = 7.0;\n#endif\nconst int CELLS_TALL = 20; // hide the top four cells so we don't see shapes spawning\n\nconst float fCELLS_WIDE = float(CELLS_WIDE);\nconst float fCELLS_TALL = float(CELLS_TALL);\nconst int HALF_CELLS_WIDE = CELLS_WIDE / 2;\nconst int HALF_CELLS_TALL = CELLS_TALL / 2;\nconst float fHALF_CELLS_WIDE = float(HALF_CELLS_WIDE);\nconst float fHALF_CELLS_TALL = float(HALF_CELLS_TALL);\n\nconst float PI = 3.14159265359;\n\n// Block Types\nconst float I_BLOCK = 1.0;\nconst float J_BLOCK = 2.0;\nconst float L_BLOCK = 3.0;\nconst float O_BLOCK = 4.0;\nconst float S_BLOCK = 5.0;\nconst float T_BLOCK = 6.0;\nconst float Z_BLOCK = 7.0;\nconst float PLUS_BLOCK = 8.0;\nconst float MAX_BLOCK = 9.0;\n\n// storage register/texel addresses\nconst vec2 txGameInfo0      \t\t= vec2(0.0, 0.0); // x = game state, y = time in current state, z = time till next spin, time till next move\nconst vec2 txGameInfo1 \t    \t\t= vec2(1.0, 0.0); // x = score, y = total lines cleared, z = highScore, w = drop speed\nconst vec2 txGameInfo2 \t    \t\t= vec2(2.0, 0.0); // x = current test row, y = kill/copy row, z = next block type, w = current multipler\nconst vec2 txControlledBlockInfo0 \t= vec2(3.0, 0.0); // xy = position, z = rotation, w = block type\nconst vec2 txControlledBlockInfo1 \t= vec2(4.0, 0.0); // x = time till drop, y = next block type, z = space released\nconst vec4 txBlocks \t\t\t\t= vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));  // x = taken, y = color, z = destory, w = time till death\n\n// Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec3 GetColor(in float colorType, in vec2 textCoord)\n{\n    vec3 color = vec3(0.0);\n    \n    if(colorType == I_BLOCK)\n    \tcolor = vec3(0.5, 1.0, 1.0); // cyan\n    else if(colorType == J_BLOCK)    \n        color = vec3(0.0, 0.0, 1.0); // blue\n    else if(colorType == L_BLOCK)    \n        color = vec3(1.0, 0.5, 0.0); // orange\n    else if(colorType == O_BLOCK)    \n        color = vec3(1.0, 1.0, 0.0); // yellow\n    else if(colorType == S_BLOCK)    \n        color = vec3(0.0, 1.0, 0.5); // lime green\n    else if(colorType == T_BLOCK)    \n        color = vec3(0.5, 0.0, 1.0); // purple\n    else if(colorType == Z_BLOCK)    \n        color = vec3(1.0, 0.0, 0.0); // red\n    else if(colorType == PLUS_BLOCK)    \n        color = vec3(1.0, 0.7, 0.8); // pink\n\telse if(colorType == MAX_BLOCK)\n        color = vec3(1.0);\n\n    vec2 q = abs(textCoord);   \n    vec2 t = step(vec2(0.9), q);\n    return mix(color * 0.0, + color, vec3(1.0 - length(q * q)));\n}\n\nvec4 GetCollisionSetA(in float blockType)\n{\n    if(blockType == I_BLOCK)\n   \t\treturn vec4(0.0, 0.0, 0.0, 1.0);    \n    else if(blockType == J_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);     \n    else if(blockType == L_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(0.0, 0.0, 0.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);     \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);    \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0); \n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetB(in float blockType)\n{\n    if(blockType == I_BLOCK)\n    \treturn vec4(0.0, 2.0, 0.0, 3.0);     \n    else if(blockType == J_BLOCK)\n        return vec4(-1.0, 0.0, 1.0, 1.0);    \n    else if(blockType == L_BLOCK)\n        return vec4(-1.0, 0.0, -1.0, 1.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(1.0, 0.0, 1.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, -1.0, 1.0, -1.0);    \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);      \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, -1.0, -1.0, -1.0);\n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);\n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetC(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return vec4(0.0);\n    else if(blockType == J_BLOCK)\n        return vec4(0.0);\n    else if(blockType == L_BLOCK)\n         return vec4(0.0);\n    else if(blockType == O_BLOCK)\n        return vec4(0.0); \n    else if(blockType == S_BLOCK)\n\t\treturn vec4(0.0);\n    else if(blockType == T_BLOCK)\n        return vec4(-2.0, 0.0, 0.0, 0.0);\n    else if(blockType == Z_BLOCK)\n        vec4(0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);\n\treturn vec4(0.0);  \n}\n\nvec3 CheckForUserBlockColor(in vec4 controlledBlockInfo, in vec2 blockInfoCoords, in vec2 localBlockCoords, in float colorType)\n{\n    vec2 position = controlledBlockInfo.xy;\n    float rotation = controlledBlockInfo.z;\n    float blockType = controlledBlockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    \n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n    \n    vec2 c0 = floor(position + collisionSetA.xy);\n    vec2 c1 = floor(position + collisionSetA.zw);\n    vec2 c2 = floor(position + collisionSetB.xy);\n    vec2 c3 = floor(position + collisionSetB.zw);\n    vec2 c4 = floor(position + collisionSetC.xy);\n    vec2 c5 = floor(position + collisionSetC.zw);\n       \n    vec2 blockIndex = floor(vec2((blockInfoCoords.x * fCELLS_WIDE), (blockInfoCoords.y * fCELLS_TALL)));\n    \n#if (MODE == MODIFIED)\n    if((blockIndex == c0) || (blockIndex == c1) || (blockIndex == c2) || (blockIndex == c3) || (blockIndex == c4) || (blockIndex == c5))\n#else\n    if((blockIndex == c0) || (blockIndex == c1) || (blockIndex == c2) || (blockIndex == c3))   \n#endif\n    {\n        return GetColor(colorType, localBlockCoords);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float fieldAspectRatio = float(CELLS_WIDE) / float(CELLS_TALL);\n    const float inverseFieldAspectRatio = 1.0 / fieldAspectRatio;\n   \n    float aspectRatio = (iResolution.x / iResolution.y);\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 uv =  2.0 * screenCoord - 1.0; \n\n    // load game state\n    vec4 gameInfo0 = LoadValue(txGameInfo0);\n    vec4 gameInfo1 = LoadValue(txGameInfo1);\n    vec4 gameInfo2 = LoadValue(txGameInfo2);\n    vec4 controlledBlockInfo0 = LoadValue(txControlledBlockInfo0);\n    vec4 controlledBlockInfo1 = LoadValue(txControlledBlockInfo1);\n    \n    vec3 finalColor = vec3(0.0);\n    \n\t// Blocks\n    vec2 blockInfoCoords = vec2(uv.x * inverseFieldAspectRatio + 0.5, (1.0 - (screenCoord.y - 0.1979)));\n    vec2 localBlockCoords = vec2(blockInfoCoords.x * fCELLS_WIDE, blockInfoCoords.y * fCELLS_TALL);\n    localBlockCoords = (localBlockCoords - floor(localBlockCoords)) * 2.0 - 1.0;\n\n    if((blockInfoCoords.x > 0.0) && (blockInfoCoords.x < 1.0))\n    {   \n        vec2 blockIndex = floor(vec2((blockInfoCoords.x * fCELLS_WIDE), (blockInfoCoords.y * fCELLS_TALL)));\n        vec4 blockInfo = texture(iChannel0, (0.5 + txBlocks.xy + blockIndex) / iChannelResolution[0].xy, -100.0);\n        \n        if(blockInfo.x == 2.0) // hack for a clear block flash\n            finalColor.rgb = GetColor(MAX_BLOCK, localBlockCoords);\n        else if(blockInfo.x == 1.0)\n            finalColor.rgb = GetColor(blockInfo.y + ((blockInfo.x - 1.0) * MAX_BLOCK), localBlockCoords);\n        \n         if(controlledBlockInfo0.w != 0.0) // Player Block\n            finalColor.rgb += CheckForUserBlockColor(controlledBlockInfo0, blockInfoCoords, localBlockCoords, controlledBlockInfo1.w);\n    }\n    else if((blockInfoCoords.x > -0.1) && (blockInfoCoords.x < 1.1))\n    {\n        float gradient = (cos(abs(uv.x) * 110.0));\n        finalColor.rgb = vec3(gradient * gradient * 0.5 + 0.2);\n    }\n    else\n    {\n        finalColor = vec3(screenCoord, 0.5 + 0.5 * sin(iTime)) * 0.33334;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Based on iq's brick game: https://www.shadertoy.com/view/MddGzf\n\n// Modified has unique colors per block and some 5-pieces\n#define MODIFIED 1\n#define CLASSIC 2\n#define MODE MODIFIED\n\n#define RANDOM_COLOR_BLOCKS 1\n\n#if (MODE == MODIFIED)\nconst int CELLS_WIDE = 13;\nconst float NUM_BLOCK_TYPES = 8.0;\n#else\nconst int CELLS_WIDE = 10;\nconst float NUM_BLOCK_TYPES = 7.0;\n#endif\nconst int CELLS_TALL = 24;\n\nconst float fCELLS_WIDE = float(CELLS_WIDE);\nconst float fCELLS_TALL = float(CELLS_TALL);\nconst int HALF_CELLS_WIDE = CELLS_WIDE / 2;\nconst int HALF_CELLS_TALL = CELLS_TALL / 2;\nconst float fHALF_CELLS_WIDE = float(HALF_CELLS_WIDE);\nconst float fHALF_CELLS_TALL = float(HALF_CELLS_TALL);\n\nconst float PI = 3.14159265359;\n\n// Block Types (empty is 0.0)\nconst float I_BLOCK = 1.0;\nconst float J_BLOCK = 2.0;\nconst float L_BLOCK = 3.0;\nconst float O_BLOCK = 4.0;\nconst float S_BLOCK = 5.0;\nconst float T_BLOCK = 6.0;\nconst float Z_BLOCK = 7.0;\nconst float PLUS_BLOCK = 8.0;\n\n// storage register/texel addresses\nconst vec2 txGameInfo0      \t\t= vec2(0.0, 0.0); // x = game state, y = time in current state, z = time till next spin, time till next move\nconst vec2 txGameInfo1 \t    \t\t= vec2(1.0, 0.0); // x = score, y = lines cleared, z = highScore, w = drop speed\nconst vec2 txGameInfo2 \t    \t\t= vec2(2.0, 0.0); // x = current test row, y = destory/copy row, z = next block type, w = current multipler\nconst vec2 txControlledBlockInfo0 \t= vec2(3.0, 0.0); // xy = position, z = rotation, w = block type\nconst vec2 txControlledBlockInfo1 \t= vec2(4.0, 0.0); // x = time till drop, y = next block type, z = space released, w = block color\nconst vec4 txBlocks \t\t\t\t= vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));  // x = taken, y = color, z = destory, w = time till death\n\n// Keys\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_E     = 69.5/256.0;\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) { vec2 d = abs(p - 0.5 - c) - 0.5; return -max(d.x, d.y); }\nfloat IsInside(in vec2 p, in vec4 c) { vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; return -max(d.x, d.y); }\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nfloat GetRandomBlock(in float seed)\n{\n    vec3 value = texture(iChannel2, seed * iTime * vec2(12.9898, 78.233 + iTime)).rgb;\n    return floor(mod((value.x + value.y * 7.13 + value.z * 131.0), NUM_BLOCK_TYPES) + 1.0);\n}\n\nvec4 GetBlockInfo(in vec2 blockPosition)\n{  \n    return LoadValue(txBlocks.xy + blockPosition);\n}\n\nbool IsCellValid(in vec2 blockPosition)\n{\n\tbool blockOutOfBounds = (blockPosition.x < 0.0 || blockPosition.x >= (fCELLS_WIDE - 0.1) \n                            || blockPosition.y < 0.0 || blockPosition.y >= (fCELLS_TALL - 0.1)); \n                             \n    return blockOutOfBounds || (GetBlockInfo(blockPosition).x != 0.0) || (GetBlockInfo(blockPosition).y != 0.0);    \n}\n\nvec4 GetCollisionSetA(in float blockType)\n{\n    if(blockType == I_BLOCK)\n   \t\treturn vec4(0.0, 0.0, 0.0, 1.0);    \n    else if(blockType == J_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);     \n    else if(blockType == L_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(0.0, 0.0, 0.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);     \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);    \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0); \n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetB(in float blockType)\n{\n    if(blockType == I_BLOCK)\n    \treturn vec4(0.0, 2.0, 0.0, 3.0);     \n    else if(blockType == J_BLOCK)\n        return vec4(-1.0, 0.0, 1.0, 1.0);    \n    else if(blockType == L_BLOCK)\n        return vec4(-1.0, 0.0, -1.0, 1.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(1.0, 0.0, 1.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, -1.0, 1.0, -1.0);    \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);      \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, -1.0, -1.0, -1.0);\n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);\n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetC(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return vec4(0.0);\n    else if(blockType == J_BLOCK)\n        return vec4(0.0);\n    else if(blockType == L_BLOCK)\n         return vec4(0.0);\n    else if(blockType == O_BLOCK)\n        return vec4(0.0); \n    else if(blockType == S_BLOCK)\n\t\treturn vec4(0.0);\n    else if(blockType == T_BLOCK)\n        return vec4(-2.0, 0.0, 0.0, 0.0);\n    else if(blockType == Z_BLOCK)\n        vec4(0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);\n\treturn vec4(0.0);  \n}\n\nbool CheckForBlockCollisions(in vec4 blockInfo)\n{\n    // Get the collision offsets for whatever the blocktype is \n    bool hasCollided = false;\n    \n    vec2 position = blockInfo.xy;\n    float rotation = blockInfo.z;\n    float blockType = blockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    // O_BLOCK doesn't need to rotate\n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n    vec2 c0 = position + collisionSetA.xy;\n    vec2 c1 = position + collisionSetA.zw;\n    vec2 c2 = position + collisionSetB.xy;\n    vec2 c3 = position + collisionSetB.zw;\n    vec2 c4 = position + collisionSetC.xy;\n    vec2 c5 = position + collisionSetC.zw;\n    \n#if (MODE == MODIFIED)\n    hasCollided = IsCellValid(c0) || IsCellValid(c1) || IsCellValid(c2) || IsCellValid(c3) || IsCellValid(c4) || IsCellValid(c5);\n#else\n    hasCollided = IsCellValid(c0) || IsCellValid(c1) || IsCellValid(c2) || IsCellValid(c3);\n#endif\n    \n    return hasCollided;\n}\n\nvoid PlaceBlock(in vec4 playerBlockInfo, in vec2 targetCellIndex, inout vec4 targetCellInfo, in float colorType)\n{\n    // Very similar to the CheckForBlockCollisions function except we need to update some user data and update block info of the target cells\n    vec2 position = playerBlockInfo.xy;\n    float rotation = playerBlockInfo.z;\n    float blockType = playerBlockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    // O_BLOCK doesn't need to rotate\n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n     \n    vec2 c0 = position + collisionSetA.xy;\n    vec2 c1 = position + collisionSetA.zw;\n    vec2 c2 = position + collisionSetB.xy;\n    vec2 c3 = position + collisionSetB.zw;\n    vec2 c4 = position + collisionSetC.xy;\n    vec2 c5 = position + collisionSetC.zw;\n    \n#if (MODE == MODIFIED)\n    if((c0 == targetCellIndex) || (c1 == targetCellIndex) || (c2 == targetCellIndex) || (c3 == targetCellIndex) || (c4 == targetCellIndex) || (c5 == targetCellIndex))\n#else\n    if((c0 == targetCellIndex) || (c1 == targetCellIndex) || (c2 == targetCellIndex) || (c3 == targetCellIndex))   \n#endif\n    {\n        targetCellInfo = vec4(1.0, colorType, 0.0, 0.0);\n    }\n}\n\n// Each block type spawns at a different height, this is so it only takes a single drop update\n// for the block to appear in the playing field\nfloat GetStartingHeight(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return 0.0;\n    else if(blockType == J_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == L_BLOCK)\n    \treturn 2.0;\n    else if(blockType == O_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == S_BLOCK)\n    \treturn 3.0;\n    else if(blockType == T_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == Z_BLOCK)\n    \treturn 3.0;\n    else if(blockType == PLUS_BLOCK)\n    \treturn 2.0;\n    return 0.0;\n}\n\nfloat CalculateDropSpeed(in float linesCleared)\n{\n\treturn max(0.5 - min(floor((linesCleared) * 0.2) * 0.09, 1.9), 0.005);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute gameplay outside of the data area\n    if(fragCoord.x > fCELLS_WIDE || fragCoord.y > (1.0 + fCELLS_TALL)) discard;\n\n    // load game state\n    vec4 gameInfo0 = LoadValue(txGameInfo0);\n    vec4 gameInfo1 = LoadValue(txGameInfo1);\n    vec4 gameInfo2 = LoadValue(txGameInfo2);\n    vec4 controlledBlockInfo0 = LoadValue(txControlledBlockInfo0);\n    vec4 controlledBlockInfo1 = LoadValue(txControlledBlockInfo1);\n    vec4 blockInfo = LoadValue(fragCoord.xy - 0.5);\n    vec2 blockIndex = floor(vec2(fragCoord.x, fragCoord.y - 1.0));\n\n    // reset buffer A on frame 0\n\tif(iFrame == 0) gameInfo0 = vec4(-1.0, 0.0, 0.0, 0.0);\n    \n    if(gameInfo0.x == -1.0) // reset state\n    { \n        gameInfo0 = vec4(0.0, 0.0, 0.0, 0.0);\n        gameInfo1 = vec4(0.0, 0.0, 10000.0, CalculateDropSpeed(0.0));\n #if (MODE == MODIFIED)\n        gameInfo2 = vec4(0.0, 0.0, GetRandomBlock(1.0), 0.0);\n #else\n        gameInfo2 = vec4(0.0, 0.0, GetRandomBlock(1.0), 0.0);\n #endif\n        controlledBlockInfo0 = vec4(0.0);\n        controlledBlockInfo1 = vec4(0.0, 0.0, 0.0, gameInfo2.z);\n        blockInfo = vec4(0.0);\n    }\n    else if(gameInfo0.x == 0.0) // title state\n    {\n    \tgameInfo0 = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    else if(gameInfo0.x == 1.0) // normal gameplay state\n    {\n        if(controlledBlockInfo0.w == 0.0) // current block type is invalid so get a new block\n        {\n            controlledBlockInfo0 = vec4(fHALF_CELLS_WIDE, GetStartingHeight(gameInfo2.z), 0.0, gameInfo2.z);        \n            controlledBlockInfo1.x = gameInfo1.w;\n#if (MODE == MODIFIED) && RANDOM_COLOR_BLOCKS\n        \tcontrolledBlockInfo1.w = GetRandomBlock(2.0);\n#else \n            controlledBlockInfo1.w =  gameInfo2.z;\n#endif\n            gameInfo2.z = GetRandomBlock(1.0);\n        }\n        else\n        {\n            if(controlledBlockInfo1.x <= 0.0) // Drop block and check for collisions\n            {\n                vec4 futureControlledBlockInfo0 = controlledBlockInfo0;\n                futureControlledBlockInfo0.y += 1.0;\n\n                bool blockCollided = CheckForBlockCollisions(futureControlledBlockInfo0);\n                if(blockCollided)\n                {\n                    PlaceBlock(controlledBlockInfo0, blockIndex, blockInfo, controlledBlockInfo1.w);\n                    controlledBlockInfo0.w = 0.0; // set user control block type to invalid\n\n                    // Move to row completion check\n                    gameInfo0.x = 2.0;\n                    gameInfo2.xy = vec2(fCELLS_TALL, -1.0);\n                }\n                else\n                {\n                    controlledBlockInfo0.y += 1.0;\n                    controlledBlockInfo1.x = gameInfo1.w;\n                }\n            }\n            else\n            {\n                bool moveWasMade = false;\n                vec4 potentialMoveData = controlledBlockInfo0;\n\n                if(gameInfo0.z <= 0.0) // Rotation\n                {\n                    float rotateCW = texture(iChannel1, vec2(KEY_SPACE, 0.25)).x + texture(iChannel1, vec2(KEY_Q, 0.25)).x;\n                    if(rotateCW > 0.5)\n                    {\n                        potentialMoveData.z -= 1.0;\n                        if(potentialMoveData.z <= -1.0)\n                            potentialMoveData.z = 3.0;    \n                        moveWasMade = true;\n                    }\n                    float rotateCCW = texture(iChannel1, vec2(KEY_UP, 0.25)).x + texture(iChannel1, vec2(KEY_E, 0.25)).x;\n                    if(rotateCCW > 0.5)\n                    {\n                        potentialMoveData.z += 1.0;\n                        if(potentialMoveData.z >= 4.0)\n                            potentialMoveData.z = 0.0;    \n                        moveWasMade = true;\n                    }\n                    gameInfo0.z = 0.1;\n                }\n\n                if(gameInfo0.w <= 0.0) // Movement\n                {\n                    float pressLeft = texture(iChannel1, vec2(KEY_LEFT, 0.25)).x;\n                    float pressRight = texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x;\n                    float pressDown = texture(iChannel1, vec2(KEY_DOWN, 0.25)).x;\n                    \n                    if(pressLeft > 0.5)\n                    {\n                        potentialMoveData.x -= 1.0;\n                        moveWasMade = true;\n                    }\n                    if(pressRight > 0.5)\n                    {\n                        potentialMoveData.x += 1.0;\n                        moveWasMade = true;\n                    }\n                    \n                    if(pressDown > 0.5)\n                    {\n                        potentialMoveData.y += 1.0;\n                        moveWasMade = true;\n                    }\n                    gameInfo0.w = 0.05;\n                }\n                \n                if(CheckForBlockCollisions(potentialMoveData) == false) // Determine if the move was valid\n                {\n                    if(potentialMoveData.y > controlledBlockInfo0.y) // if it was a downwards move reset the drop timer\n                        controlledBlockInfo1.x = gameInfo1.w;\n                    controlledBlockInfo0 = potentialMoveData;             \n                }\n\n                controlledBlockInfo1.x -= iTimeDelta; // time till next drop\n                gameInfo0.z -= iTimeDelta; // time till next rotation available\n                gameInfo0.w -= iTimeDelta; // time till next movement available\n            }\n        }\n\t} \n    else if(gameInfo0.x == 2.0) // check for completed rows\n    {\n        bool completedRow = true;\n        \n        for(int i = 0; i < CELLS_WIDE; ++i)\n        {\n            vec2 testCoords = vec2(float(i), gameInfo2.x);\n            if(LoadValue(testCoords).x == 0.0)\n            {\n                completedRow = false;\n                break;\n            }\n        }\n        \n        if(completedRow)\n        {        \n           \tgameInfo2.w++; // increase multipler\n            gameInfo0.x = 3.0; // delete row phase\n            gameInfo2.y = gameInfo2.x; // set the delete row to the test row\n            \n            if(blockIndex.y == floor(gameInfo2.x - 1.0))\n                blockInfo.x = 2.0;\n        }\n        else\n        {  \n            // advance to next row\n            gameInfo2.x--;\n            if(gameInfo2.x < 1.0) // no rows completed\n            {\n                // calculate score\n                float stage = floor(gameInfo1.y * 0.2);\n                gameInfo1.x += min((gameInfo2.w * gameInfo2.w * 100.0) - 100.0, 100.0) * (stage);\n                gameInfo1.y += gameInfo2.w; // increase completed row count\n                \n                // Do a quick check for a game over state\n                bool isGameOver = false;\n                for(int i = 0; i < CELLS_WIDE; ++i)\n                {\n                    vec2 testCoords = vec2(float(i), 3.0);\n                    if(LoadValue(testCoords).x == 1.0)\n                    {\n                        isGameOver = true;\n                        break;\n                    }\n                }\n                \n                if(isGameOver)\n                {\n                    gameInfo0.x = 5.0;\t\n                }\n                else\n                {\n                    // reset back to normal gameplay\n                    gameInfo2.w = 0.0;\n                    gameInfo0.x = 1.0;\t\n                    gameInfo2.x = 0.0;\n                    gameInfo1.w = CalculateDropSpeed(gameInfo1.y);\n                    controlledBlockInfo1.x = gameInfo1.w;\n                }\n            }\n        }\n    }\n    else if(gameInfo0.x == 3.0) // delete rows\n    {\n\t\tif(blockIndex.y == (gameInfo2.x - 1.0))\n        {\n            blockInfo = vec4(0.0); // clear this block\n            gameInfo2.x = clamp(gameInfo2.x + 1.0, -1.0, fCELLS_TALL); // go back down a row      \n        }\n        gameInfo0.x = 4.0; // move down rows\n    }\n    else if(gameInfo0.x == 4.0) // move down rows\n    {\n        if(blockIndex.y < gameInfo2.x && blockIndex.y != 0.0)\n        {\n        \t// copy the value of the block above it\n            vec4 aboveBlockInfo = LoadValue(vec2(fragCoord.x - 0.5, fragCoord.y - 0.5 - 1.0));\n            blockInfo = aboveBlockInfo;          \n        }\n        gameInfo0.x = 2.0; // go back to checking rows\n    }\n    else if(gameInfo0.x == 5.0) // game over state\n    {\n    \t// Add a reset?\n       \tfloat anyKeyPressed = texture(iChannel1, vec2(KEY_SPACE, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_Q, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_UP, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_E, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_LEFT, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_DOWN, 0.25)).x;\n        \n       \tif(anyKeyPressed > 0.5)\n       \t{\n       \t\tgameInfo0 = vec4(-1.0, 0.0, 0.0, 0.0);\n       \t}    \n    }\n    gameInfo0.y += iTimeDelta;\n    \n\t// store game state\n    fragColor = vec4(0.0);\n \n    StoreValue(txGameInfo0, gameInfo0, fragColor, fragCoord);\n    StoreValue(txGameInfo1, gameInfo1, fragColor, fragCoord);\n    StoreValue(txGameInfo2, gameInfo2, fragColor, fragCoord); \n    StoreValue(txControlledBlockInfo0, controlledBlockInfo0, fragColor, fragCoord);\n    StoreValue(txControlledBlockInfo1, controlledBlockInfo1, fragColor, fragCoord);\n   \tStoreValue(txBlocks, blockInfo, fragColor, fragCoord);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4ltGD8",
    "date": "1708400582",
    "viewed": 285,
    "name": "Bomberman",
    "description": "Bomberman\nInitially wrote this about ~8 years ago but never finished it. Spent some time recently cleaning it up and figured I'd make it public despite some remaining issues. \nControls:\nPlayer0: Arrows+Space\nPlayer1: WASD+Q\nPlayer2: IJKL+U\nPlayer3: GVBN+F",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "game",
     "sdf",
     "sprite",
     "multipass",
     "bomberman"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4d33Dj",
       "filepath": "https://soundcloud.com/junechikuma/june-chikuma-nes-bomberman",
       "type": "musicstream",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Post\n// See Buffer C for additional visual settings\n\n// References:\n// [SH16C] Contra by knarkowicz    - https://www.shadertoy.com/view/XltGDr\n// CRT Effect by Jasper \t\t   - https://www.shadertoy.com/view/4sf3Dr\n// FixingPixelArt by TimothyLottes - https://www.shadertoy.com/view/XsjSzR\n\n//////////////////////////////////////////////////\n// Post Settings\n#define POST_EFFECTS  \t1\n#define CRT_CURVATURE \t1\n#define SCANLINES\t\t1\n\n//////////////////////////////////////////////////\n// Debugging Settings\n#define DISPLAY_SPRITE_SHEET 0\n\n//////////////////////////////////////////////////\n// Helpers\nvec2 CRTCurvature(in vec2 uv, in float strength)\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = (strength * abs(uv.yx)) * vec2(0.3334, 0.5);\n    uv = uv + uv * offset * offset;\n    return Saturate(uv * 0.5 + 0.5);\n}\n\nfloat Scanline(in float position)\n{\n    return sin((position * iResolution.y * 2.0)) * 0.1;\n}\n\n//////////////////////////////////////////////////\n// Implementation \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if POST_EFFECTS    \n\n#if CRT_CURVATURE    \n    vec2 gameUV = CRTCurvature(uv, 0.425);\n#else\n    vec2 gameUV = uv;\n#endif       \n    vec4 gameColor = texture(iChannel0, gameUV);\n   \n    float vignette = (gameUV.x * gameUV.y * (1.0 - gameUV.x) * (1.0 - gameUV.y));\n    vignette = Saturate(pow(16.0 * vignette, 0.3));\n\n    const float k_brightness = 1.5;  \n    vec3 finalColor = (gameColor.rgb * vignette * k_brightness);\n#if SCANLINES\n    finalColor = finalColor - Scanline(gameUV.y);\n#endif // SCANLINES\n\n#else    \n    vec4 gameColor = texture(iChannel0, uv);\n#endif // POST_EFFECTS    \n        \n#if DISPLAY_SPRITE_SHEET    \n    const int k_spriteIndex = 0;\n    vec4 spriteSheetColor = texture(iChannel1, (uv * 16.0 + vec2(float(k_spriteIndex) * 16.0, 0.0)) / iChannelResolution[1].xy);\n    finalColor = spriteSheetColor.rgb;\n#endif\n\n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Game state and gameplay\n\n//////////////////////////////////////////////////\n// Constants\nconst float BOMB_FUSE_TIME = 3.0; // 3 seconds\nconst float BOMB_EXPLOSION_TIME = 1.0;\nconst uint MAX_BOMB_LEVEL = 4U;\nconst uint MAX_FLAME_LEVEL = 19U;\nconst uint MAX_SKATE_LEVEL = 7U;\n\n// Facing Direction\nconst float DIRECTION_UP \t= 0.0;\nconst float DIRECTION_DOWN \t= 1.0;\nconst float DIRECTION_RIGHT = 2.0;\nconst float DIRECTION_LEFT \t= 3.0;\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\n// Same as LoadValueBufferA but with bound checking\nvec4 LoadTileValueBufferA(in vec2 re)\n{\n    if ((re.x >= txPlayField.x) && (re.y >= txPlayField.y) && (re.x <= txPlayField.z) && (re.y <= txPlayField.w - 1.0))\n    {\n    \treturn LoadValueBufferA(re);\n    }\n    return vec4(0.0);\n}\n\nvec4 LoadValueBufferB(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\n////////////////////////////////////////////////////////\n// Random\nfloat GetRandomValue(in float seed, in int startValue, in int range)\n{\n    vec3 value = texture(iChannel3, seed * (iTime + 1.0) * vec2(12.9898, 78.233 + iTime)).rgb;\n    return floor(mod((value.x + value.y * 7.13 + value.z * 131.0), float(range)) + float(startValue));    \n}\n\nfloat GetRandomStartingBlock(in vec2 tileIndex)\n{\n\treturn clamp(GetRandomValue(tileIndex.x + tileIndex.y * float(CELLS_WIDE), -5, 6), float(BREAKABLE_BLOCK), float(FREE_SPACE));   \n}\n\nfloat GetRandomPowerup(in vec2 tileIndex)\n{\n\treturn clamp(GetRandomValue(tileIndex.x + tileIndex.y * float(CELLS_WIDE), FREE_SPACE, FLAME_POWER_UP + 2), float(FREE_SPACE), float(FLAME_POWER_UP));   \n}\n\n////////////////////////////////////////////////////////\n// Tiles\nvec4 GetTileInfo(in vec2 tileIndex)\n{\n\treturn LoadValueBufferA(txPlayField.xy + tileIndex);\n}\n\nbool IsFreeTile(in int tileType)\n{\n    return ((tileType >= FREE_SPACE) && (tileType < BOMB));\n}\n\nvec4 ResetTile(vec2 tileIndex)\n{\n    float tileType = float(UNBREAKABLE_BLOCK); // Initially set all blocks as unbreakble\n\n    // Set random free blocks, breakable ect\n    if (((mod(tileIndex.x, 2.0) != 0.0) && (mod(tileIndex.y, 2.0) != 0.0)) == false)\n    {\n        tileType = GetRandomStartingBlock(tileIndex);\n    }\n\n    // Clear out space near the corners\n    if (length((tileIndex - vec2(7.0, 6.0))) > 8.25)\n    {\n        tileType = float(FREE_SPACE);\n    }\n    return vec4(tileType, 0.0, 0.0, 0.0f);\n}\n\n////////////////////////////////////////////////////////\n// Bomberman\nstruct BombSlots\n{\n    vec2    mBombTile0;\n    vec2    mBombTile1;\n    vec2    mBombTile2;\n    vec2    mBombTile3;\n};\n\nstruct Bomberman\n{\n\tvec2 \t\tmPosition;\n    float   \tmDirection;\n    float \t\tmAnimation;\n    \n    BombSlots \tmBombSlots;\n    \n    // Could pack these together\n    uint \t\tmBombLevel;  \n    uint \t\tmFlameLevel;\n    uint \t\tmSkateLevel;   \t\n    \n    uint \t\tmCurrentBombFreeSlot;\n    uint\t   \tmCurrentBombCount;\n};\n    \nBomberman gBomberman0;\nBomberman gBomberman1;\nBomberman gBomberman2;\nBomberman gBomberman3;\n     \n#define ResetBombSlots BombSlots(vec2(-1.0), vec2(-1.0), vec2(-1.0), vec2(-1.0))\n#define CreateDefaultBomberman(position, direction) Bomberman(position, direction, 0., ResetBombSlots, 1U, 2U, 1U, 0U, 0U)    \n\nvec2 ConvertPackedFloatToVec2(in float x)\n{\n    return vec2(mod(x, 100.0), floor(x * 0.01));\n}\n\nfloat ConvertVec2ToPackedFloat(in vec2 v)\n{\n    return (v.x + v.y * 100.0);\n}\n\nBomberman LoadBomberman(in vec2 re)\n{\n    vec4 bombermanInfo0 = LoadValueBufferA(re);\n    vec4 bombermanInfo1 = LoadValueBufferA(re + vec2(1.0, 0.0));\n    vec4 bombermanInfo2 = LoadValueBufferA(re + vec2(2.0, 0.0));\n    \n    vec2 bomb0Location = ConvertPackedFloatToVec2(bombermanInfo1.w); \n    vec2 bomb1Location = ConvertPackedFloatToVec2(bombermanInfo2.x); \n    vec2 bomb2Location = ConvertPackedFloatToVec2(bombermanInfo2.y); \n    vec2 bomb3Location = ConvertPackedFloatToVec2(bombermanInfo2.z); \n    \n    uint currentBombCount = 4U;\n    uint currentBombFreeSlot = 0U;\n    \n    bool bombTile0 = (bomb0Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb0Location).x) == BOMB);\n    bool bombTile1 = (bomb1Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb1Location).x) == BOMB);\n    bool bombTile2 = (bomb2Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb2Location).x) == BOMB);\n    bool bombTile3 = (bomb3Location.x != -1.0) && (int(LoadValueBufferA(txPlayField.xy + bomb3Location).x) == BOMB);\n\n    if (bombTile3 == false)\n    {\n        currentBombFreeSlot = 3U;\n        bomb3Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n    \n    if (bombTile2 == false)\n    {\n        currentBombFreeSlot = 2U;\n        bomb2Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n\n    if (bombTile1 == false)\n    {\n        currentBombFreeSlot = 1U;\n        bomb1Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n\n    if (bombTile0 == false)\n    {\n        currentBombFreeSlot = 0U;\n        bomb0Location = vec2(-1.0);\n        currentBombCount -= 1U;\n    }\n    \n    return Bomberman(bombermanInfo0.xy, // position \n                     bombermanInfo0.z, // direction \n                     bombermanInfo0.w, // animation\n                     // bomb locations\n       \t\t\t     BombSlots(bomb0Location, bomb1Location, bomb2Location, bomb3Location),\n                     uint(bombermanInfo1.x), // bomb level\n                     uint(bombermanInfo1.y), // flame level \n                     uint(bombermanInfo1.z), // skate level\n                     // extra bomb info\n                     currentBombFreeSlot, currentBombCount);\n}\n\nvoid StoreBomberman(in vec2 re, in Bomberman b, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 bombermanInfo0 = vec4(b.mPosition, b.mDirection, b.mAnimation);  \n    vec4 bombermanInfo1 = vec4(b.mBombLevel, b.mFlameLevel, b.mSkateLevel, ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile0));\n    vec4 bombermanInfo2 = vec4(ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile1), ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile2),\n                               ConvertVec2ToPackedFloat(b.mBombSlots.mBombTile3), 0.0);\n\n    StoreValue(re, bombermanInfo0, fragColor, fragCoord);\n    StoreValue(re + vec2(1.0, 0.0), bombermanInfo1, fragColor, fragCoord);\n    StoreValue(re + vec2(2.0, 0.0), bombermanInfo2, fragColor, fragCoord);\n}\n\n////////////////////////////////////////////////////////\n// Inputs\nstruct BombermanInput\n{\n    float mHorizontalMovement;\n\tfloat mVerticalMovement;\n    bool  mPlaceBomb;\n    float mLastBombTime;\n};\n\nBombermanInput gBomberman0Inputs;\nBombermanInput gBomberman1Inputs;\nBombermanInput gBomberman2Inputs;\nBombermanInput gBomberman3Inputs;\n\n////////////////////////////////////////////////////////\n// Gameplay\nbool CheckIfValidMove(in vec2 position, in vec2 movementDirection)\n{\n    vec2 normalizedMovementDirection = normalize(movementDirection);\n    vec4 currentTile = GetTileInfo(position);\n    vec2 targetPosition = position + movementDirection;\n    \n    vec2 targetTile = (position + normalizedMovementDirection);\n    \n    if ((targetPosition.x >= -0.25) && (targetPosition.x < float(CELLS_WIDE) - 0.5) \n\t\t&& (targetPosition.y >= -0.25) && (targetPosition.y < float(CELLS_TALL) - 0.5)) \n    {\n    \treturn (IsFreeTile(int(GetTileInfo(targetTile).x)) || IsFreeTile(int(GetTileInfo(targetPosition).x)));\n    }\n    return false;    \n}\n\nvoid HandleMovementInput(inout vec2 position, out float direction, inout float animation, in uint skateLevel, in BombermanInput inputs)\n{\n    const float k_defaultBombermanSpeed = 2.4;\n    const float k_speedIncreaseRate = 0.5;\n    \n    float bombermanSpeed = (k_defaultBombermanSpeed + (float(skateLevel) * k_speedIncreaseRate)) * iTimeDelta;\n\n    float xMovement = bombermanSpeed * inputs.mHorizontalMovement;\n    if ((xMovement != 0.0) && CheckIfValidMove(position, vec2(xMovement, 0.0)))\n    {\n        position.x += xMovement;\n        direction = (xMovement > 0.0) ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    } \n\n    float yMovement = bombermanSpeed * inputs.mVerticalMovement;\n    if ((yMovement != 0.0) && CheckIfValidMove(position, vec2(0.0, yMovement)))\n    {\n    \tposition.y += yMovement;\n        direction = (yMovement > 0.0) ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n    \n    const float k_walkAnimationLength = 40.0;\n    animation = ((xMovement + yMovement) != 0.0) ? (mod(animation + 1.0, k_walkAnimationLength)) : (animation += -sign(animation));\n}\n\nvoid UpdateBombSlot(inout BombSlots bombSlots, in vec2 tileIndex, in uint freeSlot)\n{\n    if (freeSlot == 0U)\n    {\n        bombSlots.mBombTile0 = tileIndex;\n    }\n    else if (freeSlot == 1U)\n    {\n        bombSlots.mBombTile1 = tileIndex;\n    }\n    else if (freeSlot == 2U)\n    {\n        bombSlots.mBombTile2 = tileIndex;\n    }\n    else if (freeSlot == 3U)\n    {\n        bombSlots.mBombTile3 = tileIndex;\n    }\n}\n\nvoid UpdateBombermanTile(inout vec4 tileInfo, in uint flameLevel, in bool placeBomb, in bool canPlaceBomb)\n{\n    int tileType = int(tileInfo.x);\n    if (canPlaceBomb && (tileType == FREE_SPACE) && placeBomb)\n    {\n        tileInfo.x = float(BOMB);\n        tileInfo.y = BOMB_FUSE_TIME;\n        tileInfo.z = float(EXPLOSION_DIRECTION_ALL);\n        \n        float floatFlameLevel = float(flameLevel);\n        tileInfo.w = floatFlameLevel;\n    }\n    else if ((tileType == BOMB_POWER_UP) || (tileType == FLAME_POWER_UP) || (tileType == SKATE_POWER_UP))\n    {\n        tileInfo.x = float(FREE_SPACE);\n        tileInfo.z = 0.0;\n    }   \n}\n\nvoid UpdateBomberman(inout Bomberman bomberman, inout vec4 tileInfo, in BombermanInput inputs)\n{         \n    vec2 bombermanTileIndex = GetTileIndex(ConvertTileCoordsToScreenUV(bomberman.mPosition.xy));\n    vec4 bombermanTileInfo = LoadValueBufferA(txPlayField.xy + bombermanTileIndex);\n\tint tileType = int(bombermanTileInfo.x);   \n    \n    bomberman.mBombLevel = min(bomberman.mBombLevel + ((tileType == BOMB_POWER_UP) ? 1U : 0U), MAX_BOMB_LEVEL);\n    bomberman.mFlameLevel = min(bomberman.mFlameLevel + ((tileType == FLAME_POWER_UP) ? 1U : 0U), MAX_FLAME_LEVEL);\n    bomberman.mSkateLevel = min(bomberman.mSkateLevel + ((tileType == SKATE_POWER_UP) ? 1U : 0U), MAX_SKATE_LEVEL);\n    bomberman.mPosition = (tileType == EXPLOSION) ? vec2(-100.0) : bomberman.mPosition;\n    \n    if ((tileType == FREE_SPACE) && (bomberman.mCurrentBombCount < bomberman.mBombLevel) && inputs.mPlaceBomb)\n    {\n        UpdateBombSlot(bomberman.mBombSlots, bombermanTileIndex, bomberman.mCurrentBombFreeSlot);\n    }   \n    HandleMovementInput(bomberman.mPosition, bomberman.mDirection, bomberman.mAnimation, bomberman.mSkateLevel, inputs);\n}\n\nBombermanInput LoadInputs(in vec2 re)\n{\n    vec4 inputs = LoadValueBufferB(re).xyzw;    \n    return BombermanInput(inputs.x, inputs.y, (inputs.z > 0.0), inputs.w);\n}\n\n//////////////////////////////////////////////////\n// Implementation \nvoid UpdateTile(inout vec4 tileInfo, in vec4 comparisionTile, in uint explosionDirection, in bool isBomb, in bool isBreakableBlock)\n{\n    if ((int(comparisionTile.x) == EXPLOSION) \n        && (comparisionTile.w > 0.0)\n        && ((uint(comparisionTile.z) == EXPLOSION_DIRECTION_ALL) \n        || (uint(comparisionTile.z) == explosionDirection)))\n    {\n        tileInfo.w = isBomb ? tileInfo.w : (isBreakableBlock ? 0.0 : comparisionTile.w - 1.0);\n        tileInfo.x = isBreakableBlock ? float(COLLAPSING_BLOCK) : float(EXPLOSION);\n        tileInfo.y = isBomb ? BOMB_EXPLOSION_TIME : ((int(tileInfo.x) == EXPLOSION) ? max(tileInfo.y, comparisionTile.y) : (comparisionTile.y - iTimeDelta));              \n        tileInfo.z = isBomb ? float(EXPLOSION_DIRECTION_ALL) : float(explosionDirection);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Don't compute gameplay outside of the data area\n    if ((fragCoord.x > float(CELLS_WIDE)) || (fragCoord.y > float(CELLS_TALL + 1U))) discard;\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    float timeInMode = iTime - gameInfo.z;\n    \n    float previousGameMode = gameInfo.x;\n    \n    gBomberman0 = LoadBomberman(txBomberman0Info);\n    gBomberman1 = LoadBomberman(txBomberman1Info);\n    gBomberman2 = LoadBomberman(txBomberman2Info);\n    gBomberman3 = LoadBomberman(txBomberman3Info);\n     \n    vec4 tileInfo = LoadValueBufferA(fragCoord.xy - 0.5);\n    vec2 tileIndex = floor(vec2(fragCoord.x, fragCoord.y - 1.0));\n           \n    if (gameInfo.x == MODE_MATCH_RESET)\n    { \n        tileInfo = ResetTile(tileIndex);\n        \n        gBomberman0 = CreateDefaultBomberman(vec2(0.0), DIRECTION_UP);\n        gBomberman1 = CreateDefaultBomberman(vec2(float(CELLS_WIDE - 1U), float(CELLS_TALL - 1U)), DIRECTION_DOWN);\n        gBomberman2 = CreateDefaultBomberman(vec2(0.0, float(CELLS_TALL - 1U)), DIRECTION_DOWN);\n        gBomberman3 = CreateDefaultBomberman(vec2(float(CELLS_WIDE - 1U), 0.0), DIRECTION_UP);\n                \n        gameInfo.x = MODE_GAMEPLAY;\n    }\n    else if (gameInfo.x == MODE_GAMEPLAY)\n    {              \n        uint aliveCount = 0U;\n                \n        if (IsBombermanAlive(gBomberman0.mPosition.x))\n        {\n            aliveCount += 1U;           \n            bool isBombermanTile = (floor(gBomberman0.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman0Inputs = LoadInputs(txBomberman0Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman0.mFlameLevel, gBomberman0Inputs.mPlaceBomb, (gBomberman0.mCurrentBombCount < gBomberman0.mBombLevel));\n            }\n            UpdateBomberman(gBomberman0, tileInfo, gBomberman0Inputs);\n        }\n         \n        if (IsBombermanAlive(gBomberman1.mPosition.x))\n        {\n            aliveCount += 1U;   \n            bool isBombermanTile = (floor(gBomberman1.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman1Inputs = LoadInputs(txBomberman1Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman1.mFlameLevel, gBomberman1Inputs.mPlaceBomb, (gBomberman1.mCurrentBombCount < gBomberman1.mBombLevel));\n            }\n            UpdateBomberman(gBomberman1, tileInfo, gBomberman1Inputs);\n        }\n        \n        if (IsBombermanAlive(gBomberman2.mPosition.x))\n        {\n            aliveCount += 1U;   \n            bool isBombermanTile = (floor(gBomberman2.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman2Inputs = LoadInputs(txBomberman2Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman2.mFlameLevel, gBomberman2Inputs.mPlaceBomb, (gBomberman2.mCurrentBombCount < gBomberman2.mBombLevel));\n            }\n            UpdateBomberman(gBomberman2, tileInfo, gBomberman2Inputs);\n        }\n        \n        if (IsBombermanAlive(gBomberman3.mPosition.x))\n        {\n            aliveCount += 1U;    \n            bool isBombermanTile = (floor(gBomberman3.mPosition + vec2(0.5)) == tileIndex);\n            \n            gBomberman3Inputs = LoadInputs(txBomberman3Command);\n            if (isBombermanTile)\n            {\n                UpdateBombermanTile(tileInfo, gBomberman3.mFlameLevel, gBomberman3Inputs.mPlaceBomb, (gBomberman3.mCurrentBombCount < gBomberman3.mBombLevel));\n            }\n            UpdateBomberman(gBomberman3, tileInfo, gBomberman3Inputs);\n        }\n        \n        // End the match if only one player remains\n        gameInfo.x = (aliveCount <= 1U) ? MODE_MATCH_OVER : gameInfo.x;\n        \n        int currentTileType = int(tileInfo.x);\n        \n        if (currentTileType != UNBREAKABLE_BLOCK)\n        {\n            // Update Tiles\n            vec4 leftTileInfo  = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(-1.0, 0.0));\n            vec4 rightTileInfo = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(1.0, 0.0));\n            vec4 upTileInfo    = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(0.0, -1.0));\n            vec4 downTileInfo  = LoadTileValueBufferA(fragCoord.xy - 0.5 + vec2(0.0, 1.0));     \n            \n            bool isBreakableBlock = (currentTileType == BREAKABLE_BLOCK);\n            bool isExplosion = (currentTileType == EXPLOSION) || (currentTileType == COLLAPSING_BLOCK);\n            bool isCollapsingBlock = (currentTileType == COLLAPSING_BLOCK);\n            bool isBomb = (currentTileType == BOMB);\n\n            float previousExplosionType = 0.0;\n            if (isExplosion || isCollapsingBlock)\n        \t{\n                if (tileInfo.y <= 0.0)\n                {\n                \ttileInfo.x = (currentTileType == COLLAPSING_BLOCK) ? GetRandomPowerup(tileIndex) : float(FREE_SPACE);\n                    tileInfo.z = 0.0;\n                }\n                previousExplosionType = tileInfo.z;\n                tileInfo.w = 0.0;\n        \t}\n            \n\t\t\tif (isCollapsingBlock == false)\n            {\n                UpdateTile(tileInfo, leftTileInfo, EXPLOSION_DIRECTION_RIGHT, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, rightTileInfo, EXPLOSION_DIRECTION_LEFT, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, upTileInfo, EXPLOSION_DIRECTION_DOWN, isBomb, isBreakableBlock);\n                UpdateTile(tileInfo, downTileInfo, EXPLOSION_DIRECTION_UP, isBomb, isBreakableBlock);\n            }\n\n            // Update bomb, flame and collapsing block timers\n            if ((isExplosion || isCollapsingBlock || isBomb) && (tileInfo.y > 0.0))\n            {\n                tileInfo.y -= iTimeDelta;\n                if (isBomb && (tileInfo.y <= 0.0))\n                {\n                    tileInfo.x = float(EXPLOSION);\n                    tileInfo.y = BOMB_EXPLOSION_TIME;\n                }\n            }\n        }    \n    }\n    else if (gameInfo.x == MODE_MATCH_OVER)\n    {\n        gameInfo.x = (timeInMode > 3.0) ? MODE_AWARD : gameInfo.x;\n    }\n    else if (gameInfo.x == MODE_AWARD)\n    {\n        gameInfo.x = (timeInMode > 10.0) ? MODE_MATCH_RESET : gameInfo.x;\n    }\n    gameInfo.z = (previousGameMode != gameInfo.x) ? iTime : gameInfo.z;\n    \n    // Store game state\n    fragColor = vec4(0.0);\n \n    StoreValue(txGameInfo, gameInfo, fragColor, fragCoord);\n    StoreValue(txPlayField, tileInfo, fragColor, fragCoord);\n     \n    StoreBomberman(txBomberman0Info, gBomberman0, fragColor, fragCoord);\n    StoreBomberman(txBomberman1Info, gBomberman1, fragColor, fragCoord);\n    StoreBomberman(txBomberman2Info, gBomberman2, fragColor, fragCoord);\n    StoreBomberman(txBomberman3Info, gBomberman3, fragColor, fragCoord);\t\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 2,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Keyboard Input\nvec4 LoadValueBufferB(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\n////////////////////////////////////////////////////////\n// Controls\nstruct ControlSet\n{\n    float mLeftKey;\n\tfloat mUpKey;\n    float mRightKey;\n    float mDownKey;\n    float mBombKey;\n};\n\n#define CalculateKeyCode(x) ((float(x) + 0.5) / 256.0)\n\n// Player 0\nconst float KEY_LEFT  = CalculateKeyCode(37);\nconst float KEY_UP    = CalculateKeyCode(38);\nconst float KEY_RIGHT = CalculateKeyCode(39);\nconst float KEY_DOWN  = CalculateKeyCode(40);\nconst float KEY_SPACE = CalculateKeyCode(32);\nControlSet gControlSet0 = ControlSet(KEY_LEFT, KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_SPACE);\n\n// Player 1\nconst float KEY_A     = CalculateKeyCode(65);\nconst float KEY_W     = CalculateKeyCode(87);\nconst float KEY_D     = CalculateKeyCode(68);\nconst float KEY_S     = CalculateKeyCode(83);\nconst float KEY_Q     = CalculateKeyCode(81);\nControlSet gControlSet1 = ControlSet(KEY_A, KEY_W, KEY_D, KEY_S, KEY_Q);\n\n// Player 2\nconst float KEY_J     = CalculateKeyCode(74);\nconst float KEY_I     = CalculateKeyCode(73);\nconst float KEY_K     = CalculateKeyCode(76);\nconst float KEY_L     = CalculateKeyCode(75);\nconst float KEY_U     = CalculateKeyCode(85);\nControlSet gControlSet2 = ControlSet(KEY_J, KEY_I, KEY_K, KEY_L, KEY_U);\n\n// Player 3\nconst float KEY_V     = CalculateKeyCode(86);\nconst float KEY_G     = CalculateKeyCode(71);\nconst float KEY_N     = CalculateKeyCode(78);\nconst float KEY_B     = CalculateKeyCode(66);\nconst float KEY_F     = CalculateKeyCode(70);\nControlSet gControlSet3 = ControlSet(KEY_V, KEY_G, KEY_N, KEY_B, KEY_F);\n    \nbool CheckKey(in float key)\n{\n\treturn texture(iChannel2, vec2(key, 0.25)).x > 0.5;   \n}\n\nvec4 CheckKeyboardInput(in ControlSet controlSet, in float lastBombTime)\n{\n    vec4 results = vec4(0.0, 0.0, 0.0, (abs(iTime - lastBombTime) > 0.25) ? 0.0 : lastBombTime);\n    \n    results.x -= CheckKey(controlSet.mLeftKey) ? 1.0 : 0.0;\n    results.x += CheckKey(controlSet.mRightKey) ? 1.0 : 0.0;\n    results.y -= CheckKey(controlSet.mDownKey) ? 1.0 : 0.0;\n    results.y += CheckKey(controlSet.mUpKey) ? 1.0 : 0.0;\n       \n    // Last bomb time is used to determine the bomb key was released before another bomb can be placed\n    if (CheckKey(controlSet.mBombKey)) \n    { \n        if (lastBombTime == 0.0)\n        {\n            results.z += 1.0; \n            results.w = iTime;\n        }\n    }\n    return results;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    fragColor = vec4(0.0);\n    \n    float playerToUpdate = mod(float(iFrame), 4.0);\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    \n    float bomberman0TimeSinceBomb = LoadValueBufferB(txBomberman0Command).w;\n    float bomberman1TimeSinceBomb = LoadValueBufferB(txBomberman1Command).w;\n    float bomberman2TimeSinceBomb = LoadValueBufferB(txBomberman2Command).w;\n    float bomberman3TimeSinceBomb = LoadValueBufferB(txBomberman3Command).w;       \n\n    vec4 bomberman0Inputs = CheckKeyboardInput(gControlSet0, bomberman0TimeSinceBomb);\n    vec4 bomberman1Inputs = CheckKeyboardInput(gControlSet1, bomberman1TimeSinceBomb);\n    vec4 bomberman2Inputs = CheckKeyboardInput(gControlSet2, bomberman2TimeSinceBomb);\n    vec4 bomberman3Inputs = CheckKeyboardInput(gControlSet3, bomberman3TimeSinceBomb);\n\n    StoreValue(txBomberman0Command, bomberman0Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman1Command, bomberman1Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman2Command, bomberman2Inputs, fragColor, fragCoord);\n    StoreValue(txBomberman3Command, bomberman3Inputs, fragColor, fragCoord);\t\t  \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Game Display Buffer\n\n//////////////////////////////////////////////////\n// Debugging Settings\n#define     SHOW_ALBEDO             \t0\n#define     SHOW_NORMALS            \t0\n#define     SHOW_LIGHTING               0\n\n//////////////////////////////////////////////////\n// Settings\n#define ULTRA_QUALITY       4\n#define HIGH_QUALITY\t    3\t\t\n#define MEDIUM_QUALITY\t\t2\n#define LOW_QUALITY\t\t    1\n\n#define QUALITY_MODE \t\tULTRA_QUALITY\n\n//////////////////////////////////////////////////\n// Advanced Settings\n#define     NUMBER_OF_STEPS         30\n\n#if (QUALITY_MODE >= ULTRA_QUALITY) \n#define \tGRASS_NOISE\t\t\t\t1\n#else\n#define \tGRASS_NOISE\t\t\t\t0\n#endif\n\n//////////////////////////////////////////////////\n// Common Globals\nvec3 gCloseIntersection;\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 30.0; // VR needs 20\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n// Scene\nconst int EDGE_BLOCK\t\t\t= 20;\nconst int GROUND\t\t\t\t= 30;\n\n// Bomberman Material Indexes\nconst int BOMBERMAN_WHITE\t\t= 100;\nconst int BOMBERMAN_BLACK\t\t= 101;\nconst int BOMBERMAN_RED\t\t\t= 102;\nconst int BOMBERMAN_BLUE\t\t= 103;\nconst int BOMBERMAN_PINK\t\t= 104;\nconst int BOMBERMAN_SKIN\t\t= 105;\nconst int BOMBERMAN_GOLD\t\t= 106;\n\nstruct BombermanColorSet\n{\n    int \tmPrimaryColor;\n    int \tmSecondaryColor;\n    int \tmBodyColor;\n};\nconst BombermanColorSet gColorSet0 = BombermanColorSet(BOMBERMAN_WHITE, BOMBERMAN_PINK, BOMBERMAN_BLUE);\nconst BombermanColorSet gColorSet1 = BombermanColorSet(BOMBERMAN_BLACK, BOMBERMAN_PINK, BOMBERMAN_BLACK);\nconst BombermanColorSet gColorSet2 = BombermanColorSet(BOMBERMAN_RED, BOMBERMAN_PINK, BOMBERMAN_RED);\nconst BombermanColorSet gColorSet3 = BombermanColorSet(BOMBERMAN_BLUE, BOMBERMAN_PINK, BOMBERMAN_BLUE);\n            \n// Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nstruct Bomberman\n{\n\tvec2 \tmPosition;\n    float   mDirection;\n    float   mAnimation;\n};\n    \nBomberman LoadBomberman(in vec2 re)\n{\n    vec4 bombermanInfo = LoadValueBufferA(re);  \n    return Bomberman(bombermanInfo.xy, bombermanInfo.z, bombermanInfo.w);\n}\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    vec2\t\tmStartingTileIndex;\n    vec2\t\tmEndingTileIndex;\n    float       mT;\n    int\t\t    mMaterialIndex;\n};  \n\n#define CreateIntersectionData(x, y)    \tIntersectionData(vec2(-1.0), vec2(-1.0), x, y)\n#define InvalidIntersectionData    \t\t\tIntersectionData(vec2(-1.0), vec2(-1.0), MAX_DISTANCE, -1)\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if (a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\nstruct AABB\n{\n\tvec3 mMin;\n    vec3 mMax;\n};\n           \n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfBox(in vec3 p, in vec3 boxSize)\n{\n\tvec3 d = abs(p) - boxSize;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfCylinder(in vec3 p, in vec3 cylinderDimensions)\n{\n\treturn length(p.xz - cylinderDimensions.xy) - cylinderDimensions.z;\n}\n\nfloat sdfSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdfCapsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\nfloat udfRoundedBox(in vec3 p, in vec3 boxSize, in float radius)\n{\n\treturn length(max(abs(p) - boxSize, 0.0)) - radius;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin(in float a, in float b, in float k)\n{\n    float h = Saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opBlend(in float a, in float b)\n{\n    return smin(a, b, 0.005);\n}\n\n//////////////////////////////////////////////////////\n// Noise\nfloat Hash(in vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(i), Hash(i + vec2(1.0, 0.0)), u.x), mix(Hash(i + vec2(0.0, 1.0)), Hash(i + vec2(1.0)), u.x), u.y);   \n}\n\nfloat FractalBrownianMotion(in vec2 p)\n{\n   float f \n     = Noise(p) * 16.0\n   \t + Noise(p * 2.0) * 8.0\n     + Noise(p * 4.0) * 4.0\n     + Noise(p * 8.0) * 2.0\n     + Noise(p * 16.0);\n    \n    return f / (1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0);\n}\n\nbool AABBIntersection(in Ray ray, in AABB aabb, out float tMin, out float tMax)\n{\n    for(int i = 0; i < 3; i++)\n    {\n        float inverseDirection = 1.0 / ray.mDirection[i];\n        float t0 = (aabb.mMin[i] - ray.mPosition[i]) * inverseDirection;\n        float t1 = (aabb.mMax[i] - ray.mPosition[i]) * inverseDirection;\n        \n        if (inverseDirection < 0.0)\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        \n        tMin = max(t0, tMin);\n        tMax = min(t1, tMax);\n        \n        if (tMax <= tMin)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Scene\nconst vec3 k_playFieldHalfSize = vec3(0.75, 0.035, 0.5);\nconst vec3 k_playFieldOffset = vec3(0.0, 0.1, 0.0);\nconst AABB k_playField = AABB(-k_playFieldHalfSize + k_playFieldOffset, k_playFieldHalfSize + k_playFieldOffset);\nconst vec3 k_playFieldSize = abs(k_playField.mMax - k_playField.mMin);\n\n// Ground\nconst vec3 k_groundHalfSize = vec3(0.5 * k_playFieldSize.x, 0.25 * k_playFieldSize.y, 0.5 * k_playFieldSize.z);\nconst vec3 k_groundCenter = k_playField.mMin + k_groundHalfSize;\n\n// Blocks\nconst vec3 k_tileSize = vec3(k_playFieldSize.x / (float(CELLS_WIDE) + 2.0), k_playFieldSize.y * 0.375, k_playFieldSize.z / (float(CELLS_TALL) + 2.0));\nconst vec3 k_tileHalfSize = k_tileSize * 0.5;\nconst vec3 k_edgeBlockHalfSize = vec3(k_tileHalfSize.x, k_playFieldSize.y, k_tileHalfSize.z);\n\n// Power Ups\nconst vec3 k_powerUpSize = vec3(k_tileHalfSize.z * 0.65, k_tileHalfSize.y * 0.5, k_tileHalfSize.z * 0.65);\n\nvec3 GetTileCenter(in vec2 tileIndex)\n{\n    vec2 offsetTileIndex = floor(tileIndex + vec2(1.0));\n \n    return vec3(k_playField.mMin.x + k_tileHalfSize.x + offsetTileIndex.x * k_tileSize.x,\n\t\t\t\tk_groundCenter.y + k_groundHalfSize.y + k_tileHalfSize.y,\n    \t\t\tk_playField.mMin.z + k_tileHalfSize.z + offsetTileIndex.y * k_tileSize.z);\n}\n\nvec3 GetBombermanPosition(in vec2 position)\n{    \n    vec2 bomberman2DPosition = k_playField.mMin.xz + k_tileHalfSize.xz + (position.xy + 1.0) * k_tileSize.xz;\n    return vec3(bomberman2DPosition.x, (k_groundCenter.y + k_groundHalfSize.y) + k_tileHalfSize.y, bomberman2DPosition.y);\n}\n\nvec3 GetBombermanForward(in float direction)\n{\n    const vec3[] k_bombermanForward = vec3[](vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec3(1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0)); \n    return k_bombermanForward[uint(direction)];\n}\n\nvec3 GetBombermanRight(in float direction)\n{\n    const vec3[] k_bombermanRight = vec3[](vec3(1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0)); \n    return k_bombermanRight[uint(direction)];\n}\n\nIntersectionData CheckBomberman(in Bomberman bomberman, in vec3 position, in vec2 tileIndex, in BombermanColorSet colorSet)\n{\n    IntersectionData primaryIntersection = InvalidIntersectionData;\n    vec2 bombermanTileIndex = GetTileIndex(ConvertTileCoordsToScreenUV(bomberman.mPosition.xy)); \n    vec2 tileDistance = abs(tileIndex - bombermanTileIndex);\n    \n    if ((tileDistance.x <= 1.0) && (tileDistance.y <= 1.0))\n    {\n    \tvec3 bombermanPosition = GetBombermanPosition(bomberman.mPosition) + vec3(k_tileHalfSize.x * 0.125, 0.0, k_tileHalfSize.z * 0.25); \n        vec3 bombermanForward = GetBombermanForward(bomberman.mDirection);\n        vec3 bombermanRight = GetBombermanRight(bomberman.mDirection);\n\n        vec3 offsetPosition = bombermanPosition - position;\n\n#if QUALITY_MODE >= MEDIUM_QUALITY   \n        float headT = sdfSphere(offsetPosition + vec3(0.0, 0.05, 0.0), k_tileHalfSize.z * 0.65);\n        primaryIntersection.mT = headT;\n        primaryIntersection.mMaterialIndex = colorSet.mPrimaryColor;\n\n        // Body\n        IntersectionData bodyIntersection;\n        bodyIntersection.mT = min(primaryIntersection.mT, sdfCapsule(position, bombermanPosition + vec3(0.0, 0.04, 0.0), bombermanPosition + vec3(0.0, 0.03, 0.0), k_tileHalfSize.z * 0.45));\n        bodyIntersection.mMaterialIndex = colorSet.mBodyColor;\n\t\tprimaryIntersection = GetClosestIntersection(bodyIntersection, primaryIntersection);\n        \n        IntersectionData pinkIntersection;\n        pinkIntersection.mMaterialIndex = colorSet.mSecondaryColor;  \n        pinkIntersection.mT = sdfSphere((offsetPosition - (bombermanForward * 0.012) + vec3(0.0, 0.07, 0.0)), k_tileHalfSize.z * 0.3);    \n\n        // Hands\n        vec3 handHeightOffset = vec3(0.0, 0.015, 0.0);\n        float handRotation = bomberman.mAnimation / 20.0 * PI;\n        vec3 handForwardOffset = sin(handRotation) * bombermanForward * 0.01;\n        \n        pinkIntersection.mT = min(pinkIntersection.mT, sdfSphere((offsetPosition - (bombermanRight * 0.02) + handHeightOffset + handForwardOffset), k_tileHalfSize.z * 0.25));\n        pinkIntersection.mT = min(pinkIntersection.mT, sdfSphere((offsetPosition - (bombermanRight * -0.02) + handHeightOffset - handForwardOffset), k_tileHalfSize.z * 0.25));     \n        primaryIntersection = GetClosestIntersection(pinkIntersection, primaryIntersection);\n\n        // Face\n        IntersectionData skinIntersection;\n        vec3 bombermanSkinBoxSize = vec3(k_tileHalfSize.x * 0.3, k_tileHalfSize.y * 0.3, k_tileHalfSize.x * 0.3) * (vec3(1.0) - (0.70 * abs(bombermanForward)));\n        skinIntersection.mT = udfRoundedBox(offsetPosition + vec3(0.0, 0.05, 0.0) + (bombermanForward * 0.0125), bombermanSkinBoxSize, 0.001);\n\n        skinIntersection.mT = opBlend(skinIntersection.mT, headT);\n        skinIntersection.mMaterialIndex = BOMBERMAN_SKIN;  \n        primaryIntersection = GetClosestIntersection(skinIntersection, primaryIntersection);\n\n        // Eyes\n        const float k_eyeRadius = 0.006;\n        const float k_eyeForward = 0.015;\n        const float k_eyeSpacing = 0.0075;\n\n        IntersectionData eyeIntersection;\n        eyeIntersection.mMaterialIndex = BOMBERMAN_BLACK;\n        vec3 eyeTop = bombermanPosition + vec3(0.0, 0.052, 0.0) + (bombermanForward * k_eyeForward);\n        vec3 eyeBottom = bombermanPosition + vec3(0.0, 0.0485, 0.0) + (bombermanForward * k_eyeForward);\n\n        eyeIntersection.mT = sdfCapsule(position, eyeBottom + (bombermanRight * k_eyeSpacing), eyeTop + (bombermanRight * k_eyeSpacing), k_eyeRadius);\n        eyeIntersection.mT = min(eyeIntersection.mT, sdfCapsule(position, eyeBottom + (bombermanRight * -k_eyeSpacing), eyeTop + (bombermanRight * -k_eyeSpacing), k_eyeRadius));\n        primaryIntersection = GetClosestIntersection(eyeIntersection, primaryIntersection);\n\n#elif QUALITY_MODE >= LOW_QUALITY      \n        primaryIntersection.mT = sdfSphere(bombermanPosition - position, gTileHalfSize.z);\n        primaryIntersection.mMaterialIndex = colorSet.mPrimaryColor;\n\n        IntersectionData pinkIntersection;\n        pinkIntersection.mT = sdfSphere((bombermanPosition - (bombermanForward * 0.02) + vec3(0.0, 0.03, 0.0)) - position, gTileHalfSize.z * 0.3);\n        pinkIntersection.mMaterialIndex = colorSet.mSeconadryColor;  \n\n        primaryIntersection = GetClosestIntersection(pinkIntersection, primaryIntersection);\n#endif // QUALITY_MODE >= LOW_QUALITY \n    }\n    return primaryIntersection;\n}\n\nIntersectionData CheckBombermen(in vec3 position, in vec2 tileIndex)\n{ \n\tBomberman bomberman0 = LoadBomberman(txBomberman0Info);\n    Bomberman bomberman1 = LoadBomberman(txBomberman1Info);\n    Bomberman bomberman2 = LoadBomberman(txBomberman2Info);\n    Bomberman bomberman3 = LoadBomberman(txBomberman3Info);\n     \n    IntersectionData bombermanIntersection = GetClosestIntersection(\n           GetClosestIntersection(CheckBomberman(bomberman0, position, tileIndex, gColorSet0), CheckBomberman(bomberman1, position, tileIndex, gColorSet1)),                                                                 \n           GetClosestIntersection(CheckBomberman(bomberman2, position, tileIndex, gColorSet2), CheckBomberman(bomberman3, position, tileIndex, gColorSet3)));\n\n    bombermanIntersection.mStartingTileIndex = tileIndex;\n    bombermanIntersection.mEndingTileIndex = tileIndex;  \n    \n    return bombermanIntersection;\n}\n\nIntersectionData CheckTileIntersection(in vec3 position, in vec2 tileIndex)\n{\n    IntersectionData tileIntersection = InvalidIntersectionData;\n    \n    vec3 tileCenter = GetTileCenter(tileIndex);\n            \n    if ((tileIndex.x >= 0.0) && (tileIndex.y >= 0.0) && (tileIndex.x < float(CELLS_WIDE)) && (tileIndex.y < float(CELLS_TALL)))\n    {\n        vec4 tileInfo = LoadValueBufferA(txPlayField.xy + tileIndex);   \n\t\tint tileType = int(tileInfo.x);\n        \n        if ((tileType == BREAKABLE_BLOCK) || (tileType == UNBREAKABLE_BLOCK) || (tileType == COLLAPSING_BLOCK))\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_tileHalfSize);\n            tileIntersection.mMaterialIndex = int(tileInfo.x);\n        }\n        else if (tileType == EXPLOSION)\n        {\n            tileIntersection.mMaterialIndex = EXPLOSION;\n\n            const vec3 k_horizontalExplosionOffset = vec3(k_tileHalfSize.x, 0.0, 0.0);\n            const vec3 k_verticalExplosionOffset = vec3(0.0, 0.0, k_tileHalfSize.z);\n            float explosionRadius = k_tileHalfSize.z * 0.9 * Saturate(tileInfo.y * 10.0);\n\n            vec3 explosionCenter = vec3(tileCenter.x, k_playField.mMin.y + k_tileHalfSize.z * 0.9, tileCenter.z);\n\n            uint explosionFlags = uint(tileInfo.z);\n            if ((explosionFlags & EXPLOSION_DIRECTION_LEFT) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter, explosionCenter + k_horizontalExplosionOffset * 2.0, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_RIGHT) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter - k_horizontalExplosionOffset * 2.0, explosionCenter, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_UP) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter, explosionCenter + k_verticalExplosionOffset * 2.0, explosionRadius));\n            }\n            \n            if ((explosionFlags & EXPLOSION_DIRECTION_DOWN) != 0U)\n            {\n                tileIntersection.mT = min(tileIntersection.mT, sdfCapsule(position, explosionCenter - k_verticalExplosionOffset * 2.0, explosionCenter, explosionRadius));\n            }\n        }\n        else if (tileType == BOMB)\n        {\n            float radiusMix = (sin(tileInfo.y * 10.0) + 1.0) * 0.5;\n            float bombRadius = mix(k_tileHalfSize.z * 0.9, k_tileHalfSize.z * 1.05, radiusMix);\n            \n            tileIntersection.mT = sdfSphere(tileCenter - position, bombRadius);\n            tileIntersection.mMaterialIndex = BOMBERMAN_BLACK;        \n        }\n        else if ((tileType == BOMB_POWER_UP) || (tileType == FLAME_POWER_UP) || (tileType == SKATE_POWER_UP))\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_powerUpSize);\n            tileIntersection.mMaterialIndex = tileType;\n        }         \n    }\n    else\n    {\n        bool xEdge = (tileIndex.x == -1.0) || (tileIndex.x == float(CELLS_WIDE));\n        bool yEdge = (tileIndex.y == -1.0) || (tileIndex.y == float(CELLS_TALL));\n            \n        if (xEdge || yEdge)\n        {\n            tileIntersection.mT = sdfBox(tileCenter - position, k_edgeBlockHalfSize);\n        \ttileIntersection.mMaterialIndex = EDGE_BLOCK;\n        }\n    }   \n    return tileIntersection;\n}\n\nIntersectionData CheckSceneForIntersection(in vec3 position, in vec2 startingTileIndex, in vec2 endingTileIndex)\n{\n#if GRASS_NOISE\n    vec3 grassOffset = vec3(0.0, Noise((position.xz + vec2(2.0)) * iResolution.y * 0.5) * 0.0075, 0.0);\n    IntersectionData sceneIntersection = CreateIntersectionData(sdfBox(k_groundCenter - position, k_groundHalfSize + grassOffset), GROUND);\n#else\n    IntersectionData sceneIntersection = CreateIntersectionData(sdfBox(k_groundCenter - position, k_groundHalfSize), GROUND);\n#endif // GRASS_NOISE\n       \n    IntersectionData bombermanIntersection = CheckBombermen(position, startingTileIndex);\n    sceneIntersection = GetClosestIntersection(sceneIntersection, bombermanIntersection);      \n\n    // Starting tile collision\n    IntersectionData tileIntersection = CheckTileIntersection(position, startingTileIndex);\n    sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    \n    bool checkX = (abs(endingTileIndex.x - startingTileIndex.x) > 0.01);\n\tbool checkY = (abs(endingTileIndex.y - startingTileIndex.y) > 0.01);           \n    \n    if (checkX)\n    {\n        tileIntersection = CheckTileIntersection(position, vec2(endingTileIndex.x, startingTileIndex.y));\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    if (checkY)\n    {\n        tileIntersection = CheckTileIntersection(position, vec2(startingTileIndex.x, endingTileIndex.y));\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    if (checkX && checkY)\n    {\n        tileIntersection = CheckTileIntersection(position, endingTileIndex.xy);\n        sceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n    }\n    \n    // Adjacent tiles, doing some duplicate work here :(\n    const int k_adjacentTilesToCheck = 1;\n     \n    for (int x = -k_adjacentTilesToCheck; x <= k_adjacentTilesToCheck; ++x)\n    {\n        for (int y = -k_adjacentTilesToCheck; y <= k_adjacentTilesToCheck; ++y)\n        {                     \n            vec2 currentTileIndex = (startingTileIndex + vec2(x, y));    \n            if (currentTileIndex != startingTileIndex)\n            {\n\t\t\t\ttileIntersection = CheckTileIntersection(position, currentTileIndex);\n            \tsceneIntersection = GetClosestIntersection(sceneIntersection, tileIntersection);\n            }\n    \t}\n    }\n    \n    return sceneIntersection;\n}\n\nvec2 CalculateTileUV(in vec2 point)\n{\n    return (point - k_playField.mMin.xz) / k_playFieldSize.xz;\n}\n\nvec2 CalculateTileIndex(in vec3 intersectionPoint)\n{\n    vec2 tileUV = CalculateTileUV(intersectionPoint.xz);    \n    return GetTileIndex(tileUV);\n}\n\nIntersectionData CheckSceneForIntersection(in Ray ray)\n{\n    IntersectionData sceneIntersection = InvalidIntersectionData;\n    vec2 closeTileIndex = vec2(-1.0);  \n    vec2 farTileIndex = vec2(-1.0);\n    \n    float tMin = -100.0;\n    float tMax = 100.0;\n    \n    if (AABBIntersection(ray, k_playField, tMin, tMax))\n    { \n        gCloseIntersection = ray.mPosition + (tMin * ray.mDirection);\n        vec2 closeTileUV = CalculateTileUV(gCloseIntersection.xz); \n        closeTileIndex = GetTileIndex(closeTileUV);\n        \n        vec3 farIntersection = ray.mPosition + (tMax * ray.mDirection);\n        vec2 farTileUV = CalculateTileUV(farIntersection.xz); \n        farTileIndex = GetTileIndex(farTileUV);\n             \n        sceneIntersection = CheckSceneForIntersection(ray.mPosition, closeTileIndex, farTileIndex);\n    }\n    sceneIntersection.mStartingTileIndex = closeTileIndex;\n    sceneIntersection.mEndingTileIndex = farTileIndex;\n    \n    return sceneIntersection;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = InvalidIntersectionData;\n    \n    float t = 0.0;   \n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection);    \n        sceneIntersection = CheckSceneForIntersection(currentRay);    \n        t += sceneIntersection.mT; // Step forward\n    }    \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 position, in vec2 startingTileIndex, in vec2 endingTileIndex, in float d0T) \n{\n    IntersectionData d0 = CheckSceneForIntersection(position, startingTileIndex, endingTileIndex);\n    IntersectionData dX = CheckSceneForIntersection(position - vec3(EPSILON, 0.0, 0.0), startingTileIndex, endingTileIndex);\n    IntersectionData dY = CheckSceneForIntersection(position - vec3(0.0, EPSILON, 0.0), startingTileIndex, endingTileIndex);\n    IntersectionData dZ = CheckSceneForIntersection(position - vec3(0.0, 0.0, EPSILON), startingTileIndex, endingTileIndex);\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n    return fract(sin(p * mat2(12.98, 78.23, 127.99, 311.33)) * 43758.54);\n}\n\nvec3 WorleyNoise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 n = fract(uv);\n    vec3 minD = vec3(9.0);\n    \n    for (float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 point = sin(32.0 * Hash2D(i + vec2(x, y))) * 0.5 + 0.5;\n            float d = length(vec2(x, y) + point - n);\n            \n            minD = (d < minD.x) ? vec3(d, minD.xy) \n               \t : (d < minD.y) ? vec3(minD.x, d, minD.y) \n               \t : (d < minD.z) ? vec3(minD.xy, d) \n                 : minD;\n        }\n    }\n    return minD;\n}\n\nvec2 GetPowerUpUVs(in vec3 point, in vec3 normal, in int powerUp)\n{\n\tvec2 tileIndex = CalculateTileIndex(point); \n    vec3 tileCenter = GetTileCenter(tileIndex);\n    normal = abs(normal);\n    \n    vec2 sampleUV = vec2(0.0);\n    if (normal.y > 0.5)\n    {\n    \tsampleUV = (((point.xz - tileCenter.xz) / k_powerUpSize.xz) + vec2(1.0)) * 0.5;\n    }\n    else if (normal.x > 0.5)\n    {\n    \tsampleUV = (((point.yz - tileCenter.yz) / k_powerUpSize.yz) + vec2(1.0)) * 0.5;\n    }\n    else if (normal.z > 0.5)\n    {\n    \tsampleUV = (((point.xy - tileCenter.xy) / k_powerUpSize.xy) + vec2(1.0)) * 0.5;\n    }\n    sampleUV = sampleUV * (vec2(16.0) / iChannelResolution[1].xy) + (float(powerUp) * vec2(16.0, 0.0) / iChannelResolution[1].xy);\n   \n    return sampleUV;\n}\n\nvec3 GetDiffuseColor(in vec3 intersectionPoint, in vec3 normal, in int materialIndex)\n{\n    const vec3 bombermanColors[] = vec3[](vec3(1.0), vec3(0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.93, 0.51, 0.65), vec3(0.96, 0.9, 0.76));\n\n    vec3 diffuse = vec3(0.0);\n\t\t\n    if (materialIndex == BREAKABLE_BLOCK)\n    {\n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);   \n        vec3 noise = WorleyNoise((intersectionPoint.xz + tileIndex * 17.3) * 30.0);\n        float tint = (noise.z - noise.x);\n        \n        diffuse = mix(vec3(0.35, 0.25, 0.15), vec3(0.7, 0.5, 0.3), tint);\n#else\n        diffuse = vec3(0.8, 0.6, 0.4);        \n#endif \n    }\n    else if (materialIndex == UNBREAKABLE_BLOCK)\n    {\n        diffuse = vec3(0.20);\n #if QUALITY_MODE >= MEDIUM_QUALITY       \n    \tvec2 tileUV = CalculateTileUV(intersectionPoint.xz);   \n        vec2 t = fract(tileUV * vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0) - vec2(0.25));   \n        \n        if((t.x < 0.5) || (t.y < 0.5))\n        {\n            diffuse = vec3(0.35);\n        }\n#endif \n    }\n    else if (materialIndex == COLLAPSING_BLOCK)\n    {\n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);   \n        vec3 noise = WorleyNoise((intersectionPoint.xz + tileIndex * 17.3) * 30.0);\n        float tint = (noise.z - noise.x);\n        \n        diffuse = mix(vec3(0.35, 0.25, 0.15), vec3(1.0, 0.25, 0.0), tint);\n#else\n        diffuse = vec3(1.0, 0.25, 0.0);        \n#endif \n    }\n    else if (materialIndex == EXPLOSION)\n    {\n        float flameTint = Saturate(dot(normal, vec3(0.0, -1.0, 0.0)));\n        float flameTintSquared = flameTint * flameTint;\n        diffuse = mix(vec3(1.0, 0.25, 0.0), vec3(1.0, 0.6, 0.2), flameTintSquared * flameTintSquared);\n    }\n    else if (materialIndex == EDGE_BLOCK)\n    {\n        diffuse = vec3(0.5);\n    }\n    else if (materialIndex == GROUND)\n    {\n        diffuse = vec3(0.0, 0.5, 0.0); \n        \n#if QUALITY_MODE >= MEDIUM_QUALITY\n        vec2 tileIndex = CalculateTileIndex(intersectionPoint);\n        if (mod(tileIndex.x + tileIndex.y, 2.0) < 1.0)\n        {\n            diffuse = vec3(0.0, 0.425, 0.0);\n        }\n#endif\n    }\n    else if ((materialIndex >= BOMB_POWER_UP) && (materialIndex <= FLAME_POWER_UP))\n    {\n\t\tdiffuse = texture(iChannel1, GetPowerUpUVs(intersectionPoint, normal, materialIndex - BOMB_POWER_UP)).rgb;      \n#if QUALITY_MODE >= MEDIUM_QUALITY\n\t\tdiffuse = (diffuse.r >= 0.95) ? mix(diffuse, vec3(1.0, 1.0, 0.0), mod(iTime * 15.0, 2.0)) : diffuse;       \n#endif\n    }\n    else if ((materialIndex >= BOMBERMAN_WHITE) && (materialIndex <= BOMBERMAN_SKIN))\n    {\n        diffuse = bombermanColors[materialIndex - BOMBERMAN_WHITE];\n    }  \n    return diffuse;\n}\n\nfloat ApplyDirectionalLight(in vec3 point, in vec3 normal, in vec3 lightDirection, in vec2 startingTileIndex, in vec2 endingTileIndex, in float t)\n{\n    float nDotL = Saturate(dot(normal, lightDirection)); \n    // Eventually apply shadows here\n    return nDotL;\n}\n\nfloat CalculateLighting(in vec3 point, in vec3 normal, in vec2 startingTileIndex, in vec2 endingTileIndex, in float t)\n{\n    const vec3 lightDirection = normalize(vec3(0.5, -1.0, 0.5));\n    float lighting = ApplyDirectionalLight(point, normal, lightDirection, startingTileIndex, endingTileIndex, t);\n    \n    // Wrap lighting\n    const float k_wrapAmount = 0.5;\n    lighting = (lighting + k_wrapAmount) / (1.0 + k_wrapAmount);\n    \n    const float k_ambientLight = 0.3;\n    lighting = min(lighting + k_ambientLight, 1.0);\n\n    return lighting;\n}\n\nvec3 ThreeDimensionalDisplay(in vec3 cameraPosition, in vec3 cameraDirection)\n{\n    vec3 finalColor = vec3(0.0);\n  \n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint, intersection.mStartingTileIndex, intersection.mEndingTileIndex, intersection.mT); \n       \tvec3 diffuse = GetDiffuseColor(intersectionPoint, normal, intersection.mMaterialIndex);\n        \n        float lighting = CalculateLighting(intersectionPoint, normal, intersection.mStartingTileIndex, intersection.mEndingTileIndex, intersection.mT);\n#if SHOW_ALBEDO       \n    \tfinalColor = diffuse;  \n#elif SHOW_NORMALS\n        finalColor = normal * 0.5 + vec3(0.5);\n#elif SHOW_LIGHTING\n        finalColor = vec3(lighting);\n#else\n        finalColor = (diffuse * lighting);\n#endif // SHOW_NORMALS        \n    }\n    else\n    {\n#if QUALITY_MODE == ULTRA_QUALITY\n\t\tfinalColor = vec3(0.6, 0.6, 1.0) * (1.0 - FractalBrownianMotion(cameraDirection.xz));\n#else\n        finalColor = vec3(0.6, 0.6, 1.0);\n#endif\n    }  \n\treturn finalColor;\n}\n\n//////////////////////////////////////////////////\n// Font\n\nfloat DrawCharacter(inout vec2 p, in int c)\n{\n    float fC = float(c);\n    float color = 0.0;\n\tif (p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)\n    {\n        color = step(texture(iChannel2, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);\n    }\n    p.x -= 0.5;\n    return color;\n}\n\n#define DrawWhite(c, x) c += DrawCharacter(x, 87); c += DrawCharacter(x, 104); c += DrawCharacter(x, 105); c += DrawCharacter(x, 116); c += DrawCharacter(x, 101)\n#define DrawBlack(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 108); c += DrawCharacter(x, 97); c += DrawCharacter(x, 99); c += DrawCharacter(x, 107)\n#define DrawRed(c, x) c += DrawCharacter(x, 82); c += DrawCharacter(x, 101); c += DrawCharacter(x, 100);\n#define DrawBlue(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 108); c += DrawCharacter(x, 117); c += DrawCharacter(x, 101);\n#define DrawBomber(c, x) c += DrawCharacter(x, 66); c += DrawCharacter(x, 111); c += DrawCharacter(x, 109); c += DrawCharacter(x, 98); c += DrawCharacter(x, 101); c += DrawCharacter(x, 114)\n#define DrawWins(c, x) c += DrawCharacter(x, 87); c += DrawCharacter(x, 105); c += DrawCharacter(x, 110); c += DrawCharacter(x, 115)\n#define DrawDraw(c, x) c += DrawCharacter(x, 68); c += DrawCharacter(x, 114); c += DrawCharacter(x, 97); c += DrawCharacter(x, 119)\n\n//////////////////////////////////////////////////\n// Implementation \n\nvec3 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv, in vec2 textUVs)\n{\n    vec3 sceneColor = vec3(0.0);\n    \n    vec4 gameInfo = LoadValueBufferA(txGameInfo);\n    \n    if ((gameInfo.x == MODE_GAMEPLAY) || (gameInfo.x == MODE_MATCH_OVER) || (gameInfo.x == MODE_AWARD))\n    {  \n    \tsceneColor = ThreeDimensionalDisplay(cameraPosition, cameraDirection);\n        \n        float characterMask = 0.0;\n\n        if (gameInfo.x == MODE_AWARD) // Win Screen\n        {\n            Bomberman bomberman0 = LoadBomberman(txBomberman0Info);\n            Bomberman bomberman1 = LoadBomberman(txBomberman1Info);\n            Bomberman bomberman2 = LoadBomberman(txBomberman2Info);\n            Bomberman bomberman3 = LoadBomberman(txBomberman3Info);\n        \n            const float k_textScale = 8.0;\n            const float k_spaceAmount = 0.5f;\n            \n            textUVs = textUVs * k_textScale + vec2(0.0, -3.25);\n            vec3 textColor = vec3(1.0);\n        \n            bool shouldBrighten = true;\n        \n            // Tint the screen the color of the winner\n            if (IsBombermanAlive(bomberman0.mPosition.x))\n            {   \n                textUVs.x -= 2.8;\n            \n                textColor = vec3(1.0, 1.0, 1.0);\n                DrawWhite(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n                \n                shouldBrighten = false;\n            }\n            else if (IsBombermanAlive(bomberman1.mPosition.x))\n            {\n                textUVs.x -= 3.0;\n            \n                textColor = vec3(0.0, 0.0, 0.0);\n                DrawBlack(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else if (IsBombermanAlive(bomberman2.mPosition.x))\n            {\n                textUVs.x -= 3.1;\n            \n                textColor = vec3(1.0, 0.0, 0.0);\n                DrawRed(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else if (IsBombermanAlive(bomberman3.mPosition.x))\n            {\n                textUVs.x -= 3.0;\n            \n                textColor = vec3(0.0, 0.0, 1.0);\n                DrawBlue(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawBomber(characterMask, textUVs);\n                textUVs.x -= k_spaceAmount;\n                DrawWins(characterMask, textUVs);\n            }\n            else\n            {\n                textUVs.x -= 5.8;            \n                DrawDraw(characterMask, textUVs);\n                shouldBrighten = false;\n            }\n            \n            // Darken or brighten the screen for easier text reading\n            sceneColor = shouldBrighten ? mix(sceneColor, vec3(1.0), 0.7) : (sceneColor * 0.7);\n            sceneColor = mix(sceneColor, textColor, characterMask);\n        }    \n    }\n    return sceneColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 adjustedUVs = vec2((uv.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), uv.y * 2.0 - 1.0) * 0.75; \n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float zRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x - 0.5) * (PI * 0.5) : 0.0; // Multiply by 0.1 to slow down the rotation \n    mat3 zRotationMatrix = Create3x3RotationMatrix(vec3(0.0, 0.0, -1.0), zRotationValue);\n           \n    const float k_distanceFromOrigin = 0.75;\n    vec3 cameraPosition = vec3(k_distanceFromOrigin * sin(zRotationValue) * cos(xRotationValue), k_distanceFromOrigin * cos(zRotationValue) * cos(xRotationValue), k_distanceFromOrigin * sin(xRotationValue));\n    vec3 cameraDirection = normalize(zRotationMatrix * xRotationMatrix * vec3(adjustedUVs.x, -1.0, adjustedUVs.y));\n   \n    // We use yy to account for the aspect ratio  \n    vec2 textUVs = (fragCoord.xy / iResolution.yy);\n   \n    vec3 finalColor = DisplayScene(cameraPosition, cameraDirection, uv, textUVs);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Sprite Sheet\n// References: [SH16C] Contra by knarkowicz - https://www.shadertoy.com/view/XltGDr\n\n#define RGB(r, g, b) vec3(float(r), float(g), float(b)) / 255.0\n\n// Each powerup sprite is 16x16\n\nconst vec2 k_powerUpSize = vec2(16.0);\nconst vec4 k_bombPowerUp = vec4(0.0, 0.0, k_powerUpSize.xy);\nconst vec4 k_skatePowerUp = vec4(k_powerUpSize.x, 0.0, 2.0 * k_powerUpSize.x, k_powerUpSize.y);\nconst vec4 k_flamePowerUp = vec4(2.0 * k_powerUpSize.x, 0.0, 3.0 * k_powerUpSize.x, k_powerUpSize.y);\n\nbool IsWithinDimensions(in vec2 fragCoord, in vec4 area)\n{\n    if ((fragCoord.x >= area.x) && (fragCoord.y >= area.y) && (fragCoord.x < area.z) && (fragCoord.y < area.w))\n    {\n        return true;\n    }\n    return false;\n}\n\nvec3 DisplayBombPowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_bombPowerUp.x);\n    float y = floor(fragCoord.y - k_bombPowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n\n   \tconst vec3 k_backGreen = RGB(51, 148, 82);\n\tconst vec3 k_bombBlack = RGB(33, 38, 30);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    \n    spriteColor = (y == 14.0) ? ((x >= 5.0 && x <= 10.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 13.0) ? ((x >= 3.0 && x <= 11.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : (x == 13.0 ? RGB(209, 60, 30) : (x == 12.0 ? RGB(255, 255, 255) : k_backGreen)))) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : RGB(51, 148, 82))) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 2.0 && x <= 13.0) ? (x == 5.0 || x == 6.0 ? RGB(255, 255, 255) : k_bombBlack) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 2.0 && x <= 13.0) ? (x == 5.0 || x == 6.0 ? RGB(255, 255, 255) : k_bombBlack) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n\tspriteColor = (y == 9.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 8.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x >= 2.0 && x <= 13.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x >= 3.0 && x <= 12.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x >= 5.0 && x <= 10.0) ? k_bombBlack : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\n    return spriteColor;\n}\n\nvec3 DisplayFlamePowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_flamePowerUp.x);\n    float y = floor(fragCoord.y - k_flamePowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n    \n    const vec3 k_backGreen = RGB(51, 148, 82);\n    const vec3 k_black = RGB(0, 0, 0);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    const vec3 k_flameYellow = RGB(255, 180, 0);\n    \n    spriteColor = (y == 14.0) ? ((x >= 5.0 && x <= 13.0) ? ((x == 5.0 || x == 9.0 || x == 12.0 || x == 13.0) ? RGB(127, 26, 4) : RGB(51, 148, 82))  : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 13.0) ? ((x >= 3.0 && x <= 14.0) ? ((x == 3.0 || x == 4.0 || x == 6.0 || x == 8.0 || x == 9.0 || x == 11.0 || x == 13.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0 || x == 12.0 ? RGB(255, 202, 0) : k_backGreen)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 14.0 || x == 10.0 || x == 7.0 || x == 2.0) ? RGB(127, 26, 4) : RGB(255, 202, 0))  : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 2.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 9.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 8.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x == 5.0  || x == 9.0 ? k_black : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? RGB(127, 26, 4) : (x >= 5.0 && x <= 9.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x >= 2.0 && x <= 13.0) ? ((x == 2.0 || x == 13.0) ? RGB(127, 26, 4) : (x >= 5.0 && x <= 9.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x >= 2.0 && x <= 13.0) ? ((x == 2.0 || x == 13.0) ? RGB(127, 26, 4) : (x >= 6.0 && x <= 8.0 ? RGB(155, 20, 20) : k_flameYellow)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x >= 3.0 && x <= 12.0) ? ((x == 3.0 || x == 12.0) ? RGB(127, 26, 4) : k_flameYellow) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x >= 4.0 && x <= 11.0) ? RGB(127, 26, 4) : ((x == 0.0 || x == 15.0) ? k_edgeRed : RGB(51, 148, 82))) : spriteColor; \n    \n    return spriteColor;\n}\n\nvec3 DisplaySkatePowerUp(in vec2 fragCoord)\n{\n    float x = floor(fragCoord.x - k_skatePowerUp.x);\n    float y = floor(fragCoord.y - k_skatePowerUp.y);\n    \n    vec3 spriteColor = RGB(255, 25, 25);\n    \n    const vec3 k_backGreen = RGB(51, 148, 82);\n    const vec3 k_black = RGB(0, 0, 0);\n    const vec3 k_edgeRed = RGB(255, 25, 25);\n    const vec3 k_skateBlue = RGB(5, 119, 252);\n    const vec3 k_skateOrange = RGB(219, 113, 5);\n    \n    spriteColor = (y == 14.0) ? ((x >= 6.0 && x <= 13.0) ? ((x >= 6.0 && x <= 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n    spriteColor = (y == 13.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 12.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : ((x < 9.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    spriteColor = (y == 11.0) ? ((x >= 6.0 && x <= 13.0) ? ((x == 6.0 || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;     \n    spriteColor = (y == 10.0) ? ((x >= 5.0 && x <= 13.0) ? ((x == 5.0 || x == 13.0) ? k_black : ((x < 9.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 9.0) ? ((x >= 3.0 && x <= 13.0) ? (((x >= 3.0 && x <= 5.0) || x == 13.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 8.0) ? ((x >= 2.0 && x <= 14.0) ? ((x == 2.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor;\n\tspriteColor = (y == 7.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 6.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0 || x == 14.0) ? k_black : k_skateBlue) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 5.0) ? ((x >= 1.0 && x <= 14.0) ? ((x == 1.0 || x == 3.0 || x == 6.0 || x == 9.0 || x == 12.0 || x == 14.0) ? k_black : ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_skateOrange : k_skateBlue)) : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n\tspriteColor = (y == 4.0) ? ((x == 2.0 || x == 7.0 || x == 8.0 || x == 13.0 || x == 4.0 ||x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x >= 3.0 && x <= 6.0 || x >= 9.0 && x <= 12.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n\tspriteColor = (y == 3.0) ? ((x == 2.0 || x == 7.0 || x == 8.0 || x == 13.0 || x == 4.0 ||x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x >= 3.0 && x <= 6.0 || x >= 9.0 && x <= 12.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n    spriteColor = (y == 2.0) ? ((x == 3.0 || x == 6.0 || x == 9.0 || x == 12.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_skateOrange : k_backGreen))) : spriteColor; \n    spriteColor = (y == 1.0) ? ((x == 4.0 || x == 5.0 || x == 10.0 || x == 11.0) ? k_black : ((x == 0.0 || x == 15.0) ? k_edgeRed : k_backGreen)) : spriteColor; \n    \n    return spriteColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 finalColor = vec3(0.0);\n    \n    // Early out if not within bounds\n    if ((fragCoord.x > (k_powerUpSize.x * 4.0)) || (fragCoord.y > k_powerUpSize.y)) \n    {\n        discard;\n    }\n    \n    if (iFrame == 0)\n    {\n        finalColor = vec3(0.0, 0.0, 0.0);     \n        finalColor += IsWithinDimensions(fragCoord, k_bombPowerUp) ? DisplayBombPowerUp(fragCoord) : vec3(0);\n        finalColor += IsWithinDimensions(fragCoord, k_skatePowerUp) ? DisplaySkatePowerUp(fragCoord) : vec3(0);\n        finalColor += IsWithinDimensions(fragCoord, k_flamePowerUp) ? DisplayFlamePowerUp(fragCoord) : vec3(0);            \n    }\n    else\n    {\n        finalColor = texture(iChannel0, uv).rgb;\n    }\t\n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Tile info\n// x = tile type, y = tile timer, z = tile explosion direction, w = explosion steps remaining\nconst int UNBREAKABLE_BLOCK = -2;\nconst int BREAKABLE_BLOCK \t= -1;\nconst int FREE_SPACE\t\t=  0;\nconst int BOMB_POWER_UP\t\t=  1;\nconst int SKATE_POWER_UP\t=  2;\nconst int FLAME_POWER_UP\t=  3;\nconst int EXPLOSION\t\t\t=  4;\nconst int COLLAPSING_BLOCK \t= -3;\nconst int BOMB\t\t\t\t=  20;\n\n// Stage is 15 by 13\nconst uint CELLS_WIDE = 15U;\nconst uint CELLS_TALL = 13U;\n\n// Explosion Directions\nconst uint EXPLOSION_DIRECTION_LEFT  = 1U;\nconst uint EXPLOSION_DIRECTION_UP    = 2U;\nconst uint EXPLOSION_DIRECTION_RIGHT = 4U;\nconst uint EXPLOSION_DIRECTION_DOWN  = 8U;\nconst uint EXPLOSION_DIRECTION_ALL   = 15U;\n\n// Storage register/texel addresses\nconst vec2 txGameInfo = vec2(0.0, 0.0); // x = game mode\nconst vec4 txBombermanInfo = vec4(1.0, 0.0, 8.0, 1.0);\nconst vec2 txBomberman0Info = vec2(1.0, 0.0);\nconst vec2 txBomberman1Info = vec2(5.0, 0.0);\nconst vec2 txBomberman2Info = vec2(9.0, 0.0);\nconst vec2 txBomberman3Info = vec2(13.0, 0.0);\n\n// x = horizontal movement, y = vertical movement, z = bomb key, w = time since last bomb key press\nconst vec2 txBomberman0Command = vec2(1.0, 0.0); \nconst vec2 txBomberman1Command = vec2(2.0, 0.0); \nconst vec2 txBomberman2Command = vec2(3.0, 0.0); \nconst vec2 txBomberman3Command = vec2(4.0, 0.0); \n\nconst vec4 txPlayField = vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));\n\n//////////////////////////////////////////////////\n// Game Modes \nconst float MODE_MATCH_RESET = 0.0;\nconst float MODE_GAMEPLAY = 1.0;\nconst float MODE_MATCH_OVER = 2.0;\nconst float MODE_AWARD = 3.0;\n\n////////////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec2 Saturate(in vec2 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvec2 GetTileIndex(in vec2 uv)\n{\n    return floor(vec2(uv.x, uv.y) * vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0)) - 1.0;\n}\n\nvec2 ConvertTileCoordsToScreenUV(in vec2 tileCoords)\n{\n    return (tileCoords + vec2(1.5)) / vec2(float(CELLS_WIDE) + 2.0, float(CELLS_TALL) + 2.0);\n}\n\nbool IsBombermanAlive(in float xPosition)\n{\n    return (xPosition >= -10.0);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MtV3Ry",
    "date": "1484961464",
    "viewed": 689,
    "name": "Colored Mandelbrot Set",
    "description": "Colored Mandelbrot Set\nBased on https://blogs.msdn.microsoft.com/shawnhar/2006/12/12/technicolor-julias/",
    "likes": 0,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "mandelbrot"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 uv = fragCoord.xy / iResolution.yy;\n    \n    float z = 1.0 + cos(iTime * 0.125) * 0.99;\n    vec2 o = (iMouse.z > 0.0) ? iMouse.xy / iResolution.xy * vec2(2.0) - vec2(2.2, 1.3) : -vec2(1.2, 0.32);    \n    vec2 c = (uv - vec2(0.5)) * z + o;\n    \n    vec2 v = vec2(0);\n    float m = 0.0; \n    const float r = 5.0;   \t    \n    for (int i = 0; i < 256; ++i)\n    {\n        v = vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y) + c;\n        m = (dot(v, v) < (r * r)) ? (m + 1.0) : m;\n        v = clamp(v, -r, r);\n    }  \n    fragColor = (int(m) != 256) ? sin(m / vec4(4, 8, 12, 1)) * 0.25 + 0.75 : vec4(0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtK3Rt",
    "date": "1476228850",
    "viewed": 869,
    "name": "Silly Spiral",
    "description": "Nothing special just thought it looked pretty cool.",
    "likes": 18,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "spiral"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Update 10/12/16: Hash function update to fix artifacts on mobile. \n\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n// noise functions based on iq's https://www.shadertoy.com/view/MslGD8\nfloat Hash(in vec2 p)\n{\n    return -1.0 + 2.0 * fract(sin(dot(p, vec2(12.0, 78.0))) * 43758.0);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\nfloat Spiral(in vec2 texCoord, in float rotation)\n{   \n    float spiral = sin(50.0 * (pow(length(texCoord), 0.25) - 0.02 * atan(texCoord.x, texCoord.y) - rotation));\n    return clamp(spiral, 0.0, 1.0);\n}\n\nvec3 ColoredSpiral(in vec2 texCoord, in float rotation, in vec3 c0, in vec3 c1)\n{\n    return mix(c0, c1, Spiral(texCoord, rotation));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec4 finalColor = vec4(1.0);\n\n    vec2 portalCenter = vec2(sin(iTime * 2.0), cos(iTime * 2.0)) * 0.025;\n    vec2 portalTexCoord = portalCenter + vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    vec2 pushDirection = normalize(portalTexCoord + vec2(EPSILON));\n    float noise = Noise(pushDirection + iTime) * 0.15 * length(portalTexCoord);\n\n    portalTexCoord = portalTexCoord + (-noise * pushDirection);\n    float r = length(portalTexCoord);\n\n    vec3 portalColor = ColoredSpiral(portalTexCoord, 0.1 * iTime, vec3(0.0, 0.6, 0.0), vec3(0.35, 1.0, 0.0)); \n    finalColor.rgb = mix(finalColor.rgb, mix(portalColor, vec3(0.6, 1.0, 0.35), 0.01 + (r * r)), step(r, 1.0));     \n\n    fragColor = finalColor;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlcSRf",
    "date": "1480747628",
    "viewed": 997,
    "name": "2D Rope Example",
    "description": "A simple 2D rope demo I quickly hacked together.  Could be improved with stretching/tension forces.  May revisit it later.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "interactive",
     "multipass",
     "rope"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float MAX_ROPE_POINTS = 20.0;\nconst vec4 txRopePoints = vec4(0.0, 0.0, MAX_ROPE_POINTS, 0.0);\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadRope(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy);\n}\n\nfloat Saturate(in float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 Saturate(in vec2 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat sdfCapsule(in vec2 p, in vec2 pointA, in vec2 pointB, in float radius)\n{\n    vec2 lineBA = pointB - pointA;\n    vec2 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = (iResolution.x / iResolution.y);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    uv.x *= aspectRatio;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(int i = 0; i < int(MAX_ROPE_POINTS - 1.0); ++i)\n    {\n        float ropeIndex = float(i);\n        vec2 currentPoint = LoadRope(vec2(ropeIndex - 0.5, 0.0)).xy;\n        vec2 nextPoint = LoadRope(vec2(ropeIndex + 1.0 - 0.5, 0.0)).xy;\n\n        if((distance(currentPoint, nextPoint) > 0.0) && (sdfCapsule(uv, currentPoint, nextPoint, 0.075) < 0.0))\n        {\n            finalColor = vec3(mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), (ropeIndex / MAX_ROPE_POINTS)));\n        }\n    }\n\tfragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "const float MAX_ROPE_POINTS = 20.0;\nconst float MAX_ROPE_SEPERATION = 0.09;\nconst vec4 txRopePoints = vec4(0.0, 0.0, MAX_ROPE_POINTS, 0.0);\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadRope(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy);\n}\n\nvoid StoreRope(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvec4 ConstrainRope(in vec4 ropeParameters, in float forceIndex)\n{\n    const float gravityAmount = 0.98;\n    vec2 gravity = iTimeDelta * vec2(0.0, -gravityAmount);\n    \n    vec2 forcePoint = LoadRope(vec2(forceIndex - 0.5, 0.0)).xy;\n    vec2 q = ropeParameters.xy - forcePoint.xy;\n    float pointDistance = length(q);\n\n    if(pointDistance <= 0.0) // catching bug if distance == 0.0\n    {\n        ropeParameters.xy += gravity;\n    }\n    else\n    {\n        float pastLimit = max(pointDistance - MAX_ROPE_SEPERATION, 0.0);\n\n        // clamp rope distance\n        vec2 towardsPrev = normalize(q);\n        ropeParameters.xy += -towardsPrev * pastLimit; \n\n        // is a hack\n        const float tension = 0.01;\n        ropeParameters.zw += -towardsPrev * tension;\n    }  \n    return ropeParameters;\n}\n\nvec4 MoveRope(in vec4 ropeParameters, in float index)\n{\n    const float gravityAmount = 0.98;\n    if(index >= 1.0)\n    {\n        vec2 gravity = iTimeDelta * vec2(0.0, -gravityAmount);\n        ropeParameters.zw += gravity;\n        ropeParameters.xy += ropeParameters.zw;\n\n        ropeParameters = ConstrainRope(ropeParameters, index - 1.0);\n    }\n    return ropeParameters;\n}\n\nvec2 gPinPoint = vec2(0.0, 0.9);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     float aspectRatio = (iResolution.x / iResolution.y);\n    \n     // don't compute rope if not needed\n    if(fragCoord.x > MAX_ROPE_POINTS || fragCoord.y > 2.0) discard;\n\n    vec4 ropeParameters = LoadRope(fragCoord.xy - 0.5);\n    \n    if(iFrame <= 1) ropeParameters = vec4(gPinPoint.x, gPinPoint.y + floor(fragCoord.x) * -MAX_ROPE_SEPERATION, 0.0, 0.0);\n\n    if((iMouse.z > 0.0) && (fragCoord.x >= 1.0))\n    { \n        ropeParameters = vec4((2.0 * (iMouse.xy / iResolution.xy) - 1.0), 0.0, 0.0);\n        ropeParameters.x *= aspectRatio;\n    }  \n    ropeParameters = MoveRope(ropeParameters, fragCoord.x);\n    \n    fragColor = vec4(0.0);  \n    StoreRope(txRopePoints, ropeParameters, fragColor, fragCoord);\n}",
     "name": "Buf A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4tVSzz",
    "date": "1482595710",
    "viewed": 972,
    "name": "Open Sign",
    "description": "a simple sdf open sign with glow",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "glow",
     "multipass"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Combine\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 signColor = texture(iChannel0, uv).rgb;\n    vec3 blurredSamples = texture(iChannel1, uv).rgb * 5.0;\n\tfragColor = vec4(signColor + blurredSamples, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Scene\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         32\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 20.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\nconst float \tRED_DIM\t\t= 4.0;\nconst float \tRED_LIT\t\t= 3.0;\nconst float \tBLUE_LIT \t= 2.0;\nconst float \tBLUE_DIM \t= 1.0;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n    \n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(in vec3 p, in vec3 boxSize)\n{\n  \tvec3 d = abs(p) - boxSize;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xy) - torusDimensions.x, p.z);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfCapsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    float lightTimer = mod(iTime, 6.0);\n    \n    IntersectionData oIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 1.0) ? RED_DIM : RED_LIT);\n    oIntersectionData.mT = sdTorus(p - vec3(-2.1, 0.0, 0.0), vec2(1.0, 0.1));\n    \n\tIntersectionData pIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 2.0) ? RED_DIM : RED_LIT);\n    pIntersectionData.mT = sdfCapsule(p, vec3(-0.6, -1.0, 0.0), vec3(-0.6, 1.0, 0.0), 0.1);\n    pIntersectionData.mT = min(pIntersectionData.mT, sdfCapsule(p, vec3(-0.6, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.1));\n    pIntersectionData.mT = min(pIntersectionData.mT, sdfCapsule(p, vec3(-0.6, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 0.1));\n    float halfLoop = sdTorus(p - vec3(0.0, 0.5, 0.0), vec2(0.5, 0.1));\n    pIntersectionData.mT = min(pIntersectionData.mT, (p.x < 0.0) ?  MAX_DISTANCE : halfLoop);\n    \n    IntersectionData eIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 3.0) ? RED_DIM : RED_LIT);\n    eIntersectionData.mT = sdfCapsule(p, vec3(1.0, -1.0, 0.0), vec3(1.0, 1.0, 0.0), 0.1);\n    eIntersectionData.mT = min(eIntersectionData.mT, sdfCapsule(p, vec3(1.0, 0.0, 0.0), vec3(1.8, 0.0, 0.0), 0.1));\n    eIntersectionData.mT = min(eIntersectionData.mT, sdfCapsule(p, vec3(1.0, 1.0, 0.0), vec3(1.8, 1.0, 0.0), 0.1));\n    eIntersectionData.mT = min(eIntersectionData.mT, sdfCapsule(p, vec3(1.0, -1.0, 0.0), vec3(1.8, -1.0, 0.0), 0.1));\n       \n    IntersectionData nIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 4.0) ? RED_DIM : RED_LIT);\n    nIntersectionData.mT = sdfCapsule(p, vec3(2.3, -1.0, 0.0), vec3(2.3, 1.0, 0.0), 0.1);\n    nIntersectionData.mT = min(nIntersectionData.mT, sdfCapsule(p, vec3(3.4, -1.0, 0.0), vec3(2.3, 1.0, 0.0), 0.1));\n    nIntersectionData.mT = min(nIntersectionData.mT, sdfCapsule(p, vec3(3.4, -1.0, 0.0), vec3(3.4, 1.0, 0.0), 0.1));\n    \n    oIntersectionData = GetClosestIntersection(oIntersectionData, pIntersectionData);\n    eIntersectionData = GetClosestIntersection(eIntersectionData, nIntersectionData);\n    oIntersectionData = GetClosestIntersection(oIntersectionData, eIntersectionData);\n    \n    IntersectionData edgeIntersectionData = IntersectionData(MAX_DISTANCE, (lightTimer < 0.5) ? BLUE_DIM : BLUE_LIT);\n    edgeIntersectionData.mT = sdfCapsule(p, vec3(4.0, -1.5, 0.0), vec3(4.0, 1.5, 0.0), 0.1);\n    edgeIntersectionData.mT = min(edgeIntersectionData.mT, sdfCapsule(p, vec3(-3.7, -1.5, 0.0), vec3(-3.7, 1.5, 0.0), 0.1));\n    edgeIntersectionData.mT = min(edgeIntersectionData.mT, sdfCapsule(p, vec3(4.0, -1.5, 0.0), vec3(-3.7, -1.5, 0.0), 0.1));\n    edgeIntersectionData.mT = min(edgeIntersectionData.mT, sdfCapsule(p, vec3(4.0, 1.5, 0.0), vec3(-3.7, 1.5, 0.0), 0.1));\n    \n    oIntersectionData = GetClosestIntersection(oIntersectionData, edgeIntersectionData);\n    \n    return oIntersectionData;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }    \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 CalculateLighting(in vec3 normal, in vec3 albedo, in float ambient)\n{       \n    vec3 n = normalize(normal);\n    vec3 l = normalize(vec3(0.0, 0.0, -1.0));\n    return (albedo * ambient) + albedo * Saturate(dot(n, l));\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    // Gets the intersection point from the camera ray to camera facing plane that the core is on\n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == RED_LIT)\n        {\n\t\t\tdiffuse = vec3(1.0, 0.2, 0.2);\n        }\n        else if(intersection.mMaterialIndex == RED_DIM)\n        {\n            diffuse = vec3(0.125, 0.05, 0.05);\n        }\n        else if(intersection.mMaterialIndex == BLUE_LIT)\n        {\n\t\t\tdiffuse = vec3(0.2, 0.2, 1.0);\n        }\n        else if(intersection.mMaterialIndex == BLUE_DIM)\n        {\n            diffuse = vec3(0.05, 0.05, 0.125);\n        }\n        finalColor += CalculateLighting(normal, diffuse, ambient);         \n    }\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.3) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x * 0.5 - 0.25) * (PI * 1.0) : 0.0; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 4.0;\n    vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n    fragColor = DisplayScene(cameraPosition, cameraDirection, 0.4);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Horizontal blur with limit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelOffset = vec2(1.0, 0.0) / iResolution.xy;\n    \n    float weight = 8.0;\n    vec3 horizontalSamples = texture(iChannel0, uv).rgb * weight;\n    \n    const int horizontalHalfSampleCount = 16;\n    for(int i = 1; i < horizontalHalfSampleCount; ++i)\n    {\n        float currentWeight = float(horizontalHalfSampleCount - i);\n        \n        vec3 sampleA = texture(iChannel0, uv + pixelOffset * float(i)).rgb;\n    \thorizontalSamples += (length(sampleA) > 0.6) ? sampleA * currentWeight : vec3(0.0);\n        weight += currentWeight;\n        \n    \tvec3 sampleB = texture(iChannel0, uv - pixelOffset * float(i)).rgb;\n        horizontalSamples += (length(sampleB) > 0.6) ? sampleB * currentWeight: vec3(0.0);\n        weight += currentWeight;\n    }\n    horizontalSamples *= (1.0 / weight);\n\n\tfragColor = vec4(horizontalSamples, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2016\n// Vertical blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelOffset = vec2(0.0, 1.0) / iResolution.xy;\n    \n    float weight = 0.0;\n    vec3 verticalSamples = vec3(0.0);\n    \n    const int verticalHalfSampleCount = 16;\n    for(int i = 1; i < verticalHalfSampleCount; ++i)\n    {\n        float currentWeight = float(verticalHalfSampleCount - i);\n        \n    \tverticalSamples += texture(iChannel0, uv + pixelOffset * float(i)).rgb * currentWeight;\n        weight += currentWeight;\n    \tverticalSamples += texture(iChannel0, uv - pixelOffset * float(i)).rgb * currentWeight;\n        weight += currentWeight;\n    }\n    verticalSamples *= (1.0 / weight);\n    \n\tfragColor = vec4(verticalSamples, 1.0);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MlyXR1",
    "date": "1484513120",
    "viewed": 1299,
    "name": "Simple Shadowmap",
    "description": "A simple sdf shadowmap example.  Still need to fix aliasing/artifact issues.",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "sdf",
     "shadow",
     "spotlight",
     "multipass",
     "shadowmap"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         128\n#define \tAA \t\t\t\t\t\t2\n#define \tPOISSON_SAMPLING\t\t1\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 500.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\nconst float \tTORUS \t\t\t= 2.0;\nconst float \tGROUND \t\t\t= 1.0;\n\n//////////////////////////////////////////////////\n// Globals\nmat4 gLightViewMatrix;\nvec3 gLightPosition;\nvec3 gLightDirection;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfPlane(in vec3 p, in vec4 normal)\n{\n  \t// n must be normalized\n\treturn dot(p, normal.xyz) + normal.w;\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);\n    \n    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));\n    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale); \n    IntersectionData torusIntersectionData = IntersectionData(sdfTorus(p + curvePoint, vec2(2.0, 0.5)), TORUS);\n\n    return GetClosestIntersection(planeIntersectionData, torusIntersectionData);\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n\n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }   \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nmat4 CreateViewMatrix(in vec3 cameraPosition, in vec3 cameraForward, in vec3 cameraUp)\n{\n    vec3 rightAxis = normalize(cross(cameraForward, cameraUp));\n\n    mat4 viewMatrix = mat4(rightAxis.xyz, 0.0,\n\t\t\t\t\t\t   cameraUp.xyz, 0.0,\n                           cameraForward.xyz, 0.0,\n                           cameraPosition.xyz, 1.0);\n    \n    return viewMatrix;\n}\n\nvec2 CalculateShadowMapUV(in mat4 shadowMapMatrix, in vec3 position, in float aspectRatio)\n{\n    vec3 lightPosition = vec3(shadowMapMatrix[3][0], shadowMapMatrix[3][1], shadowMapMatrix[3][2]); \n    \n    vec3 lightWorldDirection = normalize(position.xyz - lightPosition);\n    vec3 shadowMapCameraRayDirection = (vec4(lightWorldDirection.xyz, 1.0) * shadowMapMatrix).xyz;\n    shadowMapCameraRayDirection /= shadowMapCameraRayDirection.z;\n    \n    vec2 textureCoords = shadowMapCameraRayDirection.xy / vec2(aspectRatio, 1.0);\n    textureCoords = textureCoords * 0.5 + 0.5;\n    \n    return textureCoords;\n}\n\nfloat SampleShadowMap(in vec2 shadowCoords)\n{\n    return texture(iChannel0, shadowCoords).r;\n}\n\nvec2 SamplePoissonDisk(in int i)\n{\n    if(i == 0) \t\t{ return vec2(-0.942016240, -0.39906216); }\n    else if(i == 1) { return vec2( 0.945586090, -0.76890725); }\n    else if(i == 2) { return vec2(-0.094184101, -0.92938870); }\n    else \t\t\t{ return vec2( 0.344959380,  0.29387760); }\n}\n\nfloat SampleShadowMap(in vec3 point, in float shadowMapBias)\n{\n\tconst float shadowMapMaxDistance = 23.0;\n    \n    float shadow = 1.0;\n    \n    vec3 pointToLight = point - gLightPosition;\n    float distanceToLight = length(pointToLight);\n    \n    vec2 shadowCoords = CalculateShadowMapUV(gLightViewMatrix, point, (iResolution.x / iResolution.y));\n    \n    if((shadowCoords.x > EPSILON && shadowCoords.y > EPSILON) && (shadowCoords.x < (1.0 - EPSILON) && shadowCoords.y < (1.0 - EPSILON)))\n    {\n#if POISSON_SAMPLING        \n        for(int i = 0; i < 4; ++i)\n        {\n            const float poissonDiskSpread = 0.00125;\n            float shadowMap = SampleShadowMap(shadowCoords + (SamplePoissonDisk(i) * poissonDiskSpread));\n            \n            float shadowMapDistance = (shadowMap * shadowMapMaxDistance);\n\n            if(shadowMapDistance < (distanceToLight - shadowMapBias))\n            {\n                shadow -= 0.25;\n            }   \n        }\n#else\n        float shadowMap = SampleShadowMap(shadowCoords);\n        float shadowMapDistance = (shadowMap * shadowMapMaxDistance);\n\n        if(shadowMapDistance < (distanceToLight - shadowMapBias))\n        {\n            shadow = 0.0;\n        }     \n#endif\n    }\n    return shadow;\n}\n\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)\n{       \n    vec3 lightToPoint = gLightPosition - point;\n    float spot = step(0.7, dot(normalize(lightToPoint), gLightDirection)) * Saturate(1.0 - length(lightToPoint) / 30.0);\n    float lighting = Saturate(dot(normal, -gLightDirection)) * spot;\n    \n    // Slope bias\n    float shadowMapBias = clamp(0.1 * tan(acos(Saturate(dot(normal, gLightDirection)))), 0.0, 0.1);\n    float shadow = SampleShadowMap(point, shadowMapBias);\n    \n    return (albedo * lighting * shadow) + (albedo * ambient);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n       \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        const float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == TORUS)\n        {\n\t\t\tdiffuse = vec3(1.0, 0.4, 0.0);\n        }\n        else if(intersection.mMaterialIndex == GROUND)\n        {\n            float tile = mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;\n            diffuse = vec3(0.5) + tile;\n        }\n        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, ambient);         \n    }\n    \n    vec3 fogColor = vec3(0.85, 0.85, 1.0);\n    float fogAmount = 1.0 - exp(-intersection.mT * 0.015);\n    finalColor = mix(finalColor, fogColor, fogAmount);\n                          \n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 finalColor = vec4(0.0);\n    \n    // Setup light\n    gLightPosition = vec3(0.0, 8.0, 0.0);\n    gLightDirection = normalize(vec3(0.0, 1.0, 0.0));\n    gLightViewMatrix = CreateViewMatrix(gLightPosition, gLightDirection, vec3(0.0, 0.0, -1.0));\n    \n    vec2 initialScreenCoord = (fragCoord.xy / iResolution.xy);\n#if (AA > 1)\n    for(int x = 0; x < AA; ++x)\n    {\n    \tfor(int y = 0; y < AA; ++y)\n        {\n    \t\tvec2 offset = vec2(float(x), float(y)) / float(AA) - 0.5; \t\n    \t\tvec2 screenCoord = ((fragCoord.xy + offset) / iResolution.xy);\n#else\n    \t\t// Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    \t\tvec2 screenCoord = (fragCoord.xy / iResolution.xy);   \n#endif\n            vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n            float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.3) : 0.0;\n            mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n            float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05; // Multiply by 0.1 to slow down the rotation ;   \n            mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n            // Determine our camera info\n            const float distanceFromOrigin = 8.0;\n            vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n            cameraPosition += vec3(0.0, 2.0, 0.0);\n            vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n            finalColor += DisplayScene(cameraPosition, cameraDirection);\n#if (AA > 1)\n    \t}\n    }\n\tfinalColor /= float(AA * AA);        \n#endif         \n\n    if(initialScreenCoord.x < 0.2 && initialScreenCoord.y > 0.8)\n    {\n        finalColor = texture(iChannel0, vec2(initialScreenCoord.x, (1.0 - initialScreenCoord.y)) * 5.0);\n    }\n\tfragColor = finalColor;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Alexander Lemke, 2017\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         128\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_SHADOW_MAP_DISTANCE\t\t= 23.0;\nconst float     EPSILON        \t\t\t \t= 0.001;\nconst float     PI              \t\t\t= 3.14159265359;\n\n//////////////////////////////////////////////////\n// Globals\nvec3 gCameraPosition;\nvec3 gCameraDirection;\n\n//////////////////////////////////////////////////////\n// Intersection Helpers   \nfloat GetClosestIntersection(in float a, in float b)\n{\n    if(a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfPlane(in vec3 p, in vec4 normal)\n{\n  \t// n must be normalized\n  \treturn dot(p, normal.xyz) + normal.w;\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nfloat CheckSceneForIntersection(in vec3 p)\n{\n    float planeT = sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0));\n    \n    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));\n    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale);\n    float torusT = sdfTorus(p + curvePoint, vec2(2.0, 0.5));\n\n    return GetClosestIntersection(planeT, torusT);\n}\n\nfloat Intersect(in Ray initialRay)\n{    \n    float sceneIntersection = MAX_SHADOW_MAP_DISTANCE;\n    \n    float t = 0.0;   \n \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection < EPSILON || t > MAX_SHADOW_MAP_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection; // Step forward\n    }\n    sceneIntersection = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nfloat DisplayShadowMap(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection); \n    return Intersect(cameraRay);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n    // Determine our camera info\n    gCameraPosition = vec3(0.0, 8.0, 0.0);\n    gCameraDirection = normalize(vec3(aspectRatioAdjustedUVs.x, -1.0, aspectRatioAdjustedUVs.y));\n\n    float t = DisplayShadowMap(gCameraPosition, gCameraDirection, 0.4);\n    float shadowMapValue = min(t / MAX_SHADOW_MAP_DISTANCE, 1.0);\n    \n\tfragColor = vec4(vec3(shadowMapValue), 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4lKSzK",
    "date": "1485061275",
    "viewed": 672,
    "name": "Worley/Cell Noise",
    "description": "Worley and Cell Noise\nHopefully I'm doing this right.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "noise",
     "worley",
     "cell"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 Hash2D(in vec2 p)\n{\n    return fract(sin(p * mat2(12.98, 78.23, 127.99, 311.33)) * 43758.54);\n}\n\nvec3 DisplayNoise(in vec4 d)\n{\n    float toggle = mod(floor(iTime * 0.5), 6.0);\n    \n    vec3 color = d.xxx;\n    \n    if(toggle == 1.0) \t\tcolor = vec3(1.0 - d.x);\n    else if(toggle == 2.0) \tcolor = vec3(d.y - d.x);     \n    else if(toggle == 3.0) \tcolor = vec3(d.z - d.y);\n    else if(toggle == 4.0) \tcolor = vec3(d.z - d.x);  \n    else if(toggle == 5.0) \tcolor = d.xyz;   \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy * 12.0;\n    vec2 i = floor(uv);\n    vec2 n = fract(uv);\n    vec4 minD = vec4(9.0);\n    \n    for (float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 point = sin(iTime + 32.0 * Hash2D(i + vec2(x, y))) * 0.5 + 0.5;\n            float d = length(vec2(x, y) + point - n);\n            \n            minD = (d < minD.x) ? vec4(d, minD.xyz) \n               \t : (d < minD.y) ? vec4(minD.x, d, minD.yz) \n               \t : (d < minD.z) ? vec4(minD.xy, d, minD.z) \n               \t : (d < minD.w) ? vec4(minD.xyz, d) \n                 : minD;\n        }\n    }\n    fragColor = vec4(DisplayNoise(minD), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}